{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"flowpaths Python Package","text":"<p>This package implements fast solvers for decomposing weighted directed graphs into weighted paths or walks, based on (Mixed) Integer Linear Programming ((M)ILP) formulations. It supports both acyclic graphs (DAGs, decomposed into paths) and general graphs with cycles (decomposed into walks), and makes it easy to create new decomposition models.</p> <p></p>"},{"location":"index.html#installation","title":"Installation","text":"<pre><code>pip install flowpaths\n</code></pre> <p>Info</p> <p>Flowpaths is being developed on GitHub.</p>"},{"location":"index.html#basic-usage-examples","title":"Basic usage examples","text":"<pre><code>import flowpaths as fp\nimport networkx as nx\n\n# Create a simple graph\ngraph = nx.DiGraph()\ngraph.add_edge(\"s\", \"a\", flow=2)\ngraph.add_edge(\"a\", \"t\", flow=2)\ngraph.add_edge(\"s\", \"b\", flow=5)\ngraph.add_edge(\"b\", \"t\", flow=5)\n# ...\n\n# Create a Minimum Flow Decomposition solver\nmfd_solver = fp.MinFlowDecomp(graph, flow_attr=\"flow\") \n\nmfd_solver.solve() # We solve it\n\nif mfd_solver.is_solved(): # We get the solution\n    print(mfd_solver.get_solution())\n    # {'paths': [['s', 'b', 't'], ['s', 'a', 't']], 'weights': [5, 2]}\n</code></pre> <p>For graphs with cycles, use the cyclic variants which return walks rather than simple paths:</p> <pre><code>import flowpaths as fp\nimport networkx as nx\n\nG = nx.DiGraph()\nG.add_edge(\"s\", \"a\", flow=1)\nG.add_edge(\"a\", \"b\", flow=2)  # part of a cycle\nG.add_edge(\"b\", \"a\", flow=2)  # part of a cycle\nG.add_edge(\"a\", \"t\", flow=1)\n\nmfd_solver = fp.MinFlowDecompCycles(G, flow_attr=\"flow\")\nmfd_solver.solve()\nif mfd_solver.is_solved():\n    print(mfd_solver.get_solution())\n    # {'walks': [['s', 'a', 'b', 'a', 'b', 'a', 't']], 'weights': [1]}\n</code></pre> <p>More examples</p> <p>For more examples, see GitHub examples/.</p>"},{"location":"index.html#design-principles","title":"Design principles","text":"<ol> <li> <p>Easy to use: You pass a directed graph (as a networkx DiGraph), and the solvers return optimal weighted paths (or walks for cyclic models). See the examples folder.</p> </li> <li> <p>It just works: You do not need to install an (M)ILP solver. This is possible thanks to the fast open source solver HiGHS, which gets installed once you install this package. </p> <ul> <li>If you have a Gurobi license (free for academic users), you can install the gurobipy Python package, and then you can run the Gurobi solver instead of the default HiGHS solver by just passing the entry <code>\"external_solver\": \"gurobi\"</code> in the <code>solver_options</code> dictionary.</li> </ul> </li> <li> <p>Easy to implement other decomposition models: </p> <ul> <li>For DAGs, use the abstract class <code>AbstractPathModelDAG</code>, which encodes a given number of paths. See docs: Abstract Path Model.</li> <li>For general directed graphs with cycles, use <code>AbstractWalkModelDiGraph</code>, which encodes a given number of walks. See docs: Abstract Walk Model.</li> </ul> <p>You can inherit from these classes to add weights and model-specific constraints/objectives. See a basic example. These abstract classes interface with a wrapper for popular MILP solvers, so you don\u2019t need to worry about solver-specific details.</p> </li> <li> <p>Fast: Having solvers implemented using <code>AbstractPathModelDAG</code> or <code>AbstractWalkModelDiGraph</code> means that any optimization to the path-/walk-finding mechanisms benefits all solvers that inherit from these classes. In particular, in these abstract classes we implement \u201csafety optimizations\u201d described in this paper (for DAGs) and this paper (for general graphs), based on ideas first introduced in this paper. These can provide up to 1000x speedups, depending on the graph instance, while preserving global optimality (under some simple assumptions).</p> </li> <li> <p>Flexible inputs: The models support graphs with flows/weights on either edges or nodes, and additional real use-case input features, such as subpathconstraints or subset constraints.</p> </li> </ol>"},{"location":"index.html#models-currently-implemented","title":"Models currently implemented","text":"<ul> <li> <p>Minimum Flow Decomposition: Given a graph with flow values on its edges (i.e. at every node different from source or sink the flow entering the node is equal to the flow exiting the node), find the minimum number of weighted paths / walks such that, for every edge, the sum of the weights of the paths going through the edge equals the flow value of the edge.</p> </li> <li> <p>k-Least Absolute Errors: Given a graph with weights on its edges, and a number \\(k\\), find \\(k\\) weighted paths / walks such that the sum of the absolute errors of each edge is minimized. </p> <ul> <li>The error of an edge is defined as the weight of the edge minus the sum of the weights of the paths / walks going through it.</li> </ul> </li> <li> <p>k-Minimum Path Error: Given a graph with weights on its edges, and a number \\(k\\), find \\(k\\) weighted paths / walks, with associated slack values, such that:</p> <ul> <li>The error of each edge (defined as in \\(k\\)-Least Absolute Errors above) is at most the sum of the slacks of the paths / walks going through the edge, and</li> <li>The sum of path / walk slacks is minimized.</li> </ul> </li> <li> <p>Minimum Path Cover: Given a graph and node sets S and T, find a minimum number of S-T paths (if the graph is acyclic) or S-T walks (if the graph has cycles) such that every edge appears in at least one path or walk.</p> </li> </ul>"},{"location":"index.html#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please read the CONTRIBUTING.md guide for how to set up a dev environment, run tests locally, and build/preview the documentation with Material for MkDocs.</p>"},{"location":"abstract-path-model.html","title":"Abstract Path Model in DAGs","text":"<p>A general approach in developing a model to decompose a weighted graph into weighted paths is to:</p> <ol> <li>Fix \\(k\\), the number of paths. </li> <li>Formulate in ILP the \\(k\\) paths; that is adding a set of \\(k\\) variables and suitable constraints constraints such that the \\(i\\)-th set of variables encodes the \\(i\\)-th path.</li> <li>Add additional variables, constraints, or set the objective function, that these paths must satisfy.</li> <li>Iterate the above process for different values of \\(k\\), until the \u201cbest\u201d one is found (\u201cbest\u201d depends on the problem). See our implementation of a basic routine for this step.</li> </ol> <p>For step 2. above we provide the abstract class <code>AbstractPathModelDAG</code> which models a given number \\(k\\) of paths in a given acyclic graph \\(G = (V,E)\\). For simplicity, \\(G\\) must have a single source \\(s\\) and a single sink \\(t\\), see our class stDiGraph. (The <code>stDiGraph</code> class adds these automatically for any NetworkX DiGraph, and keeps track of their incident edges.) This approach appeared in this paper.</p> <p>More in detail, for every edge \\((u,v) \\in E\\), and for every path index \\(i \\in \\{0,\\dots,k-1\\}\\), we add a binary variable \\(x_{u,v,i} \\in \\{0,1\\}\\). We add constraints on these variables to ensure that for every \\(i\\) the variables \\(x_{u,v,i}\\) that equal 1 induce an \\(s\\)-\\(t\\) path (i.e., a path from \\(s\\) to \\(t\\)). In other words \\(x_{u,v,i} = 1\\) if edge \\((u,v)\\) belongs to solution path \\(i\\), and 0 otherwise. See the paper on the specific constraints that are added to enforce that they induce an \\(s\\)-\\(t\\) path. </p> <p>For example, the edges in brown below induce an \\(s\\)-\\(t\\) path (for say \\(i = 3\\)), and notice that the \\(x_{u,v,3}\\) variables equal 1 only on the edges \\((u,v)\\) on the path.</p> <pre><code>%%{init: {'themeVariables': { 'edgeLabelBackground': 'white'}}}%%\nflowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|\"$$x_{s,a,3} = 1$$\"| a\n    a --&gt;|\"$$x_{a,b,3} = 1$$\"| b\n    s --&gt;|\"$$x_{s,b,3} = 0$$\"| b\n    a --&gt;|\"$$x_{a,c,3} = 0$$\"| c\n    b --&gt;|\"$$x_{b,c,3} = 1$$\"| c\n    c --&gt;|\"$$x_{c,d,3} = 1$$\"| d\n    d --&gt;|\"$$x_{d,t,3} = 1$$\"| t\n    c --&gt;|\"$$x_{c,t,3} = 0$$\"| t\n\n    linkStyle 0,1,4,5,6 stroke:brown,stroke-width:3;</code></pre> <p>The search for paths</p> <ul> <li>Note that we do not have the paths beforehand, and the ILP will search for paths (i.e. assignment of values to the \\(x_{u,v,i}\\) variables, under the constraints that they induce a path). </li> <li>Once a class inherits from <code>AbstractPathModelDAG</code>, it will add other variables and constraints (as in point 3. above). The ILP solver will then search for the \\(k\\) paths (i.e. find the values to the \\(x_{u,v,i}\\) variables) to satisfy all constraints.</li> </ul> <p>Example: Modelling \\(k\\)-Flow Decomposition</p> <p>Consider the problem of decomposing a network flow \\(f : E \\rightarrow \\mathbb{N}\\) over a DAG \\(G = (V,E)\\) into a given number \\(k\\) of \\(s\\)-\\(t\\) paths (k-Flow Decomposition). Assume we created the \\(x_{u,v,i}\\) variables as above. Thus, we just need to implement point 3. above.</p> <ul> <li>We introduce a variable \\(w_i\\) (integer or continuous) modeling the weight of path \\(i\\), for every \\(i \\in \\{0,\\dots,k-1\\}\\).</li> <li>We need to enforce the \u201cflow explanation\u201d constraint: $$ f(u,v) = \\sum_{i=0}^{k-1} x_i \\cdot w_i, ~~\\forall (u,v) \\in E. $$ Note that in the above \\(f(u,v)\\) is a constant. Moreover, \\(x_i \\cdot w_i\\) is not a linear term (as required by an Integer Linear Program), but it can be easily linearized via additional variables and constraints. However, our <code>SolverWrapper</code> class provides the method <code>add_binary_continuous_product_constraint()</code> to directly encode such a non-linear constraint, without bothering to manually set up these additional variables and constraints.</li> </ul> <p>The \\(x_{u,v,i}\\) variables are implemented as <code>edge_vars[(u, v, i)]</code>, see the class documentation below.</p>"},{"location":"abstract-path-model.html#flowpaths.abstractpathmodeldag.AbstractPathModelDAG","title":"AbstractPathModelDAG","text":"<pre><code>AbstractPathModelDAG(\n    G: stDAG,\n    k: int,\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1,\n    subpath_constraints_coverage_length: float = None,\n    encode_edge_position: bool = False,\n    encode_path_length: bool = False,\n    length_attr: str = None,\n    optimization_options: dict = None,\n    solver_options: dict = {},\n    solve_statistics: dict = {},\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>This is an abstract class modelling a path-finding (M)ILP in a DAG. The design of this package is based on the following principles:</p> <ul> <li>The class is designed to be extended by other classes that model specific path-finding problems in DAGs. In this way, they all benefit from the variables it encodes, and the safety optimizations it provides.</li> <li>The class uses our custom SolverWrapper class, which is a wrapper around the solvers HiGHS (open source) and  Gurobi (free with academic license). In this way, both solvers can be used interchangeably.</li> </ul> <p>More in detail, this class encodes <code>k</code> s-t paths in the DAG G, where s is the global source of the stDAG  and t is the global sink. It also allows for subpath constraints that must appear in at least one of the s-t paths.</p> <p>The class creates the following variables:</p> <ul> <li>edge_vars: <code>edge_vars[(u, v, i)]</code> = 1 if path <code>i</code> goes through edge <code>(u, v)</code>, <code>0</code> otherwise</li> <li> <p>edge_position_vars: <code>edge_position_vars[(u, v, i)]</code> = position of edge <code>(u, v)</code> in path <code>i</code>, starting from position 0</p> <ul> <li>These variables are created only if <code>encode_edge_position</code> is set to <code>True</code></li> <li>Note that positions are relative to the globals source <code>s</code> of the stDAG, thus the first edge in a path is  the edge from <code>s</code> to the first vertex in the original graph, and this first edge has position 0</li> <li>If you set <code>length_attr</code>, then the positions are relative to the edge lengths, and not the number of edges The first edge still gets position 0, and other edges get positions equal to the sum of the lengths of the edges before them in the path</li> <li>If you set <code>length_attr</code>, and an edge has missing edge length, then it gets length 1</li> </ul> </li> <li> <p>path_length_vars: <code>path_length_vars[(i)]</code> = length of path <code>i</code></p> <ul> <li>These variables are created only if <code>encode_path_length</code> is set to <code>True</code></li> <li>Note that the length of a path is the sum of the lengths of the edges in the path</li> <li>If you set <code>length_attr</code>, then the lengths are the sum of the lengths of the edges in the path</li> <li>If you set <code>length_attr</code>, and an edge has missing edge length, then it gets length 1</li> <li>NOTE: the length also includes the edges from global source to the first vertex, and from the last vertex to the global sink. By default, these do not have a length attached, so each gets length 1.</li> </ul> </li> <li> <p>solver: a solver object to solve the (M)ILP, implemented using our SolverWrapper class.</p> </li> </ul> <p>Safety optimizations</p> <p>This class uses the \u201csafety information\u201d (see https://doi.org/10.48550/arXiv.2411.03871) in the graph to fix some  <code>edge_vars</code> to 1 or 0. The safety information consists of safe paths, or safe sequences, that are guaranteed to appear in at least  one cover (made up of any number of s-t paths) of the edges in <code>trusted_edges_for_safety</code>. That is, when implementing a new path-finding (M)ILP, you can guarantee that </p> <ol> <li>The solution is made up of s-t paths</li> <li>Any solution covers all edges in <code>trusted_edges_for_safety</code>, then safety optimizations can be used to fix some <code>edge_vars</code> to 1,  which can speed up the solving process, while guaranteeing global optimality.</li> </ol>"},{"location":"abstract-path-model.html#flowpaths.abstractpathmodeldag.AbstractPathModelDAG--parameters","title":"Parameters","text":"<ul> <li> <p><code>G: stDAG.stDAG</code> </p> <p>The directed acyclic graph (DAG) to be used. Create it using the <code>stDAG</code> class.</p> </li> <li> <p><code>k: int</code></p> <p>The number of paths to be modeled.</p> </li> <li> <p><code>subpath_constraints: list</code>, optional</p> <p>A list of lists, where each list is a sequence of edges (not necessarily contiguous, i.e. path). Defaults to an empty list.</p> <p>Each sequence of edges must appear in at least one solution path; if you also pass subpath_constraints_coverage,  then each sequence of edges must appear in at least subpath_constraints_coverage fraction of some solution path, see below.</p> </li> <li> <p><code>subpath_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subpath constraints that must be covered by some solution paths, in terms of number of edges.      - Defaults to 1 (meaning that 100% of the edges of the constraint need to be covered by some solution path).</p> </li> <li> <p><code>subpath_constraints_coverage_length: float</code>, optional </p> <p>Coverage fraction of the subpath constraints that must be covered by some solution paths, in terms of length of the subpath. Defaults to <code>None</code>, meaning that this is not imposed.  - If you set this constraint, you cannot set <code>subpath_constraints_coverage</code> (and its default value of 1 will be ignored). - If you set this constraint, you also need to set <code>length_attr</code>. If an edge has missing edge length, it gets length 1.</p> </li> <li> <p><code>encode_edge_position: bool</code>, optional</p> <p>Whether to encode the position of the edges in the paths. Defaults to <code>False</code>.</p> </li> <li> <p><code>encode_path_length: bool</code>, optional</p> <p>Whether to encode the length of the paths (in terms of number of edges, or sum of lengths of edges, if set via <code>length_attr</code>). Defaults to <code>False</code>.</p> </li> <li> <p><code>length_attr: str</code>, optional</p> <p>The attribute name from where to get the edge lengths. Defaults to <code>None</code>.</p> <ul> <li>If set, then the edge positions, or path lengths (above) are in terms of the edge lengths specified in the <code>length_attr</code> field of each edge</li> <li>If set, and an edge has a missing edge length, then it gets length 1.</li> </ul> </li> <li> <p><code>optimization_options: dict</code>, optional </p> <p>Dictionary of optimization options. Defaults to <code>None</code>, in which case the default values are used. See the available optimizations.  If you pass any safety optimizations, you must also pass the dict entry <code>\"trusted_edges_for_safety\"</code> (see below).  If a child class has already solved the problem and has the solution paths, it can pass them via the dict entry <code>\"external_solution_paths\"</code> to skip the solver creation and encoding of paths (see below).</p> <ul> <li> <p><code>\"trusted_edges_for_safety\": set</code></p> <p>Set of trusted edges for safety. Defaults to <code>None</code>.</p> <p>Global optimality</p> <p>In order for the optimizations to still guarantee a global optimum, you must guarantee that:</p> <ol> <li>The solution is made up of source-to-sink paths, and</li> <li>Every edge in <code>trusted_edges_for_safety</code> appears in some solution path, for all solutions. This naturally holds for several problems, for example Minimum Flow Decomposition or [k-Minimum Path Error] where in fact, under default settings, all edges appear in all solutions.</li> </ol> </li> <li> <p><code>\"external_solution_paths\" : list</code></p> <p>External solution paths, as a list of paths, where every path is a list of nodes. Defaults to <code>None</code>. If you provide this, this class skip the solver creation and encoding of paths, and just return these paths.  This is useful when the child class managed to solver the problem in a different way,  and needs to let this class know them, in order to have a consistent API.</p> </li> </ul> </li> <li> <p><code>solver_options: dict</code>, optional</p> <p>Dictionary of solver options. Defaults to <code>{}</code>, in which case the default values are used.  See the available solver options.</p> </li> <li> <p><code>solve_statistics: dict</code>, optional</p> <p>Dictionary to store solve statistics. Defaults to <code>{}</code>.</p> </li> </ul>"},{"location":"abstract-path-model.html#flowpaths.abstractpathmodeldag.AbstractPathModelDAG--raises","title":"Raises","text":"<ul> <li>ValueError: If <code>trusted_edges_for_safety</code> is not provided when optimizing with <code>optimize_with_safe_paths</code> or <code>optimize_with_safe_sequences</code>.</li> <li>ValueError: If both <code>optimize_with_safe_paths</code> and <code>optimize_with_safe_sequences</code> are set to <code>True</code>.</li> </ul> Source code in <code>flowpaths/abstractpathmodeldag.py</code> <pre><code>def __init__(\n    self,\n    G: stdag.stDAG,\n    k: int,\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1,\n    subpath_constraints_coverage_length: float = None,\n    encode_edge_position: bool = False,\n    encode_path_length: bool = False,\n    length_attr: str = None,\n    optimization_options: dict = None,\n    solver_options: dict = {},\n    solve_statistics: dict = {},\n):\n    \"\"\"\n    Parameters\n    ----------\n\n    - `G: stDAG.stDAG`  \n\n        The directed acyclic graph (DAG) to be used. Create it using the [`stDAG` class](stdag.md).\n\n    - `k: int`\n\n        The number of paths to be modeled.\n\n    - `subpath_constraints: list`, optional\n\n        A list of lists, where each list is a sequence of edges (not necessarily contiguous, i.e. path). Defaults to an empty list.\n\n        Each sequence of edges must appear in at least one solution path; if you also pass subpath_constraints_coverage, \n        then each sequence of edges must appear in at least subpath_constraints_coverage fraction of some solution path, see below.\n\n    - `subpath_constraints_coverage: float`, optional\n\n        Coverage fraction of the subpath constraints that must be covered by some solution paths, in terms of number of edges. \n            - Defaults to 1 (meaning that 100% of the edges of the constraint need to be covered by some solution path).\n\n    - `subpath_constraints_coverage_length: float`, optional \n\n        Coverage fraction of the subpath constraints that must be covered by some solution paths, in terms of length of the subpath. Defaults to `None`, meaning that this is not imposed. \n        - If you set this constraint, you cannot set `subpath_constraints_coverage` (and its default value of 1 will be ignored).\n        - If you set this constraint, you also need to set `length_attr`. If an edge has missing edge length, it gets length 1.\n\n    - `encode_edge_position: bool`, optional\n\n        Whether to encode the position of the edges in the paths. Defaults to `False`.\n\n    - `encode_path_length: bool`, optional\n\n        Whether to encode the length of the paths (in terms of number of edges, or sum of lengths of edges, if set via `length_attr`). Defaults to `False`.\n\n    - `length_attr: str`, optional\n\n        The attribute name from where to get the edge lengths. Defaults to `None`.\n\n        - If set, then the edge positions, or path lengths (above) are in terms of the edge lengths specified in the `length_attr` field of each edge\n        - If set, and an edge has a missing edge length, then it gets length 1.\n\n    - `optimization_options: dict`, optional \n\n        Dictionary of optimization options. Defaults to `None`, in which case the default values are used. See the [available optimizations](solver-options-optimizations.md). \n        If you pass any safety optimizations, you must also pass the dict entry `\"trusted_edges_for_safety\"` (see below). \n        If a child class has already solved the problem and has the solution paths, it can pass them via the dict entry `\"external_solution_paths\"` to skip the solver creation and encoding of paths (see below).\n\n        - `\"trusted_edges_for_safety\": set`\n\n            Set of trusted edges for safety. Defaults to `None`.\n\n            !!! warning \"Global optimality\"\n                In order for the optimizations to still guarantee a global optimum, you must guarantee that:\n\n                1. The solution is made up of source-to-sink paths, and\n                2. Every edge in `trusted_edges_for_safety` appears in some solution path, for all solutions. This naturally holds for several problems, for example [Minimum Flow Decomposition](minimum-flow-decomposition.md) or [k-Minimum Path Error] where in fact, under default settings, **all** edges appear in all solutions.\n\n        - `\"external_solution_paths\" : list`\n\n            External solution paths, as a list of paths, where every path is a list of nodes. Defaults to `None`.\n            If you provide this, this class skip the solver creation and encoding of paths, and just return these paths. \n            This is useful when the child class managed to solver the problem in a different way, \n            and needs to let this class know them, in order to have a consistent API.\n\n    - `solver_options: dict`, optional\n\n        Dictionary of solver options. Defaults to `{}`, in which case the default values are used. \n        See the [available solver options](solver-options-optimizations.md).\n\n    - `solve_statistics: dict`, optional\n\n        Dictionary to store solve statistics. Defaults to `{}`.\n\n\n    Raises\n    ----------\n    - ValueError: If `trusted_edges_for_safety` is not provided when optimizing with `optimize_with_safe_paths` or `optimize_with_safe_sequences`.\n    - ValueError: If both `optimize_with_safe_paths` and `optimize_with_safe_sequences` are set to `True`.\n    \"\"\"\n\n    self.G = G\n    if G.number_of_edges() == 0:\n        utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n        raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n    self.id = self.G.id\n    self.k = k\n    self.length_attr = length_attr\n\n    self.subpath_constraints = copy.deepcopy(subpath_constraints)\n    if self.subpath_constraints is not None:\n        self._check_valid_subpath_constraints()\n\n    self.subpath_constraints_coverage = subpath_constraints_coverage\n    self.subpath_constraints_coverage_length = subpath_constraints_coverage_length\n    if len(subpath_constraints) &gt; 0:\n        if self.subpath_constraints_coverage &lt;= 0 or self.subpath_constraints_coverage &gt; 1:\n            utils.logger.error(f\"{__name__}: subpath_constraints_coverage must be in the range (0, 1]\")\n            raise ValueError(\"subpath_constraints_coverage must be in the range (0, 1]\")\n\n        if self.subpath_constraints_coverage_length is not None:\n            if self.subpath_constraints_coverage_length &lt;= 0 or self.subpath_constraints_coverage_length &gt; 1:\n                utils.logger.error(f\"{__name__}: subpath_constraints_coverage_length must be in the range (0, 1]\")\n                raise ValueError(\"If set, subpath_constraints_coverage_length must be in the range (0, 1]\")\n            if self.length_attr is None:\n                utils.logger.error(f\"{__name__}: If subpath_constraints_coverage_length is set, length_attr must be provided.\")\n                raise ValueError(\"If subpath_constraints_coverage_length is set, length_attr must be provided.\")\n            if self.subpath_constraints_coverage &lt; 1:\n                utils.logger.error(f\"{__name__}: If subpath_constraints_coverage_length is set, you cannot set also subpath_constraints_coverage.\")\n                raise ValueError(\"If subpath_constraints_coverage_length is set, you cannot set also subpath_constraints_coverage.\")\n\n    self.solve_statistics = solve_statistics\n    self.edge_vars = {}\n    self.edge_vars_sol = {}\n    self.subpaths_vars = {}\n    self.encode_edge_position = encode_edge_position\n    self.encode_path_length = encode_path_length\n    self.edge_position_vars = {}\n\n    self.edges_set_to_zero = {}\n    self.edges_set_to_one = {}\n\n    self.solver_options = solver_options\n    if self.solver_options is None:\n        self.solver_options = {}\n    self.threads = self.solver_options.get(\"threads\", sw.SolverWrapper.threads)\n\n    # optimizations\n    if optimization_options is None:\n        optimization_options = {}\n    self.optimize_with_safe_paths = optimization_options.get(\"optimize_with_safe_paths\", AbstractPathModelDAG.optimize_with_safe_paths)\n    self.external_safe_paths = optimization_options.get(\"external_safe_paths\", None)\n    self.optimize_with_safe_sequences = optimization_options.get(\"optimize_with_safe_sequences\", AbstractPathModelDAG.optimize_with_safe_sequences)\n    self.optimize_with_subpath_constraints_as_safe_sequences = optimization_options.get(\"optimize_with_subpath_constraints_as_safe_sequences\", AbstractPathModelDAG.optimize_with_subpath_constraints_as_safe_sequences)\n    self.trusted_edges_for_safety = optimization_options.get(\"trusted_edges_for_safety\", None)\n    self.optimize_with_safe_zero_edges = optimization_options.get(\"optimize_with_safe_zero_edges\", AbstractPathModelDAG.optimize_with_safe_zero_edges)\n    self.external_solution_paths = optimization_options.get(\"external_solution_paths\", None)\n    self.allow_empty_paths = optimization_options.get(\"allow_empty_paths\", False)\n    self.optimize_with_safety_as_subpath_constraints = optimization_options.get(\"optimize_with_safety_as_subpath_constraints\", AbstractPathModelDAG.optimize_with_safety_as_subpath_constraints)\n    self.optimize_with_safety_from_largest_antichain = optimization_options.get(\"optimize_with_safety_from_largest_antichain\", AbstractPathModelDAG.optimize_with_safety_from_largest_antichain)\n\n    self._is_solved = False\n    if self.external_solution_paths is not None:\n        self._is_solved = True\n\n    # some checks\n    if self.optimize_with_safe_paths and self.external_safe_paths is None and self.trusted_edges_for_safety is None:\n        utils.logger.error(f\"{__name__}: trusted_edges_for_safety must be provided when optimizing with safe paths\")\n        raise ValueError(\"trusted_edges_for_safety must be provided when optimizing with safe lists\")        \n    if self.optimize_with_safe_sequences and self.external_safe_paths is not None:\n        utils.logger.error(f\"{__name__}: Cannot optimize with both external safe paths and safe sequences\")\n        raise ValueError(\"Cannot optimize with both external safe paths and safe sequences\")\n\n    if self.optimize_with_safe_paths and self.optimize_with_safe_sequences:\n        utils.logger.error(f\"{__name__}: Cannot optimize with both safe paths and safe sequences\")\n        raise ValueError(\"Cannot optimize with both safe paths and safe sequences\")        \n\n    self.safe_lists = []\n    if self.external_safe_paths is not None:\n        self.safe_lists = self.external_safe_paths\n    elif self.optimize_with_safe_paths and not self.is_solved() and self.trusted_edges_for_safety is not None:\n        start_time = time.perf_counter()\n        self.safe_lists += safetypathcovers.safe_paths(\n            G=self.G,\n            edges_to_cover=self.trusted_edges_for_safety,\n            no_duplicates=False,\n            threads=self.threads,\n        )\n        self.solve_statistics[\"safe_paths_time\"] = time.perf_counter() - start_time\n\n    if self.optimize_with_safe_sequences and not self.is_solved():\n        start_time = time.perf_counter()\n        self.safe_lists += safetypathcovers.safe_sequences(\n            G=self.G,\n            edges_or_subpath_constraints_to_cover=self.trusted_edges_for_safety,\n            no_duplicates=False,\n            threads=self.threads,\n        )\n        self.solve_statistics[\"safe_sequences_time\"] = time.perf_counter() - start_time\n\n    if self.optimize_with_subpath_constraints_as_safe_sequences and len(self.subpath_constraints) &gt; 0 and not self.is_solved():\n        if self.subpath_constraints_coverage == 1 and self.subpath_constraints_coverage_length in [1, None]:\n            start_time = time.perf_counter()\n            self.safe_lists += safetypathcovers.safe_sequences(\n                G=self.G,\n                edges_or_subpath_constraints_to_cover=self.subpath_constraints,\n                no_duplicates=False,\n                threads=self.threads,\n            )\n            self.solve_statistics[\"optimize_with_subpath_constraints_as_safe_sequences\"] = time.perf_counter() - start_time\n\n    if self.optimize_with_safety_as_subpath_constraints:\n        self.subpath_constraints += self.safe_lists\n</code></pre>"},{"location":"abstract-path-model.html#flowpaths.abstractpathmodeldag.AbstractPathModelDAG.create_solver_and_paths","title":"create_solver_and_paths","text":"<pre><code>create_solver_and_paths()\n</code></pre> <p>Creates a solver instance and encodes the paths in the graph.</p> <p>This method initializes the solver with the specified parameters and encodes the paths by creating variables for edges and subpaths.</p> <p>If external solution paths are provided, it skips the solver creation.</p> <p>Call this method before encoding other variables and constraints.</p> <p>Always call this method before encoding other variables and constraints on the paths.</p> Source code in <code>flowpaths/abstractpathmodeldag.py</code> <pre><code>def create_solver_and_paths(self):\n    \"\"\"\n    Creates a solver instance and encodes the paths in the graph.\n\n    This method initializes the solver with the specified parameters and encodes the paths\n    by creating variables for edges and subpaths.\n\n    If external solution paths are provided, it skips the solver creation.\n\n    !!! warning \"Call this method before encoding other variables and constraints.\"\n\n        Always call this method before encoding other variables and constraints on the paths.\n\n    \"\"\"\n    if self.external_solution_paths is not None:\n        return\n\n    self.solver = sw.SolverWrapper(**self.solver_options)\n\n    self._encode_paths()\n\n    self._apply_safety_optimizations_fix_zero_edges()\n</code></pre>"},{"location":"abstract-path-model.html#flowpaths.abstractpathmodeldag.AbstractPathModelDAG.get_lowerbound_k","title":"get_lowerbound_k  <code>abstractmethod</code>","text":"<pre><code>get_lowerbound_k()\n</code></pre> <p>Implement this class in the child class to return a lower bound on the number of solution paths to the model. If you have no lower bound, you should implement this method to return 1.</p> Source code in <code>flowpaths/abstractpathmodeldag.py</code> <pre><code>@abstractmethod\ndef get_lowerbound_k(self):\n    \"\"\"\n    Implement this class in the child class to return a lower bound on the number of solution paths to the model.\n    If you have no lower bound, you should implement this method to return 1.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"abstract-path-model.html#flowpaths.abstractpathmodeldag.AbstractPathModelDAG.get_objective_value","title":"get_objective_value  <code>abstractmethod</code>","text":"<pre><code>get_objective_value()\n</code></pre> <p>Implement this class in the child class to return the objective value of the model. This is needed to be able to compute the safe paths (i.e. those appearing any optimum solution) for any child class.</p> <p>A basic objective value is <code>k</code> (when we\u2019re trying to minimize the number of paths). If your model has a different objective, you should implement this method to return the objective value of the model. If your model has no objective value, you should implement this method to return None.</p> Source code in <code>flowpaths/abstractpathmodeldag.py</code> <pre><code>@abstractmethod\ndef get_objective_value(self):\n    \"\"\"\n    Implement this class in the child class to return the objective value of the model. This is needed to be able to\n    compute the safe paths (i.e. those appearing any optimum solution) for any child class.\n\n    A basic objective value is `k` (when we're trying to minimize the number of paths). If your model has a different\n    objective, you should implement this method to return the objective value of the model. If your model has no objective value,\n    you should implement this method to return None.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"abstract-path-model.html#flowpaths.abstractpathmodeldag.AbstractPathModelDAG.get_solution","title":"get_solution  <code>abstractmethod</code>","text":"<pre><code>get_solution()\n</code></pre> <p>Implement this class in the child class to return the full solution of the model. The solution paths are obtained with the get_solution_paths method.</p> Source code in <code>flowpaths/abstractpathmodeldag.py</code> <pre><code>@abstractmethod\ndef get_solution(self):\n    \"\"\"\n    Implement this class in the child class to return the full solution of the model.\n    The solution paths are obtained with the get_solution_paths method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"abstract-path-model.html#flowpaths.abstractpathmodeldag.AbstractPathModelDAG.get_solution_paths","title":"get_solution_paths","text":"<pre><code>get_solution_paths() -&gt; list\n</code></pre> <p>Retrieves the solution paths from the graph.</p> <p>This method returns the solution paths either from the external solution paths if they are provided at initialization time, or by calculating them based on the edge variable solutions.</p>"},{"location":"abstract-path-model.html#flowpaths.abstractpathmodeldag.AbstractPathModelDAG.get_solution_paths--returns","title":"Returns","text":"<ul> <li>A list of paths, where each path is represented as a list of vertices.</li> </ul> Source code in <code>flowpaths/abstractpathmodeldag.py</code> <pre><code>def get_solution_paths(self) -&gt; list:\n    \"\"\"\n    Retrieves the solution paths from the graph.\n\n    This method returns the solution paths either from the external solution paths\n    if they are provided at initialization time, or by calculating them based on the\n    edge variable solutions.\n\n    Returns\n    ----------\n    - A list of paths, where each path is represented as a list of vertices.\n    \"\"\"\n    if self.external_solution_paths is not None:\n        return self.external_solution_paths\n\n    if self.edge_vars_sol == {}:\n        self.edge_vars_sol = self.solver.get_values(self.edge_vars, binary_values=True)\n\n    paths = []\n    for i in range(self.k):\n        vertex = self.G.source\n        # checking if there is a path from source to sink\n        found_path = False\n        for out_neighbor in self.G.successors(vertex):\n            if self.edge_vars_sol[(str(vertex), str(out_neighbor), i)] == 1:\n                found_path = True\n                break\n        if not found_path:\n            path = []\n            paths.append(path)\n            # print(\"Warning: No path found for path index\", i)\n        else:\n            path = [vertex]\n            while vertex != self.G.sink:\n                for out_neighbor in self.G.successors(vertex):\n                    if self.edge_vars_sol[(str(vertex), str(out_neighbor), i)] == 1:\n                        vertex = out_neighbor\n                        break\n                path.append(vertex)\n            if len(path) &lt; 2:\n                utils.logger.error(f\"{__name__}: Something went wrong, solution path {path} has less than 2 vertices. This should not happen. Make sure the stDAG has no edge from global source {self.G.source} to global sink {self.G.sink}.\")\n                raise Exception(f\"Something went wrong, solution path {path} has less than 2 vertices. This should not happen. Make sure the stDAG has no edge from global source {self.G.source} to global sink {self.G.sink}.\")\n\n            # We remove the first and the last vertex, because\n            # these are the global source and the global sink introduced by stDAG\n            paths.append(path[1:-1])\n\n    return paths\n</code></pre>"},{"location":"abstract-path-model.html#flowpaths.abstractpathmodeldag.AbstractPathModelDAG.is_valid_solution","title":"is_valid_solution  <code>abstractmethod</code>","text":"<pre><code>is_valid_solution() -&gt; bool\n</code></pre> <p>Implement this class in the child class to perform a basic check whether the solution is valid.</p> <p>If you cannot perform such a check, provide an implementation that always returns True.</p> Source code in <code>flowpaths/abstractpathmodeldag.py</code> <pre><code>@abstractmethod\ndef is_valid_solution(self) -&gt; bool:\n    \"\"\"\n    Implement this class in the child class to perform a basic check whether the solution is valid.\n\n    If you cannot perform such a check, provide an implementation that always returns True.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"abstract-path-model.html#flowpaths.abstractpathmodeldag.AbstractPathModelDAG.solve","title":"solve","text":"<pre><code>solve() -&gt; bool\n</code></pre> <p>Solves the optimization model for the current instance.</p>"},{"location":"abstract-path-model.html#flowpaths.abstractpathmodeldag.AbstractPathModelDAG.solve--returns","title":"Returns","text":"<ul> <li>True if the model is solved successfully, False otherwise.</li> </ul> <p>The method first checks if an external solution is already provided. If so, it sets the solved attribute to True and returns True.</p> <p>If not, it optimizes the model using the solver, and records the solve time and solver status in the solve_statistics dictionary. If the solver status indicates an optimal solution (either \u2018kOptimal\u2019 (highs) or status code 2 (gurobi)), it sets the solved attribute to True and returns True. Otherwise, it sets the solved attribute to False and returns False.</p> Source code in <code>flowpaths/abstractpathmodeldag.py</code> <pre><code>def solve(self) -&gt; bool:\n    \"\"\"\n    Solves the optimization model for the current instance.\n\n    Returns\n    ----------\n    - True if the model is solved successfully, False otherwise.\n\n    The method first checks if an external solution is already provided. If so, it sets the\n    solved attribute to True and returns True.\n\n    If not, it optimizes the model using the solver, and records the solve time and solver status\n    in the solve_statistics dictionary. If the solver status indicates an optimal solution\n    (either 'kOptimal' (highs) or status code 2 (gurobi)), it sets the solved attribute to True and returns True.\n    Otherwise, it sets the solved attribute to False and returns False.\n    \"\"\"\n    utils.logger.info(f\"{__name__}: solving...\")\n\n    # If we already received an external solution, we don't need to solve the model\n    if self.external_solution_paths is not None:\n        utils.logger.info(f\"{__name__}: no need to solve, we have an external solution.\")\n        self._is_solved = True\n        return True\n\n    # self.write_model(f\"model-{self.id}.lp\")\n    start_time = time.perf_counter()\n    self.solver.optimize()\n    self.solve_statistics[f\"milp_solve_time_for_num_paths_{self.k}\"] = (\n        time.perf_counter() - start_time\n    )\n\n    self.solve_statistics[f\"milp_solver_status_for_num_paths_{self.k}\"] = (\n        self.solver.get_model_status()\n    )\n\n    if (\n        self.solver.get_model_status() == \"kOptimal\"\n        or self.solver.get_model_status() == 2\n    ):\n        self._is_solved = True\n        utils.logger.info(f\"{__name__}: solved successfully. Objective value: {self.get_objective_value()}\")\n        return True\n\n    self._is_solved = False\n    return False\n</code></pre>"},{"location":"abstract-walk-model.html","title":"Abstract Path Model in DAGs","text":"<p>A general approach in developing a model to decompose a weighted graph into weighted paths is to:</p> <ol> <li>Fix \\(k\\), the number of paths. </li> <li>Formulate in ILP the \\(k\\) paths; that is adding a set of \\(k\\) variables and suitable constraints constraints such that the \\(i\\)-th set of variables encodes the \\(i\\)-th path.</li> <li>Add additional variables, constraints, or set the objective function, that these paths must satisfy.</li> <li>Iterate the above process for different values of \\(k\\), until the \u201cbest\u201d one is found (\u201cbest\u201d depends on the problem). See our implementation of a basic routine for this step.</li> </ol> <p>For step 2. above we provide the abstract class <code>AbstractPathModelDAG</code> which models a given number \\(k\\) of paths in a given acyclic graph \\(G = (V,E)\\). For simplicity, \\(G\\) must have a single source \\(s\\) and a single sink \\(t\\), see our class stDiGraph. (The <code>stDiGraph</code> class adds these automatically for any NetworkX DiGraph, and keeps track of their incident edges.) This approach appeared in this paper.</p> <p>More in detail, for every edge \\((u,v) \\in E\\), and for every path index \\(i \\in \\{0,\\dots,k-1\\}\\), we add a binary variable \\(x_{u,v,i} \\in \\{0,1\\}\\). We add constraints on these variables to ensure that for every \\(i\\) the variables \\(x_{u,v,i}\\) that equal 1 induce an \\(s\\)-\\(t\\) path (i.e., a path from \\(s\\) to \\(t\\)). In other words \\(x_{u,v,i} = 1\\) if edge \\((u,v)\\) belongs to solution path \\(i\\), and 0 otherwise. See the paper on the specific constraints that are added to enforce that they induce an \\(s\\)-\\(t\\) path. </p> <p>For example, the edges in brown below induce an \\(s\\)-\\(t\\) path (for say \\(i = 3\\)), and notice that the \\(x_{u,v,3}\\) variables equal 1 only on the edges \\((u,v)\\) on the path.</p> <pre><code>%%{init: {'themeVariables': { 'edgeLabelBackground': 'white'}}}%%\nflowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|\"$$x_{s,a,3} = 1$$\"| a\n    a --&gt;|\"$$x_{a,b,3} = 1$$\"| b\n    s --&gt;|\"$$x_{s,b,3} = 0$$\"| b\n    a --&gt;|\"$$x_{a,c,3} = 0$$\"| c\n    b --&gt;|\"$$x_{b,c,3} = 1$$\"| c\n    c --&gt;|\"$$x_{c,d,3} = 1$$\"| d\n    d --&gt;|\"$$x_{d,t,3} = 1$$\"| t\n    c --&gt;|\"$$x_{c,t,3} = 0$$\"| t\n\n    linkStyle 0,1,4,5,6 stroke:brown,stroke-width:3;</code></pre> <p>The search for paths</p> <ul> <li>Note that we do not have the paths beforehand, and the ILP will search for paths (i.e. assignment of values to the \\(x_{u,v,i}\\) variables, under the constraints that they induce a path). </li> <li>Once a class inherits from <code>AbstractPathModelDAG</code>, it will add other variables and constraints (as in point 3. above). The ILP solver will then search for the \\(k\\) paths (i.e. find the values to the \\(x_{u,v,i}\\) variables) to satisfy all constraints.</li> </ul> <p>Example: Modelling \\(k\\)-Flow Decomposition</p> <p>Consider the problem of decomposing a network flow \\(f : E \\rightarrow \\mathbb{N}\\) over a DAG \\(G = (V,E)\\) into a given number \\(k\\) of \\(s\\)-\\(t\\) paths (k-Flow Decomposition). Assume we created the \\(x_{u,v,i}\\) variables as above. Thus, we just need to implement point 3. above.</p> <ul> <li>We introduce a variable \\(w_i\\) (integer or continuous) modeling the weight of path \\(i\\), for every \\(i \\in \\{0,\\dots,k-1\\}\\).</li> <li>We need to enforce the \u201cflow explanation\u201d constraint: $$ f(u,v) = \\sum_{i=0}^{k-1} x_i \\cdot w_i, ~~\\forall (u,v) \\in E. $$ Note that in the above \\(f(u,v)\\) is a constant. Moreover, \\(x_i \\cdot w_i\\) is not a linear term (as required by an Integer Linear Program), but it can be easily linearized via additional variables and constraints. However, our <code>SolverWrapper</code> class provides the method <code>add_binary_continuous_product_constraint()</code> to directly encode such a non-linear constraint, without bothering to manually set up these additional variables and constraints.</li> </ul> <p>The \\(x_{u,v,i}\\) variables are implemented as <code>edge_vars[(u, v, i)]</code>, see the class documentation below.</p>"},{"location":"abstract-walk-model.html#flowpaths.abstractwalkmodeldigraph.AbstractWalkModelDiGraph","title":"AbstractWalkModelDiGraph","text":"<pre><code>AbstractWalkModelDiGraph(\n    G: stDiGraph,\n    k: int,\n    max_edge_repetition: int = 1,\n    max_edge_repetition_dict: dict = None,\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1,\n    optimization_options: dict = None,\n    solver_options: dict = {},\n    solve_statistics: dict = {},\n)\n</code></pre> <p>               Bases: <code>ABC</code></p>"},{"location":"abstract-walk-model.html#flowpaths.abstractwalkmodeldigraph.AbstractWalkModelDiGraph--parameters","title":"Parameters","text":"<ul> <li> <p><code>G: stdigraph.stDiGraph</code> </p> <p>The directed graph to be used, possibly with cycles. Create it using the <code>stDiGraph</code> class.</p> </li> <li> <p><code>k: int</code></p> <p>The number of s-t walks to be modeled.</p> </li> <li> <p><code>max_edge_repetition: int</code>, optional</p> <p>The maximum number of times an edge can be used in a walk. Defaults to 1.</p> </li> <li> <p><code>max_edge_repetition_dict: dict</code>, optional</p> <pre><code>A per-edge upper bound mapping that overrides `max_edge_repetition` on a per-edge basis.\nKeys are edges `(u, v)` from `G.edges()` and values are non-negative integers specifying\nthe maximum number of times that edge can be used within a single walk (layer).\n\nRequirements and behavior:\n- If provided, it must contain an entry for every edge in `G` (missing entries raise `ValueError`).\n- Values should be integers \u2265 0; a value of 0 forbids the edge in any walk.\n- When both `max_edge_repetition` and this dict are provided, the dict takes precedence per edge.\n- These bounds are applied per layer i and are used to set the variable upper bounds and related\n    big-M constants in the model.\n</code></pre> </li> <li> <p><code>subset_constraints: list</code>, optional</p> <p>A list of lists, where each list is a set of edges (not necessarily contiguous). Defaults to an empty list.</p> <p>Each set of edges must appear in at least one solution path; if you also pass <code>subset_constraints_coverage</code>,  then each set of edges must appear in at least <code>subset_constraints_coverage</code> fraction of some solution walk, see below.</p> </li> <li> <p><code>subset_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subset constraints that must be covered by some solution walk, in terms of number of edges.      - Defaults to 1 (meaning that 100% of the edges of the constraint need to be covered by some solution walk).</p> </li> <li> <p><code>optimization_options: dict</code>, optional </p> <p>Dictionary of optimization options. Defaults to <code>None</code>, in which case the default values are used. See the available optimizations.  If you pass any safety optimizations, you must also pass the dict entry <code>\"trusted_edges_for_safety\"</code> (see below).  If a child class has already solved the problem and has the solution paths, it can pass them via the dict entry <code>\"external_solution_paths\"</code> to skip the solver creation and encoding of paths (see below).</p> <ul> <li> <p><code>\"trusted_edges_for_safety\": set</code></p> <p>Set of trusted edges for safety. Defaults to <code>None</code>.</p> <p>Global optimality</p> <p>In order for the optimizations to still guarantee a global optimum, you must guarantee that:</p> <ol> <li>The solution is made up of source-to-sink walks, and</li> <li>Every edge in <code>trusted_edges_for_safety</code> appears in some solution walk, for all solutions. This naturally holds for several problems, for example Minimum Flow Decomposition or k-Minimum Path Error where in fact, under default settings, all edges appear in all solutions.</li> </ol> </li> </ul> </li> <li> <p><code>solver_options: dict</code>, optional</p> <p>Dictionary of solver options. Defaults to <code>{}</code>, in which case the default values are used.  See the available solver options.</p> </li> <li> <p><code>solve_statistics: dict</code>, optional</p> <p>Dictionary to store solve statistics. Defaults to <code>{}</code>.</p> </li> </ul>"},{"location":"abstract-walk-model.html#flowpaths.abstractwalkmodeldigraph.AbstractWalkModelDiGraph--raises","title":"Raises","text":"<ul> <li>ValueError: If <code>trusted_edges_for_safety</code> is not provided when optimizing with <code>optimize_with_safe_sequences</code>.</li> <li>ValueError: If <code>max_edge_repetition_dict</code> is provided but is missing any edge in <code>G</code>.</li> </ul> Source code in <code>flowpaths/abstractwalkmodeldigraph.py</code> <pre><code>def __init__(\n    self,\n    G: stdigraph.stDiGraph,\n    k: int,\n    max_edge_repetition: int = 1,\n    max_edge_repetition_dict: dict = None,\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1,\n    optimization_options: dict = None,\n    solver_options: dict = {},\n    solve_statistics: dict = {},\n):\n    \"\"\"\n    Parameters\n    ----------\n\n    - `G: stdigraph.stDiGraph`  \n\n        The directed graph to be used, possibly with cycles. Create it using the [`stDiGraph` class](stdigraph.md).\n\n    - `k: int`\n\n        The number of s-t walks to be modeled.\n\n    - `max_edge_repetition: int`, optional\n\n        The maximum number of times an edge can be used in a walk. Defaults to 1.\n\n    - `max_edge_repetition_dict: dict`, optional\n\n            A per-edge upper bound mapping that overrides `max_edge_repetition` on a per-edge basis.\n            Keys are edges `(u, v)` from `G.edges()` and values are non-negative integers specifying\n            the maximum number of times that edge can be used within a single walk (layer).\n\n            Requirements and behavior:\n            - If provided, it must contain an entry for every edge in `G` (missing entries raise `ValueError`).\n            - Values should be integers \u2265 0; a value of 0 forbids the edge in any walk.\n            - When both `max_edge_repetition` and this dict are provided, the dict takes precedence per edge.\n            - These bounds are applied per layer i and are used to set the variable upper bounds and related\n                big-M constants in the model.\n\n    - `subset_constraints: list`, optional\n\n        A list of lists, where each list is a *set* of edges (not necessarily contiguous). Defaults to an empty list.\n\n        Each set of edges must appear in at least one solution path; if you also pass `subset_constraints_coverage`, \n        then each set of edges must appear in at least `subset_constraints_coverage` fraction of some solution walk, see below.\n\n    - `subset_constraints_coverage: float`, optional\n\n        Coverage fraction of the subset constraints that must be covered by some solution walk, in terms of number of edges. \n            - Defaults to 1 (meaning that 100% of the edges of the constraint need to be covered by some solution walk).\n\n    - `optimization_options: dict`, optional \n\n        Dictionary of optimization options. Defaults to `None`, in which case the default values are used. See the [available optimizations](solver-options-optimizations.md). \n        If you pass any safety optimizations, you must also pass the dict entry `\"trusted_edges_for_safety\"` (see below). \n        If a child class has already solved the problem and has the solution paths, it can pass them via the dict entry `\"external_solution_paths\"` to skip the solver creation and encoding of paths (see below).\n\n        - `\"trusted_edges_for_safety\": set`\n\n            Set of trusted edges for safety. Defaults to `None`.\n\n            !!! warning \"Global optimality\"\n                In order for the optimizations to still guarantee a global optimum, you must guarantee that:\n\n                1. The solution is made up of source-to-sink walks, and\n                2. Every edge in `trusted_edges_for_safety` appears in some solution walk, for all solutions. This naturally holds for several problems, for example [Minimum Flow Decomposition](minimum-flow-decomposition-cycles.md) or [k-Minimum Path Error](k-min-path-error-cycles.md) where in fact, under default settings, **all** edges appear in all solutions.\n\n    - `solver_options: dict`, optional\n\n        Dictionary of solver options. Defaults to `{}`, in which case the default values are used. \n        See the [available solver options](solver-options-optimizations.md).\n\n    - `solve_statistics: dict`, optional\n\n        Dictionary to store solve statistics. Defaults to `{}`.\n\n\n    Raises\n    ----------\n\n    - ValueError: If `trusted_edges_for_safety` is not provided when optimizing with `optimize_with_safe_sequences`.\n    - ValueError: If `max_edge_repetition_dict` is provided but is missing any edge in `G`.\n    \"\"\"\n\n    self.G = G\n    if G.number_of_edges() == 0:\n        utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n        raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n    self.id = self.G.id\n    self.k = k\n    if k &lt;= 0:\n        utils.logger.error(f\"{__name__}: k must be positive, got {k}.\")\n        raise ValueError(f\"k must be positive, got {k}.\")\n    if max_edge_repetition_dict is None:\n        self.edge_upper_bounds = {edge: max_edge_repetition for edge in self.G.edges()}\n    else:\n        self.edge_upper_bounds = max_edge_repetition_dict\n        for edge in self.G.edges():\n            if edge not in self.edge_upper_bounds:\n                utils.logger.critical(f\"{__name__}: Missing max_edge_repetition in max_edge_repetition_dict for edge {edge}\")\n                raise ValueError(f\"Missing max_edge_repetition for edge {edge}\")\n    # We set to 1 in edge_upper_bounds if the edge is not inside an SCC of self.G,\n    # because these edges cannot be traversed more than 1 times by any walk\n    for edge in self.G.edges():\n        if not self.G.is_scc_edge(edge[0], edge[1]):\n            self.edge_upper_bounds[edge] = 1\n\n    self.subset_constraints = copy.deepcopy(subset_constraints)\n    if self.subset_constraints is not None:\n        self._check_valid_subset_constraints()\n\n    self.subset_constraints_coverage = subset_constraints_coverage\n    if len(subset_constraints) &gt; 0:\n        if self.subset_constraints_coverage &lt;= 0 or self.subset_constraints_coverage &gt; 1:\n            utils.logger.error(f\"{__name__}: subset_constraints_coverage must be in the range (0, 1]\")\n            raise ValueError(\"subset_constraints_coverage must be in the range (0, 1]\")\n\n    self.solve_statistics = solve_statistics\n    self.edge_vars = {}\n    self.edge_vars_sol = {}\n    self.subset_vars = {}\n\n    self.solver_options = solver_options\n    if self.solver_options is None:\n        self.solver_options = {}\n    self.threads = self.solver_options.get(\"threads\", sw.SolverWrapper.threads)\n\n    self.edges_set_to_zero = {}\n    self.edges_set_to_one = {}\n\n    # optimizations\n    if optimization_options is None:\n        optimization_options = {}\n    self.optimize_with_safe_sequences = optimization_options.get(\"optimize_with_safe_sequences\", AbstractWalkModelDiGraph.optimize_with_safe_sequences)\n    self.trusted_edges_for_safety = optimization_options.get(\"trusted_edges_for_safety\", None)\n    self.allow_empty_walks = optimization_options.get(\"allow_empty_walks\", AbstractWalkModelDiGraph.allow_empty_walks)\n    self.optimize_with_safety_as_subset_constraints = optimization_options.get(\"optimize_with_safety_as_subset_constraints\", AbstractWalkModelDiGraph.optimize_with_safety_as_subset_constraints)\n    self.optimize_with_max_safe_antichain_as_subset_constraints = optimization_options.get(\"optimize_with_max_safe_antichain_as_subset_constraints\", AbstractWalkModelDiGraph.optimize_with_max_safe_antichain_as_subset_constraints)\n    self.optimize_with_safe_sequences_allow_geq_constraints = optimization_options.get(\"optimize_with_safe_sequences_allow_geq_constraints\", AbstractWalkModelDiGraph.optimize_with_safe_sequences_allow_geq_constraints)\n    self.optimize_with_safe_sequences_fix_via_bounds = optimization_options.get(\"optimize_with_safe_sequences_fix_via_bounds\", AbstractWalkModelDiGraph.optimize_with_safe_sequences_fix_via_bounds)\n    self.optimize_with_safe_sequences_fix_zero_edges = optimization_options.get(\n        \"optimize_with_safe_sequences_fix_zero_edges\",\n        AbstractWalkModelDiGraph.optimize_with_safe_sequences_fix_zero_edges,\n    )\n\n    self._is_solved = False\n\n    if not hasattr(self, \"solve_time_start\") or self.solve_time_start is None:\n        self.solve_time_start = time.perf_counter()\n</code></pre>"},{"location":"abstract-walk-model.html#flowpaths.abstractwalkmodeldigraph.AbstractWalkModelDiGraph.compute_edge_max_reachable_value","title":"compute_edge_max_reachable_value","text":"<pre><code>compute_edge_max_reachable_value(\n    u, v\n) -&gt; int\n</code></pre> <p>Returns an upper bound on how many times edge (u,v) can be used in a single walk layer.</p> <p>Subclasses should override this to provide a tighter, problem-specific bound. The default falls back to <code>self.max_edge_repetition</code>. Must return a non-negative integer.</p> Source code in <code>flowpaths/abstractwalkmodeldigraph.py</code> <pre><code>def compute_edge_max_reachable_value(self, u, v) -&gt; int:\n    \"\"\"\n    Returns an upper bound on how many times edge (u,v) can be used in a single walk layer.\n\n    Subclasses should override this to provide a tighter, problem-specific bound.\n    The default falls back to `self.max_edge_repetition`.\n    Must return a non-negative integer.\n    \"\"\"\n    return int(self.max_edge_repetition)\n</code></pre>"},{"location":"abstract-walk-model.html#flowpaths.abstractwalkmodeldigraph.AbstractWalkModelDiGraph.create_solver_and_walks","title":"create_solver_and_walks","text":"<pre><code>create_solver_and_walks()\n</code></pre> <p>Creates a solver instance and encodes the walks in the graph.</p> <p>This method initializes the solver with the specified parameters and encodes the walks by creating variables for edges and subsets to cover.</p> <p>Call this method before encoding other variables and constraints.</p> <p>Always call this method before encoding other variables and constraints on the walks.</p> Source code in <code>flowpaths/abstractwalkmodeldigraph.py</code> <pre><code>def create_solver_and_walks(self):\n    \"\"\"\n    Creates a solver instance and encodes the walks in the graph.\n\n    This method initializes the solver with the specified parameters and encodes the walks\n    by creating variables for edges and subsets to cover.\n\n    !!! warning \"Call this method before encoding other variables and constraints.\"\n\n        Always call this method before encoding other variables and constraints on the walks.\n\n    \"\"\"\n    self.solver = sw.SolverWrapper(**self.solver_options)\n\n    self._encode_walks()\n\n    start_time = time.perf_counter()\n    self._apply_safety_optimizations()\n    utils.logger.debug(f\"{__name__}: Applied safety optimizations in {time.perf_counter() - start_time} seconds.\")\n    self.solve_statistics[\"safe_sequences_time\"] = time.perf_counter() - start_time\n\n    self._encode_subset_constraints()\n\n    self.solve_statistics[\"graph_width\"] = self.G.get_width()\n    self.solve_statistics[\"edge_number\"] = self.G.number_of_edges()\n    self.solve_statistics[\"node_number\"] = self.G.number_of_nodes()\n</code></pre>"},{"location":"abstract-walk-model.html#flowpaths.abstractwalkmodeldigraph.AbstractWalkModelDiGraph.get_lowerbound_k","title":"get_lowerbound_k  <code>abstractmethod</code>","text":"<pre><code>get_lowerbound_k()\n</code></pre> <p>Implement this class in the child class to return a lower bound on the number of solution paths to the model. If you have no lower bound, you should implement this method to return 1.</p> Source code in <code>flowpaths/abstractwalkmodeldigraph.py</code> <pre><code>@abstractmethod\ndef get_lowerbound_k(self):\n    \"\"\"\n    Implement this class in the child class to return a lower bound on the number of solution paths to the model.\n    If you have no lower bound, you should implement this method to return 1.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"abstract-walk-model.html#flowpaths.abstractwalkmodeldigraph.AbstractWalkModelDiGraph.get_objective_value","title":"get_objective_value  <code>abstractmethod</code>","text":"<pre><code>get_objective_value()\n</code></pre> <p>Implement this class in the child class to return the objective value of the model. This is needed to be able to compute the safe paths (i.e. those appearing any optimum solution) for any child class.</p> <p>A basic objective value is <code>k</code> (when we\u2019re trying to minimize the number of paths). If your model has a different objective, you should implement this method to return the objective value of the model. If your model has no objective value, you should implement this method to return None.</p> Source code in <code>flowpaths/abstractwalkmodeldigraph.py</code> <pre><code>@abstractmethod\ndef get_objective_value(self):\n    \"\"\"\n    Implement this class in the child class to return the objective value of the model. This is needed to be able to\n    compute the safe paths (i.e. those appearing any optimum solution) for any child class.\n\n    A basic objective value is `k` (when we're trying to minimize the number of paths). If your model has a different\n    objective, you should implement this method to return the objective value of the model. If your model has no objective value,\n    you should implement this method to return None.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"abstract-walk-model.html#flowpaths.abstractwalkmodeldigraph.AbstractWalkModelDiGraph.get_solution","title":"get_solution  <code>abstractmethod</code>","text":"<pre><code>get_solution()\n</code></pre> <p>Implement this class in the child class to return the full solution of the model. The solution paths are obtained with the get_solution_paths method.</p> Source code in <code>flowpaths/abstractwalkmodeldigraph.py</code> <pre><code>@abstractmethod\ndef get_solution(self):\n    \"\"\"\n    Implement this class in the child class to return the full solution of the model.\n    The solution paths are obtained with the get_solution_paths method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"abstract-walk-model.html#flowpaths.abstractwalkmodeldigraph.AbstractWalkModelDiGraph.get_solution_walks","title":"get_solution_walks","text":"<pre><code>get_solution_walks() -&gt; list\n</code></pre> <p>Retrieves the solution walks from the graph, handling cycles with multiplicities.</p> <p>For each layer i, this reconstructs a single Eulerian walk that uses all edges with positive flow, ensuring complete flow decomposition.</p> Source code in <code>flowpaths/abstractwalkmodeldigraph.py</code> <pre><code>def get_solution_walks(self) -&gt; list:\n    \"\"\"\n    Retrieves the solution walks from the graph, handling cycles with multiplicities.\n\n    For each layer i, this reconstructs a single Eulerian walk that uses all edges\n    with positive flow, ensuring complete flow decomposition.\n    \"\"\"\n\n    if self.edge_vars_sol == {}:\n        self.edge_vars_sol = self.solver.get_values(self.edge_vars)\n    # utils.logger.debug(f\"{__name__}: Getting solution walks with self.edge_vars_sol = {self.edge_vars_sol}\")\n\n    walks = []\n    for i in range(self.k):\n        # Build residual graph for this layer with edge multiplicities\n        residual_graph = self._build_residual_graph_for_layer(i)\n        # utils.logger.debug(f\"{__name__}: residual_graph = {residual_graph}\")\n\n        # Check if there's any flow in this layer\n        if not residual_graph:\n            walks.append([])\n            continue\n\n        # Reconstruct complete Eulerian walk\n        walk = self._reconstruct_eulerian_walk(residual_graph, i)\n        walks.append(walk)\n\n    return walks\n</code></pre>"},{"location":"abstract-walk-model.html#flowpaths.abstractwalkmodeldigraph.AbstractWalkModelDiGraph.is_valid_solution","title":"is_valid_solution  <code>abstractmethod</code>","text":"<pre><code>is_valid_solution() -&gt; bool\n</code></pre> <p>Implement this class in the child class to perform a basic check whether the solution is valid.</p> <p>If you cannot perform such a check, provide an implementation that always returns True.</p> Source code in <code>flowpaths/abstractwalkmodeldigraph.py</code> <pre><code>@abstractmethod\ndef is_valid_solution(self) -&gt; bool:\n    \"\"\"\n    Implement this class in the child class to perform a basic check whether the solution is valid.\n\n    If you cannot perform such a check, provide an implementation that always returns True.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"abstract-walk-model.html#flowpaths.abstractwalkmodeldigraph.AbstractWalkModelDiGraph.solve","title":"solve","text":"<pre><code>solve() -&gt; bool\n</code></pre> <p>Solves the optimization model for the current instance.</p>"},{"location":"abstract-walk-model.html#flowpaths.abstractwalkmodeldigraph.AbstractWalkModelDiGraph.solve--returns","title":"Returns","text":"<ul> <li>True if the model is solved successfully, False otherwise.</li> </ul> <p>The method first checks if an external solution is already provided. If so, it sets the solved attribute to True and returns True.</p> <p>If not, it optimizes the model using the solver, and records the solve time and solver status in the solve_statistics dictionary. If the solver status indicates an optimal solution (either \u2018kOptimal\u2019 (highs) or status code 2 (gurobi)), it sets the solved attribute to True and returns True. Otherwise, it sets the solved attribute to False and returns False.</p> Source code in <code>flowpaths/abstractwalkmodeldigraph.py</code> <pre><code>def solve(self) -&gt; bool:\n    \"\"\"\n    Solves the optimization model for the current instance.\n\n    Returns\n    ----------\n    - True if the model is solved successfully, False otherwise.\n\n    The method first checks if an external solution is already provided. If so, it sets the\n    solved attribute to True and returns True.\n\n    If not, it optimizes the model using the solver, and records the solve time and solver status\n    in the solve_statistics dictionary. If the solver status indicates an optimal solution\n    (either 'kOptimal' (highs) or status code 2 (gurobi)), it sets the solved attribute to True and returns True.\n    Otherwise, it sets the solved attribute to False and returns False.\n    \"\"\"\n    utils.logger.info(f\"{__name__}: solving...\")\n\n    # self.write_model(f\"model-{self.id}.lp\")\n    start_time = time.perf_counter()\n    self.solver.optimize()\n    self.solve_statistics[f\"solve_time_ilp\"] = time.perf_counter() - start_time\n    self.solve_statistics[f\"solve_time\"] = time.perf_counter() - self.solve_time_start\n    self.solve_statistics[f\"model_status\"] = self.solver.get_model_status()\n    self.solve_statistics[f\"number_of_nontrivial_SCCs\"] = self.G.get_number_of_nontrivial_SCCs()\n    self.solve_statistics[f\"avg_size_of_non_trivial_SCC\"] = self.G.get_avg_size_of_non_trivial_SCC()\n    self.solve_statistics[f\"size_of_largest_SCC\"] = self.G.get_size_of_largest_SCC()\n\n    if self.solver.get_model_status() == \"kOptimal\" or self.solver.get_model_status() == 2:\n        self._is_solved = True\n        utils.logger.info(f\"{__name__}: solved successfully. Objective value: {self.get_objective_value()}\")\n        return True\n\n    self._is_solved = False\n    return False\n</code></pre>"},{"location":"abstractsourcesinkgraph.html","title":"Abstract Source Sink Graph","text":""},{"location":"abstractsourcesinkgraph.html#flowpaths.abstractsourcesinkgraph.AbstractSourceSinkGraph","title":"AbstractSourceSinkGraph","text":"<pre><code>AbstractSourceSinkGraph(\n    base_graph: DiGraph,\n    additional_starts: (\n        list | None\n    ) = None,\n    additional_ends: (\n        list | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>DiGraph</code></p> <p>Base class for s-t augmented graphs (internal).</p> <p>This class (introduced when unifying :class:<code>stDAG</code> and :class:<code>stDiGraph</code>) factors out logic previously duplicated in both classes.</p>"},{"location":"abstractsourcesinkgraph.html#flowpaths.abstractsourcesinkgraph.AbstractSourceSinkGraph--core-responsibilities","title":"Core responsibilities","text":"<ul> <li>Store and expose the original <code>base_graph</code> plus user supplied <code>additional_starts</code> / <code>additional_ends</code>.</li> <li>Validate that all nodes are strings and that any additional start/end nodes belong to <code>base_graph</code>.</li> <li>Create unique global source / sink node identifiers (<code>self.source</code> / <code>self.sink</code>).</li> <li>Attach the global source to every (in-degree 0) source or additional start; attach every (out-degree 0) sink   or additional end to the global sink.</li> <li>Expose convenience collections: <code>source_edges</code>, <code>sink_edges</code>, <code>source_sink_edges</code>.</li> <li>Provide shared flow helper utilities: :meth:<code>get_non_zero_flow_edges</code> and   :meth:<code>get_max_flow_value_and_check_non_negative_flow</code>.</li> </ul>"},{"location":"abstractsourcesinkgraph.html#flowpaths.abstractsourcesinkgraph.AbstractSourceSinkGraph--extension-hooks","title":"Extension hooks","text":"<p>Subclasses customise behaviour via two lightweight hooks:</p> <ul> <li><code>_pre_build_validate</code> - extra validation before augmentation (e.g. acyclicity for <code>stDAG</code>).</li> <li><code>_post_build</code> - populate subclass specific derived structures (e.g. condensation for <code>stDiGraph</code>).</li> </ul>"},{"location":"abstractsourcesinkgraph.html#flowpaths.abstractsourcesinkgraph.AbstractSourceSinkGraph--backwards-compatibility","title":"Backwards compatibility","text":"<p>External code should keep instantiating <code>stDAG</code> or <code>stDiGraph</code>; their public APIs are unchanged. <code>AbstractSourceSinkGraph</code> is an internal implementation detail and may change without notice.</p> Source code in <code>flowpaths/abstractsourcesinkgraph.py</code> <pre><code>def __init__(\n    self,\n    base_graph: nx.DiGraph,\n    additional_starts: Optional[list] = None,\n    additional_ends: Optional[list] = None,\n):\n    if not all(isinstance(node, str) for node in base_graph.nodes()):\n        utils.logger.error(f\"{__name__}: Every node of the graph must be a string.\")\n        raise ValueError(\"Every node of the graph must be a string.\")\n\n    super().__init__()\n    self.base_graph = base_graph\n    if \"id\" in base_graph.graph:\n        self.id = str(base_graph.graph[\"id\"])\n    else:\n        self.id = str(id(self))\n\n    self.additional_starts = set(additional_starts or [])\n    self.additional_ends = set(additional_ends or [])\n\n    # Ensure any declared additional start/end nodes are in the base graph\n    if not self.additional_starts.issubset(base_graph.nodes()):\n        utils.logger.error(f\"{__name__}: Some nodes in additional_starts are not in the base graph.\")\n        raise ValueError(\"Some nodes in additional_starts are not in the base graph.\")\n    if not self.additional_ends.issubset(base_graph.nodes()):\n        utils.logger.error(f\"{__name__}: Some nodes in additional_ends are not in the base graph.\")\n        raise ValueError(\"Some nodes in additional_ends are not in the base graph.\")\n\n    self.source = f\"source_{id(self)}\"\n    self.sink = f\"sink_{id(self)}\"\n\n    # Hooks\n    self._pre_build_validate()\n    self._augment_with_source_sink()\n    self._post_build()\n\n    nx.freeze(self)\n</code></pre>"},{"location":"abstractsourcesinkgraph.html#flowpaths.abstractsourcesinkgraph.AbstractSourceSinkGraph.get_max_flow_value_and_check_non_negative_flow","title":"get_max_flow_value_and_check_non_negative_flow","text":"<pre><code>get_max_flow_value_and_check_non_negative_flow(\n    flow_attr: str,\n    edges_to_ignore: set,\n) -&gt; float\n</code></pre> <p>Return maximum value of <code>flow_attr</code> over edges (ignoring some) verifying non-negativity.</p> <p>Raises ValueError if any required attribute missing or negative.</p> Source code in <code>flowpaths/abstractsourcesinkgraph.py</code> <pre><code>def get_max_flow_value_and_check_non_negative_flow(\n    self, flow_attr: str, edges_to_ignore: set\n) -&gt; float:\n    \"\"\"Return maximum value of `flow_attr` over edges (ignoring some) verifying non-negativity.\n\n    Raises ValueError if any required attribute missing or negative.\n    \"\"\"\n    w_max = float(\"-inf\")\n    if edges_to_ignore is None:\n        edges_to_ignore = set()\n    for u, v, data in self.edges(data=True):\n        if (u, v) in edges_to_ignore:\n            continue\n        if flow_attr not in data:\n            utils.logger.error(\n                f\"Edge ({u},{v}) does not have the required flow attribute '{flow_attr}'.\"\n            )\n            raise ValueError(\n                f\"Edge ({u},{v}) does not have the required flow attribute '{flow_attr}'.\"\n            )\n        if data[flow_attr] &lt; 0:\n            utils.logger.error(\n                f\"Edge ({u},{v}) has negative flow value {data[flow_attr]}. All flow values must be &gt;=0.\"\n            )\n            raise ValueError(\n                f\"Edge ({u},{v}) has negative flow value {data[flow_attr]}. All flow values must be &gt;=0.\"\n            )\n        w_max = max(w_max, data[flow_attr])\n    return w_max\n</code></pre>"},{"location":"abstractsourcesinkgraph.html#flowpaths.abstractsourcesinkgraph.AbstractSourceSinkGraph.get_non_zero_flow_edges","title":"get_non_zero_flow_edges","text":"<pre><code>get_non_zero_flow_edges(\n    flow_attr: str,\n    edges_to_ignore: set = set(),\n) -&gt; set\n</code></pre> <p>Return set of edges whose attribute <code>flow_attr</code> is non-zero and not ignored.</p> Source code in <code>flowpaths/abstractsourcesinkgraph.py</code> <pre><code>def get_non_zero_flow_edges(\n    self, flow_attr: str, edges_to_ignore: set = set()\n) -&gt; set:\n    \"\"\"Return set of edges whose attribute `flow_attr` is non-zero and not ignored.\"\"\"\n    non_zero_flow_edges = set()\n    for u, v, data in self.edges(data=True):\n        if (u, v) not in edges_to_ignore and data.get(flow_attr, 0) != 0:\n            non_zero_flow_edges.add((u, v))\n    return non_zero_flow_edges\n</code></pre>"},{"location":"additional-start-end-nodes.html","title":"Additional start/end nodes","text":"<p>By default, solution paths/walks must start in a source node of the graph (i.e. a node with no in-coming edges) and end in a sink node of the graph (i.e. a node with no out-going edges). However, in some use cases, solution paths/walks can start/end \u201cin the middle\u201d of other solution paths/walks, which means that they start in a non-source node/end in non-sink node. </p>"},{"location":"additional-start-end-nodes.html#1-implementation","title":"1. Implementation","text":"<p>To allow for such scenarios, all decomposition models (except Minimum Flow Decomposition in DAGs) offer the possibility of passing also:</p> <ul> <li><code>additional_starts</code>: a list of nodes where paths/walks are allowed to start; paths/walks are still allowed to start in source nodes;</li> <li><code>additional_ends</code>: a list of nodes where paths/walks are allowed to end; paths/walks are still allowed to end in sink nodes.</li> </ul> <p>See also</p> <p>For more details, see k-Least Absolute Values, k-Minimum Path Error</p>"},{"location":"additional-start-end-nodes.html#2-example","title":"2. Example","text":"<p>Suppose we have the example graph from Minimum Flow Decomposition, where on the edges shown in brown we have added a path of weight 20; that is, if we were to remove the path <code>('a', 'b', 'c', 'd')</code> with weight 10, the graph would satisfy flow conservation.</p> <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|6| a\n    a --&gt;|22| b\n    s --&gt;|7| b\n    a --&gt;|4| c\n    b --&gt;|29| c\n    c --&gt;|26| d\n    d --&gt;|6| t\n    c --&gt;|7| t\n\n    linkStyle 1,4,5 stroke:brown,stroke-width:3;</code></pre> <p>If we solve the k-Minimum Path Error model on it for \\(k=4\\) paths, by default, paths must start in a source (<code>'s'</code> is the unique source) and end in a sink (<code>'t'</code> is the unique sink). We thus get total solution slack 10.</p> <pre><code>import flowpaths as fp\nimport networkx as nx\n\ngraph = nx.DiGraph()\ngraph.add_edge(\"s\", \"a\", flow=6)\ngraph.add_edge(\"a\", \"b\", flow=22) #\ngraph.add_edge(\"s\", \"b\", flow=7)\ngraph.add_edge(\"a\", \"c\", flow=4)\ngraph.add_edge(\"b\", \"c\", flow=29) #\ngraph.add_edge(\"c\", \"d\", flow=26) #\ngraph.add_edge(\"d\", \"t\", flow=6)\ngraph.add_edge(\"c\", \"t\", flow=7)\n\nmpe_model = fp.kMinPathError(graph, flow_attr=\"flow\", k=4, weight_type=int)\nmpe_model.solve()\nif mpe_model.is_solved():\n    print(mpe_model.get_solution())\n    # {'paths': [\n    #   ['s', 'a', 'b', 'c', 'd', 't'], \n    #   ['s', 'a', 'c', 'd', 't'], \n    #   ['s', 'b', 'c', 't'], \n    #   ['s', 'a', 'c', 'd', 't']], \n    # 'weights': [12, 1, 7, 3], \n    # 'slacks': [10, 0, 0, 0]}\n</code></pre> <p>If we set <code>additional_starts=['a']</code>, and <code>additional_ends=['d']</code>, we recover indeed the path <code>['a', 'b', 'c', 'd']</code> with weight 20, and the total solution slack is 0.</p> <pre><code>mpe_model_2 = fp.kMinPathError(\n    graph, \n    flow_attr=\"flow\", \n    k=4, \n    weight_type=int,\n    additional_starts=['a'],\n    additional_ends=['d'])\nmpe_model_2.solve()\nif mpe_model_2.is_solved():\n    print(mpe_model_2.get_solution())\n    # {'paths': [\n    #   ['s', 'b', 'c', 't'], \n    #   ['s', 'a', 'b', 'c', 'd', 't'], \n    #   ['s', 'a', 'c', 'd', 't'], \n    #   ['a', 'b', 'c', 'd']], \n    # 'weights': [7, 2, 4, 20], \n    # 'slacks': [0, 0, 0, 0]}\n</code></pre>"},{"location":"additional-start-end-nodes.html#3-pitfalls","title":"3. Pitfalls","text":"<p>Notice that the above paths of total slack 0 the same as the ones in Minimum Flow Decomposition plus the brown path of weight 20, which looks like a good solution.</p> <p><pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|4| a\n    a --&gt;|4| c\n    c --&gt;|4| d\n    d --&gt;|4| t\n    linkStyle 0,1,2,3 stroke:red,stroke-width:3;\n    s --&gt;|2| a\n    a --&gt;|2| b\n    b --&gt;|2| c\n    c --&gt;|2| d\n    d --&gt;|2| t\n    linkStyle 4,5,6,7,8 stroke:orange,stroke-width:3;\n    s --&gt;|7| b\n    b --&gt;|7| c\n    c --&gt;|7| t\n    linkStyle 9,10,11 stroke:blue,stroke-width:3;\n    a --&gt;|20| b\n    b --&gt;|20| c\n    c --&gt;|20| d\n    linkStyle 12,13,14 stroke:brown,stroke-width:3;</code></pre> However, allowing additional starts and ends naturally makes the solution less constrained and allowed for solutions that might not be intended. For example, if we had the same example graph as above, but the brown path has weight 10 instead of 20, the paths of minimum slack are different. In fact, we obtain two paths from <code>'a'</code> to <code>'d'</code>. One needs to make sure this is indended behavior, or otherwise firther constrain the problem.</p> <pre><code>graph10 = nx.DiGraph()\ngraph10.add_edge(\"s\", \"a\", flow=6)\ngraph10.add_edge(\"a\", \"b\", flow=12) #\ngraph10.add_edge(\"s\", \"b\", flow=7)\ngraph10.add_edge(\"a\", \"c\", flow=4)\ngraph10.add_edge(\"b\", \"c\", flow=19) #\ngraph10.add_edge(\"c\", \"d\", flow=16) #\ngraph10.add_edge(\"d\", \"t\", flow=6)\ngraph10.add_edge(\"c\", \"t\", flow=7)\n\nmpe_model_10 = fp.kMinPathError(\n    graph10, \n    flow_attr=\"flow\", \n    k=4, \n    weight_type=int,\n    additional_starts=['a'],\n    additional_ends=['d'])\nmpe_model_10.solve()\nif mpe_model_10.is_solved():\n    print(mpe_model_10.get_solution())\n    # {'paths': [\n    # ['s', 'b', 'c', 't'], \n    # ['s', 'a', 'b', 'c', 'd', 't'], \n    # ['a', 'c', 'd'], \n    # ['a', 'b', 'c', 'd']], \n    # 'weights': [7, 6, 4, 6], \n    # 'slacks': [0, 0, 0, 0]}\n</code></pre>"},{"location":"faq.html","title":"Frequently Asked Questions (FAQ)","text":"<p>This page answers common questions about using the flowpaths package, its models, performance, and troubleshooting. For full guides see the model-specific docs linked throughout.</p>"},{"location":"faq.html#what-problems-does-flowpaths-solve","title":"What problems does flowpaths solve?","text":"<ul> <li>Minimum Flow Decomposition (MFD) on DAGs and on directed graphs with cycles.</li> <li>k-Flow Decomposition, k-Least Absolute Errors, and k-Minimum Path Error.</li> <li>Minimum Path Cover, Minimum Generating Set, Minimum Set Cover, and utilities for node-weighted graphs.</li> </ul> <p>See \u201cModels implemented\u201d on the Home page and links in the top navigation.</p>"},{"location":"faq.html#how-do-i-install-it-and-what-python-versions-are-supported","title":"How do I install it and what Python versions are supported?","text":"<ul> <li>Install with: <code>pip install flowpaths</code>.</li> <li>Requires Python &gt;= 3.8. Dependencies include networkx, highspy (HiGHS), graphviz, and numpy (see pyproject/requirements).</li> </ul>"},{"location":"faq.html#do-i-need-to-install-a-commercial-milp-solver","title":"Do I need to install a commercial MILP solver?","text":"<ul> <li>No. By default flowpaths uses the open-source HiGHS solver via highspy.</li> <li>If you have Gurobi, install gurobipy and set <code>solver_options={\"external_solver\": \"gurobi\"}</code> for potential speed-ups. Academic users can obtain a free academic license\u2014see the Gurobi website for details.</li> </ul>"},{"location":"faq.html#what-does-a-solution-look-like","title":"What does a solution look like?","text":"<ul> <li>The models expose the function <code>get_solution()</code>, which returns a dict:</li> <li><code>paths</code> (or <code>walks</code> for cycle models): list of s\u2013t node lists.</li> <li><code>weights</code>: list of non-negative numbers, one per path/walk.</li> <li>Example: <code>{ 'paths': [['s','b','t'], ['s','a','t']], 'weights': [5, 2] }</code>.</li> </ul>"},{"location":"faq.html#can-i-use-weightsflows-on-nodes-instead-of-edges","title":"Can I use weights/flows on nodes instead of edges?","text":"<ul> <li>Yes. Pass <code>flow_attr_origin=\"node\"</code> and set <code>flow_attr</code> to the node attribute.</li> <li>Internally, node weights are supported via <code>NodeExpandedDiGraph</code>.</li> <li>See \u201cFlows/weights on nodes\u201d for details and examples.</li> </ul>"},{"location":"faq.html#how-do-subpath-or-subset-constraints-work","title":"How do subpath or subset constraints work?","text":"<ul> <li>On DAGs: use subpath constraints, i.e., sequences of edges that must appear in at least one solution path. See \u201cSubpath constraints\u201d.</li> <li>On general directed graphs (with cycles): use subset constraints, i.e., sets of edges that must co-occur in at least one solution walk. See \u201cSubset constraints\u201d.</li> <li>Both support relaxing coverage: fraction of edges to be covered by a solution path/walk.</li> </ul>"},{"location":"faq.html#my-edge-weights-dont-satisfy-flow-conservation-what-should-i-use","title":"My edge weights don\u2019t satisfy flow conservation. What should I use?","text":"<ul> <li>You can first correct the weights to become a flow, see \u201cMinimum Error Flow\u201d, and then decompose the resulting flow.</li> <li> <p>For a more principled approach, you can use the models that handle arbitrary weights:</p> </li> <li> <p>For L1 error on edges: see k-Least Absolute Errors (k-LAE).</p> </li> <li>For robust decomposition with per-path slack: see k-Minimum Path Error (k-MPE).</li> </ul>"},{"location":"faq.html#how-do-i-choose-k","title":"How do I choose k?","text":"<ul> <li>If you know k, use the k-model variant.</li> <li>If unknown on DAGs, <code>MinFlowDecomp</code> finds the minimum k by solving increasing k values starting from a width-based lower bound.</li> <li>See \u201cOptimizing k\u201d (NumPathsOptimization) for routines and tips.</li> <li>Finally, some models allow passing no k (or <code>k = None</code>), and they set it internally as the minimum number of paths/walks needed to cover all edges of the graph (computed internally by the model).</li> </ul>"},{"location":"faq.html#what-are-safe-paths-and-safe-sequences-optimizations","title":"What are \u201csafe paths\u201d and \u201csafe sequences\u201d optimizations?","text":"<ul> <li>They shrink the ILP search space by precomputing path fragments guaranteed to be part of any path cover, speeding up solves without losing optimality (under simple assumptions).</li> <li>Evidence: large speedups, especially on wide graphs.</li> <li>DAG speedups up to two orders of magnitude for path-finding ILPs in realistic settings [Sena &amp; Tomescu, 2024].</li> <li>For MFD, search-space and dimensionality reductions speed up ILPs up to 34\u00d7 on hard instances, and even higher on variants [Grigorjew et al., SEA 2024].</li> <li>These are turned on by default. You can further configure them with <code>optimization_options</code> (see \u201cSolver options and optimizations\u201d).</li> </ul>"},{"location":"faq.html#which-papers-back-the-formulations-and-performance","title":"Which papers back the formulations and performance?","text":"<ul> <li>See \u201cReferences\u201d for links.</li> </ul>"},{"location":"faq.html#why-do-i-get-is_solved-false","title":"Why do I get <code>is_solved() == False</code>?","text":"<ul> <li>Common causes:</li> <li>Time limit too low. Increase <code>solver_options[\"time_limit\"]</code>.</li> <li>Infeasible model (e.g., flow not conserved for MFD on DAGs; incompatible constraints). Check <code>get_model_status()</code> and input assumptions.</li> <li>Using additional start/end nodes with <code>flow_attr_origin='edge'</code> in cycle models (unsupported in some APIs).</li> </ul>"},{"location":"faq.html#what-about-graphs-with-cycles","title":"What about graphs with cycles?","text":"<ul> <li>Use the \u201cwith cycles\u201d classes (e.g., <code>MinFlowDecompCycles</code>, <code>kFlowDecompCycles</code>, <code>kLeastAbsErrorsCycles</code>, <code>kMinPathErrorCycles</code>). These produce <code>walks</code> instead of simple paths.</li> <li>Constraints in cyclic models generalize subpath constraints to subset constraints since order can\u2019t be enforced around cycles.</li> </ul>"},{"location":"faq.html#are-the-results-exact-or-heuristic","title":"Are the results exact or heuristic?","text":"<ul> <li>The core models are solved via ILP/MILP and return optimal solutions subject to the model and time limits. If time-limited, <code>is_solved()</code> will be false and no solution is returned.</li> </ul>"},{"location":"faq.html#how-do-i-validate-a-solution","title":"How do I validate a solution?","text":"<ul> <li>For decomposition models, you can verify: for each edge not ignored, the sum of weights of solution paths/walks using it equals the flow (MFD) or satisfies the model\u2019s error/slack constraints (LAE, MPE, etc.). Some classes expose helpers like <code>is_valid_solution()</code>.</li> </ul>"},{"location":"faq.html#minimal-code-examples","title":"Minimal code examples","text":"<ul> <li>See the main README and the <code>examples/</code> directory for runnable scripts, including DAG and cyclic variants, node-weighted graphs, and constraints.</li> </ul>"},{"location":"ignoring-edges.html","title":"Ignoring edges or nodes","text":"<p>All decomposition models (except <code>MinFlowDecomp</code>) offer the option of ignoring some edges from the constraints that the solution paths need to satisfy, or dampening their effect on the constraints or on the objective value of the model. </p> <p>The indented use-case is when some edges, or their weights, are not fully trusted. Intuitively, we want to keep them in the graph to e.g. allow the solution paths to go through them, but we do not want them to penalize the solution.</p>"},{"location":"ignoring-edges.html#1-implementation","title":"1. Implementation","text":"<p>This is achieved via:</p> <ol> <li>Passing a list  of edges as <code>elements_to_ignore</code>. </li> <li>Passing a dict <code>error_scaling</code> that associates to some edges <code>(u,v)</code> a scaling factor <code>error_scaling[(u,v,)]</code> in the interval [0,1]. If this factor is 0, then edges are completely ignored, if it is 1 they are fully trusted. Adding an edge to <code>elements_to_ignore</code> overrides the value it could be assigned via this dictionary (i.e. it is equivalent to setting its scaling factor to 0). </li> </ol> <p>See also</p> <p>For more details, see k-Least Absolute Values, k-Minimum Path Error</p>"},{"location":"ignoring-edges.html#2-example","title":"2. Example","text":"<p>Suppose we have the graph from Minimum Flow Decomposition, where we multiplied all original edge weights by 10, and in addition we added the edge <code>('a','d')</code> with weight 1.</p> <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|60| a\n    a --&gt;|20| b\n    s --&gt;|70| b\n    a --&gt;|40| c\n    b --&gt;|90| c\n\n    a --&gt;|1| d\n\n    c --&gt;|60| d\n    d --&gt;|60| t\n    c --&gt;|70| t\n\n    linkStyle 5 stroke:brown,stroke-width:3;</code></pre> <p>Notice that we now need at least 4 paths to have a feasible solution, and indeed we get the <code>['s', 'a', 'd', 't']</code> of weight 0 and slack 1, giving a total solution slack of 1.</p> <pre><code>import flowpaths as fp\nimport networkx as nx\n\ngraph = nx.DiGraph()\ngraph.add_edge(\"s\", \"a\", flow=60)\ngraph.add_edge(\"a\", \"b\", flow=20)\ngraph.add_edge(\"s\", \"b\", flow=70)\ngraph.add_edge(\"a\", \"c\", flow=40)\ngraph.add_edge(\"b\", \"c\", flow=90)\ngraph.add_edge(\"c\", \"d\", flow=60)\ngraph.add_edge(\"d\", \"t\", flow=60)\ngraph.add_edge(\"c\", \"t\", flow=70)\n\ngraph.add_edge(\"a\", \"d\", flow=1)\n\nmpe_model = fp.kMinPathError(graph, flow_attr=\"flow\", k=4, weight_type=int)\nmpe_model.solve()\nif mpe_model.is_solved():\n    print(mpe_model.get_solution())\n    # {'paths': [\n    #   ['s', 'a', 'b', 'c', 'd', 't'], \n    #   ['s', 'a', 'c', 'd', 't'], \n    #   ['s', 'a', 'd', 't'], \n    #   ['s', 'b', 'c', 't']], \n    # 'weights': [20, 40, 0, 70], \n    # 'slacks': [0, 0, 1, 0]}\n</code></pre> <p>Such a high difference in weights (or any other domain knowledge) might raise some red flags, so we can set <code>elements_to_ignore = [('a','d')]</code>. Noteice that in this case 3 paths are enough to cover all the edges except <code>('a','d')</code>.</p> <pre><code>mpe_model_2 = fp.kMinPathError(\n    graph, \n    flow_attr=\"flow\", \n    k=3, \n    weight_type=int,\n    elements_to_ignore=[(\"a\", \"d\")])\nmpe_model_2.solve()\nif mpe_model_2.is_solved():\n    print(mpe_model_2.get_solution())\n    # {'paths': [\n    #   ['s', 'a', 'b', 'c', 'd', 't'], \n    #   ['s', 'a', 'c', 'd', 't'], \n    #   ['s', 'b', 'c', 't']], \n    # 'weights': [20, 40, 70], \n    # 'slacks': [0, 0, 0]}\n</code></pre> <p>These paths are as follows, and notice that in this example they do not even pass through the edge <code>('a','d')</code>.</p> <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|40| a\n    a --&gt;|40| c\n    c --&gt;|40| d\n    d --&gt;|40| t\n    linkStyle 0,1,2,3 stroke:red,stroke-width:3;\n    s --&gt;|20| a\n    a --&gt;|20| b\n    b --&gt;|20| c\n\n    a --&gt;|1| d\n\n    c --&gt;|20| d\n    d --&gt;|20| t\n    linkStyle 4,5,6,8,9 stroke:orange,stroke-width:3;\n    s --&gt;|70| b\n    b --&gt;|70| c\n    c --&gt;|70| t\n    linkStyle 10,11,12 stroke:blue,stroke-width:3;</code></pre>"},{"location":"k-flow-decomposition-cycles.html","title":"k-Flow Decomposition in General Graphs","text":"<p>See also</p> <ul> <li>Minimum Flow Decomposition in General Graphs</li> <li>k-Flow Decomposition in Acyclic Graphs</li> <li>Handling graphs with flows / weights on nodes</li> </ul> <p>This class implements a solver for the problem of decomposing a flow in a general graph possibly with cycles into a given number \\(k\\) of walks (\\(k\\)-flow decomposition). This problem is a generalization of Minimum Flow Decomposition, in the sense that we are also given the number of walks that we need to decompose the flow in.</p> <p>The class MinFlowDecompCycles uses this class internally to find the minimum value of \\(k\\) for which a \\(k\\)-flow decomposition exists.</p> <p>Warning</p> <p>Suppose that the number of walks of a minimum flow decomposition is \\(k^*\\). If we ask for a decomposition with \\(k &gt; k^*\\) walks, this class will always return a decomposition with \\(k\\) walks, but some walks might have weight 0.</p>"},{"location":"k-flow-decomposition-cycles.html#flowpaths.kflowdecompcycles.kFlowDecompCycles","title":"kFlowDecompCycles","text":"<pre><code>kFlowDecompCycles(\n    G: DiGraph,\n    flow_attr: str,\n    k: int,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1.0,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = None,\n    solver_options: dict = {},\n)\n</code></pre> <p>               Bases: <code>AbstractWalkModelDiGraph</code></p> <p>This class implements the k-Flow Decomposition problem, namely it looks for a decomposition of a weighted general directed graph, possibly with cycles, into  \\(k\\) weighted walks such that the flow on each edge of the graph equals the sum of the weights of the walks going through that edge (multiplied by the number of times the walk goes through it).</p>"},{"location":"k-flow-decomposition-cycles.html#flowpaths.kflowdecompcycles.kFlowDecompCycles--parameters","title":"Parameters","text":"<ul> <li> <p><code>G: nx.DiGraph</code></p> <p>The input directed graph, as networkx DiGraph, which can have cycles.</p> </li> <li> <p><code>flow_attr: str</code></p> <p>The attribute name from where to get the flow values on the edges.</p> </li> <li> <p><code>k: int</code></p> <p>The number of walks to decompose in.</p> </li> <li> <p><code>flow_attr_origin: str</code>, optional</p> <p>The origin of the flow attribute. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: the flow attribute is assumed to be on the edges of the graph.</li> <li><code>\"node\"</code>: the flow attribute is assumed to be on the nodes of the graph. See the documentation on how node-weighted graphs are handled.</li> </ul> </li> <li> <p><code>weight_type: int | float</code>, optional</p> <p>The type of the weights and slacks (<code>int</code> or <code>float</code>). Default is <code>float</code>.</p> </li> <li> <p><code>subset_constraints: list</code>, optional</p> <p>List of subset constraints. Default is an empty list.  Each subset constraint is a list of edges that must be covered by some solution walk (in any order), according  to the <code>subset_constraints_coverage</code> parameter (see below).</p> </li> <li> <p><code>subset_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subset constraints that must be covered by some solution walk. </p> <p>Defaults to <code>1.0</code>, meaning that 100% of the edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) of  the constraint need to be covered by some solution walk).  See subset constraints documentation</p> </li> <li> <p><code>elements_to_ignore: list</code>, optional</p> <p>List of edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) to ignore when adding constrains on flow explanation by the weighted walks.  Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>additional_starts: list</code>, optional</p> <p>List of additional start nodes of the walks. Default is an empty list.</p> </li> <li> <p><code>additional_ends: list</code>, optional</p> <p>List of additional end nodes of the walks. Default is an empty list.</p> </li> <li> <p><code>optimization_options: dict</code>, optional</p> <p>Dictionary with the optimization options. Default is <code>None</code>. See optimization options documentation.</p> </li> <li> <p><code>solver_options: dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>{}</code>. See solver options documentation.</p> </li> </ul>"},{"location":"k-flow-decomposition-cycles.html#flowpaths.kflowdecompcycles.kFlowDecompCycles--raises","title":"Raises","text":"<ul> <li> <p><code>ValueError</code></p> <ul> <li>If <code>weight_type</code> is not <code>int</code> or <code>float</code>.</li> <li>If the flow attribute <code>flow_attr</code> is not specified in some edge.</li> <li>If the graph contains edges with negative flow values.</li> <li>ValueError: If <code>flow_attr_origin</code> is not <code>node</code> or <code>edge</code>.</li> </ul> </li> </ul> Source code in <code>flowpaths/kflowdecompcycles.py</code> <pre><code>def __init__(\n    self,\n    G: nx.DiGraph,\n    flow_attr: str,\n    k: int,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1.0,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = None,\n    solver_options: dict = {},\n):\n    \"\"\"\n    This class implements the k-Flow Decomposition problem, namely it looks for a decomposition of a weighted general directed graph, possibly with cycles, into \n    $k$ weighted walks such that the flow on each edge of the graph equals the sum of the weights of the walks going through that edge (multiplied by the number of times the walk goes through it).\n\n    Parameters\n    ----------\n    - `G: nx.DiGraph`\n\n        The input directed graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html), which can have cycles.\n\n    - `flow_attr: str`\n\n        The attribute name from where to get the flow values on the edges.\n\n    - `k: int`\n\n        The number of walks to decompose in.\n\n    - `flow_attr_origin: str`, optional\n\n        The origin of the flow attribute. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: the flow attribute is assumed to be on the edges of the graph.\n        - `\"node\"`: the flow attribute is assumed to be on the nodes of the graph. See [the documentation](node-expanded-digraph.md) on how node-weighted graphs are handled.\n\n    - `weight_type: int | float`, optional\n\n        The type of the weights and slacks (`int` or `float`). Default is `float`.\n\n     - `subset_constraints: list`, optional\n\n        List of subset constraints. Default is an empty list. \n        Each subset constraint is a list of edges that must be covered by some solution walk (in any order), according \n        to the `subset_constraints_coverage` parameter (see below).\n\n    - `subset_constraints_coverage: float`, optional\n\n        Coverage fraction of the subset constraints that must be covered by some solution walk. \n\n        Defaults to `1.0`, meaning that 100% of the edges (or nodes, if `flow_attr_origin` is `\"node\"`) of \n        the constraint need to be covered by some solution walk). \n        See [subset constraints documentation](subset-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `elements_to_ignore: list`, optional\n\n        List of edges (or nodes, if `flow_attr_origin` is `\"node\"`) to ignore when adding constrains on flow explanation by the weighted walks. \n        Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `additional_starts: list`, optional\n\n        List of additional start nodes of the walks. Default is an empty list.\n\n    - `additional_ends: list`, optional\n\n        List of additional end nodes of the walks. Default is an empty list.\n\n    - `optimization_options: dict`, optional\n\n        Dictionary with the optimization options. Default is `None`. See [optimization options documentation](solver-options-optimizations.md).\n\n    - `solver_options: dict`, optional\n\n        Dictionary with the solver options. Default is `{}`. See [solver options documentation](solver-options-optimizations.md).\n\n    Raises\n    ------\n    - `ValueError`\n\n        - If `weight_type` is not `int` or `float`.\n        - If the flow attribute `flow_attr` is not specified in some edge.\n        - If the graph contains edges with negative flow values.\n        - ValueError: If `flow_attr_origin` is not `node` or `edge`.\n    \"\"\"\n    utils.logger.info(f\"{__name__}: START initializing with graph id = {utils.fpid(G)}, k = {k}\")\n\n    # Handling node-weighted graphs\n    self.flow_attr_origin = flow_attr_origin\n    if self.flow_attr_origin == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n        self.G_internal = nedg.NodeExpandedDiGraph(G, node_flow_attr=flow_attr)\n        subset_constraints_internal = self.G_internal.get_expanded_subpath_constraints(subset_constraints)\n        additional_starts_internal = self.G_internal.get_expanded_additional_starts(additional_starts)\n        additional_ends_internal = self.G_internal.get_expanded_additional_ends(additional_ends)\n\n        if not all(isinstance(element_to_ignore, str) for element_to_ignore in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n        edges_to_ignore_internal = list(set(edges_to_ignore_internal))\n\n    elif self.flow_attr_origin == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n        self.G_internal = G\n        subset_constraints_internal = subset_constraints\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n        additional_starts_internal = additional_starts\n        additional_ends_internal = additional_ends\n    else:\n        utils.logger.error(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n        raise ValueError(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n\n    self.G = stdigraph.stDiGraph(self.G_internal, additional_starts=additional_starts_internal, additional_ends=additional_ends_internal)\n    self.subset_constraints = subset_constraints_internal\n    self.edges_to_ignore = self.G.source_sink_edges.union(edges_to_ignore_internal)\n\n    if weight_type not in [int, float]:\n        utils.logger.error(f\"{__name__}: weight_type must be either int or float, not {weight_type}\")\n        raise ValueError(f\"weight_type must be either int or float, not {weight_type}\")\n    self.weight_type = weight_type\n\n\n    self.k = k\n    self.optimization_options = optimization_options or {}        \n\n    self.subset_constraints_coverage = subset_constraints_coverage\n\n    self.flow_attr = flow_attr\n    self.w_max = self.k * self.weight_type(\n        self.G.get_max_flow_value_and_check_non_negative_flow(\n            flow_attr=self.flow_attr, edges_to_ignore=self.edges_to_ignore\n        )\n    )\n\n    self.pi_vars = {}\n    self.path_weights_vars = {}\n\n    self.path_weights_sol = None\n    self._solution = None\n    self._lowerbound_k = None\n\n    self.solve_statistics = {}\n    self.solve_time_start = time.perf_counter()\n\n    self.optimization_options[\"trusted_edges_for_safety\"] = self.G.get_non_zero_flow_edges(flow_attr=self.flow_attr, edges_to_ignore=self.edges_to_ignore)\n\n    # Call the constructor of the parent class AbstractPathModelDAG\n    # Build per-edge repetition upper bounds: use the edge flow when available,\n    # otherwise fall back to self.w_max (e.g., for source/sink helper edges).\n    self.edge_upper_bounds_dict = {\n        (u, v): (data[self.flow_attr] if self.flow_attr in data else self.w_max)\n        for u, v, data in self.G.edges(data=True)\n    }\n    super().__init__(\n        G=self.G,\n        k=self.k,\n        # max_edge_repetition=self.w_max,\n        max_edge_repetition_dict=self.edge_upper_bounds_dict,\n        subset_constraints=self.subset_constraints,\n        subset_constraints_coverage=self.subset_constraints_coverage,\n        optimization_options=self.optimization_options,\n        solver_options=solver_options,\n        solve_statistics=self.solve_statistics\n    )\n\n    utils.logger.debug(f\"{__name__}: START create_solver_and_walks()\")\n    # This method is called from the super class AbstractWalkModelDiGraph\n    self.create_solver_and_walks()\n    utils.logger.debug(f\"{__name__}: END create_solver_and_walks()\")\n\n    utils.logger.debug(f\"{__name__}: START encoding flow decomposition\")\n    # This method is called from the current class \n    self._encode_flow_decomposition()\n    utils.logger.debug(f\"{__name__}: END encoding flow decomposition\")\n\n    utils.logger.debug(f\"{__name__}: START encoding given weights\")\n    # This method is called from the current class\n    self._encode_given_weights()\n    utils.logger.debug(f\"{__name__}: END encoding given weights\")\n\n    utils.logger.info(f\"{__name__}: END initialized with graph id = {utils.fpid(G)}, k = {self.k}\")\n</code></pre>"},{"location":"k-flow-decomposition-cycles.html#flowpaths.kflowdecompcycles.kFlowDecompCycles.get_solution","title":"get_solution","text":"<pre><code>get_solution(\n    remove_empty_walks=True,\n)\n</code></pre> <p>Retrieves the solution for the flow decomposition problem.</p> <p>If the solution has already been computed and cached as <code>self.solution</code>, it returns the cached solution. Otherwise, it checks if the problem has been solved, computes the solution walks, weights and caches the solution.</p>"},{"location":"k-flow-decomposition-cycles.html#flowpaths.kflowdecompcycles.kFlowDecompCycles.get_solution--returns","title":"Returns","text":"<ul> <li> <p><code>solution: dict</code></p> <p>A dictionary containing the solution walks (key <code>\"walks\"</code>) and their corresponding weights (key <code>\"weights\"</code>).</p> </li> </ul>"},{"location":"k-flow-decomposition-cycles.html#flowpaths.kflowdecompcycles.kFlowDecompCycles.get_solution--raises","title":"Raises","text":"<ul> <li><code>exception</code> If model is not solved.</li> </ul> Source code in <code>flowpaths/kflowdecompcycles.py</code> <pre><code>def get_solution(self, remove_empty_walks=True):\n    \"\"\"\n    Retrieves the solution for the flow decomposition problem.\n\n    If the solution has already been computed and cached as `self.solution`, it returns the cached solution.\n    Otherwise, it checks if the problem has been solved, computes the solution walks, weights\n    and caches the solution.\n\n\n    Returns\n    -------\n    - `solution: dict`\n\n        A dictionary containing the solution walks (key `\"walks\"`) and their corresponding weights (key `\"weights\"`).\n\n    Raises\n    -------\n    - `exception` If model is not solved.\n    \"\"\"\n\n    if self._solution is not None:\n        return self._remove_empty_walks(self._solution) if remove_empty_walks else self._solution\n\n    self.check_is_solved()\n\n    weights_sol_dict = self.solver.get_values(self.path_weights_vars)\n\n    utils.logger.debug(f\"{__name__}: weights_sol_dict = {weights_sol_dict}\")\n\n    self.path_weights_sol = [\n        (\n            round(weights_sol_dict[i])\n            if self.weight_type == int\n            else float(weights_sol_dict[i])\n        )\n        for i in range(self.k)\n    ]\n\n    if self.flow_attr_origin == \"edge\":\n        self._solution = {\n            \"walks\": self.get_solution_walks(),\n            \"weights\": self.path_weights_sol,\n        }\n    elif self.flow_attr_origin == \"node\":\n        self._solution = {\n            \"_walks_internal\": self.get_solution_walks(),\n            \"walks\": self.G_internal.get_condensed_paths(self.get_solution_walks()),\n            \"weights\": self.path_weights_sol,\n        }\n\n    return self._remove_empty_walks(self._solution) if remove_empty_walks else self._solution\n</code></pre>"},{"location":"k-flow-decomposition-cycles.html#flowpaths.kflowdecompcycles.kFlowDecompCycles.is_valid_solution","title":"is_valid_solution","text":"<pre><code>is_valid_solution(\n    tolerance=0.001,\n)\n</code></pre> <p>Checks if the solution is valid by comparing the flow from walks with the flow attribute in the graph edges.</p>"},{"location":"k-flow-decomposition-cycles.html#flowpaths.kflowdecompcycles.kFlowDecompCycles.is_valid_solution--raises","title":"Raises","text":"<ul> <li>ValueError: If the solution is not available (i.e., self.solution is None).</li> </ul>"},{"location":"k-flow-decomposition-cycles.html#flowpaths.kflowdecompcycles.kFlowDecompCycles.is_valid_solution--returns","title":"Returns","text":"<ul> <li>bool: True if the solution is valid, False otherwise.</li> </ul>"},{"location":"k-flow-decomposition-cycles.html#flowpaths.kflowdecompcycles.kFlowDecompCycles.is_valid_solution--notes","title":"Notes","text":"<ul> <li><code>get_solution()</code> must be called before this method.</li> <li>The solution is considered valid if the flow from walks is equal     (up to <code>TOLERANCE * num_edge_walks_on_edges[(u, v)]</code>) to the flow value of the graph edges.</li> </ul> Source code in <code>flowpaths/kflowdecompcycles.py</code> <pre><code>def is_valid_solution(self, tolerance=0.001):\n    \"\"\"\n    Checks if the solution is valid by comparing the flow from walks with the flow attribute in the graph edges.\n\n    Raises\n    ------\n    - ValueError: If the solution is not available (i.e., self.solution is None).\n\n    Returns\n    -------\n    - bool: True if the solution is valid, False otherwise.\n\n    Notes\n    -------\n    - `get_solution()` must be called before this method.\n    - The solution is considered valid if the flow from walks is equal\n        (up to `TOLERANCE * num_edge_walks_on_edges[(u, v)]`) to the flow value of the graph edges.\n    \"\"\"\n\n    if self._solution is None:\n        self.get_solution()\n\n    solution_walks = self._solution.get(\"_walks_internal\", self._solution[\"walks\"])\n    solution_weights = self._solution[\"weights\"]\n    solution_walks_of_edges = [\n        [(walk[i], walk[i + 1]) for i in range(len(walk) - 1)]\n        for walk in solution_walks\n    ]\n\n    weight_from_walks = {(u, v): 0 for (u, v) in self.G.edges()}\n    num_edge_walks_on_edges = {e: 0 for e in self.G.edges()}\n    for weight, walk in zip(solution_weights, solution_walks_of_edges):\n        for e in walk:\n            weight_from_walks[e] += weight\n            num_edge_walks_on_edges[e] += 1\n\n    for u, v, data in self.G.edges(data=True):\n        if self.flow_attr in data and (u,v) not in self.edges_to_ignore:\n            if (\n                abs(data[self.flow_attr] - weight_from_walks[(u, v)])\n                &gt; tolerance * max(1,num_edge_walks_on_edges[(u, v)])\n            ):\n                utils.logger.error(\n                    f\"{__name__}: Invalid solution for edge ({u}, {v}): \"\n                    f\"flow value {data[self.flow_attr]} != weight from walks {weight_from_walks[(u, v)]} \"\n                )\n                return False\n\n    return True\n</code></pre>"},{"location":"k-flow-decomposition.html","title":"k-Flow Decomposition","text":"<p>See also</p> <ul> <li>Minimum Flow Decomposition</li> <li>An Optimization Routine for the Number k of Paths</li> <li>Handling graphs with flows / weights on nodes</li> <li>k-Flow Decomposition with cycles</li> </ul> <p>This class implements a solver for the problem of decomposing a flow into a given number \\(k\\) of paths (\\(k\\)-flow decomposition). This problem is a generalization of Minimum Flow Decomposition, in the sense that we are also given the number of paths that we need to decompose the flow in.</p> <p>The class MinFlowDecomp uses this class internally to find the minimum value of \\(k\\) for which a \\(k\\)-flow decomposition exists.</p> <p>Warning</p> <p>Suppose that the number of paths of a minimum flow decomposition is \\(k^*\\). If we ask for a decomposition with \\(k &gt; k^*\\) paths, this class will always return a decomposition with \\(k\\) paths, but some paths might have weight 0.</p>"},{"location":"k-flow-decomposition.html#flowpaths.kflowdecomp.kFlowDecomp","title":"kFlowDecomp","text":"<pre><code>kFlowDecomp(\n    G: DiGraph,\n    flow_attr: str,\n    k: int,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1.0,\n    subpath_constraints_coverage_length: float = None,\n    length_attr: str = None,\n    elements_to_ignore: list = [],\n    solution_weights_superset: list = None,\n    optimization_options: dict = {},\n    solver_options: dict = {},\n)\n</code></pre> <p>               Bases: <code>AbstractPathModelDAG</code></p> <p>Initialize the Flow Decomposition model for a given number of paths <code>k</code>.</p>"},{"location":"k-flow-decomposition.html#flowpaths.kflowdecomp.kFlowDecomp--parameters","title":"Parameters","text":"<ul> <li> <p><code>G : nx.DiGraph</code></p> <p>The input directed acyclic graph, as networkx DiGraph.</p> </li> <li> <p><code>flow_attr : str</code></p> <p>The attribute name from where to get the flow values on the edges.</p> </li> <li> <p><code>k: int</code></p> <p>The number of paths to decompose in.</p> </li> <li> <p><code>flow_attr_origin : str</code>, optional</p> <p>The origin of the flow attribute. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: the flow attribute is assumed to be on the edges of the graph.</li> <li><code>\"node\"</code>: the flow attribute is assumed to be on the nodes of the graph. See the documentation on how node-weighted graphs are handled.</li> </ul> </li> <li> <p><code>weight_type : type</code>, optional</p> <p>The type of weights (<code>int</code> or <code>float</code>). Default is <code>float</code>.</p> </li> <li> <p><code>subpath_constraints : list</code>, optional</p> <p>List of subpath constraints. Default is an empty list.  Each subpath constraint is a list of edges that must be covered by some solution path, according  to the <code>subpath_constraints_coverage</code> or <code>subpath_constraints_coverage_length</code> parameters (see below).</p> </li> <li> <p><code>subpath_constraints_coverage : float</code>, optional</p> <p>Coverage fraction of the subpath constraints that must be covered by some solution paths. </p> <p>Defaults to <code>1.0</code>, meaning that 100% of the edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) of  the constraint need to be covered by some solution path).  See subpath constraints documentation</p> </li> <li> <p><code>subpath_constraints_coverage_length : float</code>, optional</p> <p>Coverage length of the subpath constraints. Default is <code>None</code>. If set, this overrides <code>subpath_constraints_coverage</code>,  and the coverage constraint is expressed in terms of the subpath constraint length.  <code>subpath_constraints_coverage_length</code> is then the fraction of the total length of the constraint (specified via <code>length_attr</code>) needs to appear in some solution path. See subpath constraints documentation</p> </li> <li> <p><code>length_attr : str</code>, optional</p> <p>The attribute name from where to get the edge lengths (or node length, if <code>flow_attr_origin</code> is <code>\"node\"</code>). Defaults to <code>None</code>.</p> <ul> <li>If set, then the subpath lengths (above) are in terms of the edge/node lengths specified in the <code>length_attr</code> field of each edge/node.</li> <li>If set, and an edge/node has a missing edge length, then it gets length 1.</li> </ul> </li> <li> <p><code>elements_to_ignore : list</code>, optional</p> <p>List of edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) to ignore when adding constrains on flow explanation by the weighted paths. Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>solution_weights_superset: list</code>, optional</p> <p>List of allowed weights for the paths. Default is <code>None</code>.  If set, the model will use the solution path weights only from this set, with the property that every weight in this list appears at most once in the solution weight. That is, if you want to have more paths with the same weight, add it more times to <code>solution_weights_superset</code>.</p> </li> <li> <p><code>optimization_options : dict</code>, optional</p> <p>Dictionary with the optimization options. Default is <code>None</code>. See optimization options documentation. This class also supports the optimization <code>\"optimize_with_greedy\": True</code> (this is the default value). This will use a greedy algorithm to solve the problem, and if the number of paths returned by it equals a lowerbound on the solution size, then we know the greedy solution is optimum, and it will use that. The lowerbound used currently is the edge-width of the graph, meaning the minimum number of paths needed to cover all edges. This is a correct lowerbound because any flow decomposition must cover all edges,  as they have non-zero flow.</p> </li> <li> <p><code>solver_options : dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>None</code>. See solver options documentation.</p> </li> </ul>"},{"location":"k-flow-decomposition.html#flowpaths.kflowdecomp.kFlowDecomp--raises","title":"Raises","text":"<ul> <li>ValueError: If <code>weight_type</code> is not int or float.</li> <li>ValueError: If some edge does not have the flow attribute specified as <code>flow_attr</code>.</li> <li>ValueError: If the graph does not satisfy flow conservation on nodes different from source or sink.</li> <li>ValueError: If the graph contains edges with negative (&lt;0) flow values.</li> <li>ValueError: If <code>flow_attr_origin</code> is not \u201cnode\u201d or \u201cedge\u201d.</li> </ul> Source code in <code>flowpaths/kflowdecomp.py</code> <pre><code>def __init__(\n    self,\n    G: nx.DiGraph,\n    flow_attr: str,\n    k: int,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1.0,\n    subpath_constraints_coverage_length: float = None,\n    length_attr: str = None,\n    elements_to_ignore: list = [],\n    solution_weights_superset: list = None,\n    optimization_options: dict = {},\n    solver_options: dict = {},\n):\n    \"\"\"\n    Initialize the Flow Decomposition model for a given number of paths `k`.\n\n    Parameters\n    ----------\n    - `G : nx.DiGraph`\n\n        The input directed acyclic graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html).\n\n    - `flow_attr : str`\n\n        The attribute name from where to get the flow values on the edges.\n\n    - `k: int`\n\n        The number of paths to decompose in.\n\n    - `flow_attr_origin : str`, optional\n\n        The origin of the flow attribute. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: the flow attribute is assumed to be on the edges of the graph.\n        - `\"node\"`: the flow attribute is assumed to be on the nodes of the graph. See [the documentation](node-expanded-digraph.md) on how node-weighted graphs are handled.\n\n    - `weight_type : type`, optional\n\n        The type of weights (`int` or `float`). Default is `float`.\n\n    - `subpath_constraints : list`, optional\n\n        List of subpath constraints. Default is an empty list. \n        Each subpath constraint is a list of edges that must be covered by some solution path, according \n        to the `subpath_constraints_coverage` or `subpath_constraints_coverage_length` parameters (see below).\n\n    - `subpath_constraints_coverage : float`, optional\n\n        Coverage fraction of the subpath constraints that must be covered by some solution paths. \n\n        Defaults to `1.0`, meaning that 100% of the edges (or nodes, if `flow_attr_origin` is `\"node\"`) of \n        the constraint need to be covered by some solution path). \n        See [subpath constraints documentation](subpath-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `subpath_constraints_coverage_length : float`, optional\n\n        Coverage length of the subpath constraints. Default is `None`. If set, this overrides `subpath_constraints_coverage`, \n        and the coverage constraint is expressed in terms of the subpath constraint length. \n        `subpath_constraints_coverage_length` is then the fraction of the total length of the constraint (specified via `length_attr`) needs to appear in some solution path.\n        See [subpath constraints documentation](subpath-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `length_attr : str`, optional\n\n        The attribute name from where to get the edge lengths (or node length, if `flow_attr_origin` is `\"node\"`). Defaults to `None`.\n\n        - If set, then the subpath lengths (above) are in terms of the edge/node lengths specified in the `length_attr` field of each edge/node.\n        - If set, and an edge/node has a missing edge length, then it gets length 1.\n\n    - `elements_to_ignore : list`, optional\n\n        List of edges (or nodes, if `flow_attr_origin` is `\"node\"`) to ignore when adding constrains on flow explanation by the weighted paths. Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `solution_weights_superset: list`, optional\n\n        List of allowed weights for the paths. Default is `None`. \n        If set, the model will use the solution path weights only from this set, with the property that **every weight in this list\n        appears at most once in the solution weight**. That is, if you want to have more paths with the same weight, add it more times to `solution_weights_superset`.\n\n    - `optimization_options : dict`, optional\n\n        Dictionary with the optimization options. Default is `None`. See [optimization options documentation](solver-options-optimizations.md).\n        This class also supports the optimization `\"optimize_with_greedy\": True` (this is the default value). This\n        will use a greedy algorithm to solve the problem, and if the number of paths returned by it equals a lowerbound on the solution size,\n        then we know the greedy solution is optimum, and it will use that. The lowerbound used currently is the edge-width of the graph,\n        meaning the minimum number of paths needed to cover all edges. This is a correct lowerbound because any flow decomposition must cover all edges, \n        as they have non-zero flow.\n\n    - `solver_options : dict`, optional\n\n        Dictionary with the solver options. Default is `None`. See [solver options documentation](solver-options-optimizations.md).\n\n\n    Raises\n    ----------\n    - ValueError: If `weight_type` is not int or float.\n    - ValueError: If some edge does not have the flow attribute specified as `flow_attr`.\n    - ValueError: If the graph does not satisfy flow conservation on nodes different from source or sink.\n    - ValueError: If the graph contains edges with negative (&lt;0) flow values.\n    - ValueError: If `flow_attr_origin` is not \"node\" or \"edge\".\n    \"\"\"\n\n    utils.logger.info(f\"{__name__}: START initializing with graph id = {utils.fpid(G)}, k = {k}\")\n\n    # Handling node-weighted graphs\n    self.flow_attr_origin = flow_attr_origin\n    if self.flow_attr_origin == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n        self.G_internal = nedg.NodeExpandedDiGraph(G, node_flow_attr=flow_attr, node_length_attr=length_attr)\n        subpath_constraints_internal = self.G_internal.get_expanded_subpath_constraints(subpath_constraints)\n\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        if not all(isinstance(element_to_ignore, str) for element_to_ignore in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n        edges_to_ignore_internal = list(set(edges_to_ignore_internal))\n\n    elif self.flow_attr_origin == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n        self.G_internal = G\n        subpath_constraints_internal = subpath_constraints\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n    else:\n        utils.logger.error(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n        raise ValueError(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n\n    self.G = stdag.stDAG(self.G_internal)\n    self.subpath_constraints = subpath_constraints_internal\n    self.edges_to_ignore = self.G.source_sink_edges.union(edges_to_ignore_internal)\n\n    if weight_type not in [int, float]:\n        utils.logger.error(f\"weight_type must be either int or float, not {weight_type}\")\n        raise ValueError(f\"weight_type must be either int or float, not {weight_type}\")\n    self.weight_type = weight_type\n\n    # Check requirements on input graph:\n    # Check flow conservation only if there are no edges to ignore\n    satisfies_flow_conservation = gu.check_flow_conservation(G, flow_attr)\n    if len(edges_to_ignore_internal) == 0 and not satisfies_flow_conservation:\n        utils.logger.error(f\"{__name__}: The graph G does not satisfy flow conservation or some edges have missing `flow_attr`. This is an error, unless you passed `edges_to_ignore` to include at least those edges with missing `flow_attr`.\")\n        raise ValueError(\"The graph G does not satisfy flow conservation or some edges have missing `flow_attr`. This is an error, unless you passed `edges_to_ignore` to include at least those edges with missing `flow_attr`.\")\n\n    # Check that the flow is positive and get max flow value\n    self.flow_attr = flow_attr\n    self.w_max = self.weight_type(\n        self.G.get_max_flow_value_and_check_non_negative_flow(\n            flow_attr=self.flow_attr, edges_to_ignore=self.edges_to_ignore\n        )\n    )\n\n    if k &lt;= 0 or not isinstance(k, int):\n        utils.logger.error(f\"{__name__}: k must be a positive integer, not {k}\")\n        raise ValueError(f\"k must be a positive integer, not {k}\")\n    self.k = k\n    self.original_k = self.k\n\n    self.subpath_constraints_coverage = subpath_constraints_coverage\n    self.subpath_constraints_coverage_length = subpath_constraints_coverage_length\n    self.length_attr = length_attr\n\n    self.pi_vars = {}\n    self.path_weights_vars = {}\n\n    self.path_weights_sol = None\n    self._solution = None\n    self._lowerbound_k = None\n\n    self.solve_statistics = {}\n    self.optimization_options = optimization_options.copy() or {}\n\n    greedy_solution_paths = None\n    self.optimize_with_greedy = self.optimization_options.get(\"optimize_with_greedy\", kFlowDecomp.optimize_with_greedy)\n    self.optimize_with_flow_safe_paths = self.optimization_options.get(\"optimize_with_flow_safe_paths\", kFlowDecomp.optimize_with_flow_safe_paths)\n\n    # We can apply the greedy algorithm only if \n    # - there are no edges to ignore (in the original input graph), and \n    # - the graph satisfies flow conservation\n    if self.optimize_with_greedy and len(edges_to_ignore_internal) == 0 and satisfies_flow_conservation:\n        if self._get_solution_with_greedy():\n            greedy_solution_paths = self._solution[\"paths\"]\n            self.optimization_options[\"external_solution_paths\"] = greedy_solution_paths\n\n    if self.optimize_with_flow_safe_paths and satisfies_flow_conservation:\n        start_time = time.perf_counter()\n        self.optimization_options[\"external_safe_paths\"] = sfd.compute_flow_decomp_safe_paths(G=G, flow_attr=self.flow_attr)\n        self.solve_statistics[\"flow_safe_paths_time\"] = time.perf_counter() - start_time\n        # If we optimize with flow safe paths, we need to disable optimizing with safe paths and sequences\n        if self.optimization_options.get(\"optimize_with_safe_paths\", False):\n            utils.logger.error(f\"{__name__}: Cannot optimize with both flow safe paths and safe paths\")\n            raise ValueError(\"Cannot optimize with both flow safe paths and safe paths\")\n        if self.optimization_options.get(\"optimize_with_safe_sequences\", False):\n            utils.logger.error(f\"{__name__}: Cannot optimize with both flow safe paths and safe sequences\")\n            raise ValueError(\"Cannot optimize with both flow safe paths and safe sequences\")\n\n    self.optimization_options[\"trusted_edges_for_safety\"] = self.G.get_non_zero_flow_edges(flow_attr=self.flow_attr, edges_to_ignore=self.edges_to_ignore)\n\n    self.solution_weights_superset = solution_weights_superset\n\n    if self.solution_weights_superset is not None:\n        self.k = len(self.solution_weights_superset)\n        self.optimization_options[\"allow_empty_paths\"] = True\n        self.optimization_options[\"optimize_with_safe_paths\"] = False\n        self.optimization_options[\"optimize_with_flow_safe_paths\"] = False\n        self.optimization_options[\"optimize_with_safe_sequences\"] = False\n        self.optimization_options[\"optimize_with_safe_zero_edges\"] = False\n\n    # Call the constructor of the parent class AbstractPathModelDAG\n    super().__init__(\n        G=self.G, \n        k=self.k,\n        subpath_constraints=self.subpath_constraints, \n        subpath_constraints_coverage=self.subpath_constraints_coverage, \n        subpath_constraints_coverage_length=self.subpath_constraints_coverage_length,\n        length_attr=self.length_attr, \n        optimization_options=self.optimization_options,\n        solver_options=solver_options,\n        solve_statistics=self.solve_statistics,\n    )\n\n    # If already solved with a previous method, we don't create solver, not add paths\n    if self.is_solved():\n        return\n\n    # This method is called from the super class AbstractPathModelDAG\n    self.create_solver_and_paths()\n\n    # This method is called from the current class to encode the flow decomposition\n    if self.solution_weights_superset is None:\n        self._encode_flow_decomposition()\n    else:\n        self._encode_flow_decomposition_with_given_weights()\n\n    utils.logger.info(f\"{__name__}: END initialized with graph id = {utils.fpid(G)}, k = {self.k}\")\n</code></pre>"},{"location":"k-flow-decomposition.html#flowpaths.kflowdecomp.kFlowDecomp.get_solution","title":"get_solution","text":"<pre><code>get_solution(\n    remove_empty_paths=False,\n)\n</code></pre> <p>Retrieves the solution for the flow decomposition problem.</p> <p>If the solution has already been computed and cached as <code>self.solution</code>, it returns the cached solution. Otherwise, it checks if the problem has been solved, computes the solution paths and weights, and caches the solution.</p>"},{"location":"k-flow-decomposition.html#flowpaths.kflowdecomp.kFlowDecomp.get_solution--parameters","title":"Parameters","text":"<ul> <li> <p><code>remove_empty_paths: bool</code>, optional</p> <p>If <code>True</code>, removes empty paths from the solution. Default is <code>False</code>. These can happen only if passed the optimization option <code>\"allow_empty_paths\" : True</code>.</p> </li> </ul>"},{"location":"k-flow-decomposition.html#flowpaths.kflowdecomp.kFlowDecomp.get_solution--returns","title":"Returns","text":"<ul> <li> <p><code>solution: dict</code></p> <p>A dictionary containing the solution paths (key <code>\"paths\"</code>) and their corresponding weights (key <code>\"weights\"</code>).</p> </li> </ul>"},{"location":"k-flow-decomposition.html#flowpaths.kflowdecomp.kFlowDecomp.get_solution--raises","title":"Raises","text":"<ul> <li><code>exception</code> If model is not solved.</li> </ul> Source code in <code>flowpaths/kflowdecomp.py</code> <pre><code>def get_solution(self, remove_empty_paths=False):\n    \"\"\"\n    Retrieves the solution for the flow decomposition problem.\n\n    If the solution has already been computed and cached as `self.solution`, it returns the cached solution.\n    Otherwise, it checks if the problem has been solved, computes the solution paths and weights,\n    and caches the solution.\n\n    Parameters\n    ----------\n\n    - `remove_empty_paths: bool`, optional\n\n        If `True`, removes empty paths from the solution. Default is `False`. These can happen only if passed the optimization option `\"allow_empty_paths\" : True`.\n\n    Returns\n    -------\n    - `solution: dict`\n\n        A dictionary containing the solution paths (key `\"paths\"`) and their corresponding weights (key `\"weights\"`).\n\n    Raises\n    ------\n    - `exception` If model is not solved.\n    \"\"\"\n\n    if self._solution is not None:\n        return self._remove_empty_paths(self._solution) if remove_empty_paths else self._solution\n\n    self.check_is_solved()\n\n    if self.solution_weights_superset is None:\n        weights_sol_dict = self.solver.get_values(self.path_weights_vars)\n    else:\n        weights_sol_dict = {i: self.solution_weights_superset[i] for i in range(self.k)}\n\n    self.path_weights_sol = [\n        (\n            round(weights_sol_dict[i])\n            if self.weight_type == int\n            else float(weights_sol_dict[i])\n        )\n        for i in range(self.k)\n    ]\n\n    if self.flow_attr_origin == \"edge\":\n        self._solution = {\n            \"paths\": self.get_solution_paths(),\n            \"weights\": self.path_weights_sol,\n        }\n    elif self.flow_attr_origin == \"node\":\n        self._solution = {\n            \"_paths_internal\": self.get_solution_paths(),\n            \"paths\": self.G_internal.get_condensed_paths(self.get_solution_paths()),\n            \"weights\": self.path_weights_sol,\n        }\n</code></pre>"},{"location":"k-flow-decomposition.html#flowpaths.kflowdecomp.kFlowDecomp.is_valid_solution","title":"is_valid_solution","text":"<pre><code>is_valid_solution(\n    tolerance=0.001,\n)\n</code></pre> <p>Checks if the solution is valid by comparing the flow from paths with the flow attribute in the graph edges.</p>"},{"location":"k-flow-decomposition.html#flowpaths.kflowdecomp.kFlowDecomp.is_valid_solution--raises","title":"Raises","text":"<ul> <li>ValueError: If the solution is not available (i.e., self.solution is None).</li> </ul>"},{"location":"k-flow-decomposition.html#flowpaths.kflowdecomp.kFlowDecomp.is_valid_solution--returns","title":"Returns","text":"<ul> <li>bool: True if the solution is valid, False otherwise.</li> </ul>"},{"location":"k-flow-decomposition.html#flowpaths.kflowdecomp.kFlowDecomp.is_valid_solution--notes","title":"Notes","text":"<ul> <li>get_solution() must be called before this method.</li> <li>The solution is considered valid if the flow from paths is equal     (up to <code>TOLERANCE * num_paths_on_edges[(u, v)]</code>) to the flow value of the graph edges.</li> </ul> Source code in <code>flowpaths/kflowdecomp.py</code> <pre><code>def is_valid_solution(self, tolerance=0.001):\n    \"\"\"\n    Checks if the solution is valid by comparing the flow from paths with the flow attribute in the graph edges.\n\n    Raises\n    ------\n    - ValueError: If the solution is not available (i.e., self.solution is None).\n\n    Returns\n    -------\n    - bool: True if the solution is valid, False otherwise.\n\n    Notes\n    -------\n    - get_solution() must be called before this method.\n    - The solution is considered valid if the flow from paths is equal\n        (up to `TOLERANCE * num_paths_on_edges[(u, v)]`) to the flow value of the graph edges.\n    \"\"\"\n\n    if self._solution is None:\n        utils.logger.error(f\"{__name__}: Solution is not available. Call get_solution() first.\")\n        raise ValueError(\"Solution is not available. Call get_solution() first.\")\n\n    solution_paths = self._solution.get(\"_paths_internal\", self._solution[\"paths\"])\n    solution_weights = self._solution[\"weights\"]\n    solution_paths_of_edges = [\n        [(path[i], path[i + 1]) for i in range(len(path) - 1)]\n        for path in solution_paths\n    ]\n\n    flow_from_paths = {(u, v): 0 for (u, v) in self.G.edges()}\n    num_paths_on_edges = {e: 0 for e in self.G.edges()}\n    for weight, path in zip(solution_weights, solution_paths_of_edges):\n        for e in path:\n            flow_from_paths[e] += weight\n            num_paths_on_edges[e] += 1\n\n    for u, v, data in self.G.edges(data=True):\n        if self.flow_attr in data and (u,v) not in self.edges_to_ignore:\n            if (\n                abs(flow_from_paths[(u, v)] - data[self.flow_attr])\n                &gt; tolerance * num_paths_on_edges[(u, v)]\n            ):\n                utils.logger.error(f\"Flow validation failed for edge ({u}, v): expected {data[self.flow_attr]}, got {flow_from_paths[(u, v)]}\")\n                return False\n\n    return True\n</code></pre>"},{"location":"k-least-absolute-errors-cycles.html","title":"$k$-Least Absolute Errors","text":"<p>See also</p> <ul> <li>An Optimization Routine for the Number k of Paths</li> <li>Handling graphs with flows / weights on nodes</li> </ul>"},{"location":"k-least-absolute-errors-cycles.html#k-least-absolute-errors-in-general-graphs","title":"k-Least Absolute Errors in General Graphs","text":""},{"location":"k-least-absolute-errors-cycles.html#1-definition","title":"1. Definition","text":"<p>The k-Least Absolute Errors problem on a directed acyclic graph (DAG) is defined as follows. For a walk \\(W\\) and an edge \\((u,v)\\), we denote by \\(W(u,v)\\) the number of times that the walk goes through the edge \\((u,v)\\). If \\(W(u,v)\\) does not contain \\((u,v)\\) , then \\(W(u,v) = 0\\).</p> <ul> <li> <p>INPUT: </p> <ul> <li>A directed graph \\(G = (V,E)\\), and a weight function on \\(G\\), namely weights \\(f(u,v)\\) for every edge \\((u,v)\\) of \\(G\\). The weights are arbitrary non-negative numbers and do not need to satisfy flow conservation.</li> <li>\\(k \\in \\mathbb{Z}\\)</li> </ul> </li> <li> <p>OUTPUT: A number \\(k\\) of walks \\(W_1,\\dots,W_k\\), starting in some node in \\(S\\) and ending in some node in \\(T\\), with a weight \\(w_i\\) associated to each \\(P_i\\), that minimize the objective function: $$ \\sum_{(u,v) \\in E} \\left|f(u,v) - \\sum_{i \\in \\{1,\\dots,k\\}}w_i \\cdot W_i(u,v)\\right|. $$</p> </li> </ul> <p>Note</p> <ul> <li>This class support also graphs with flow values on nodes. Set the parameter <code>flow_attr_origin = \"node\"</code>. For details on how these are handled internally, see Handling graphs with flows / weights on nodes.</li> <li>The graph may have more than one source or sink nodes, in which case the solution paths are just required to start in any source node, and end in any sink node.</li> </ul>"},{"location":"k-least-absolute-errors-cycles.html#2-generalizations","title":"2. Generalizations","text":"<p>This class implements a more general version, as follows:</p> <ol> <li>This class supports adding subset constraints, that is, lists of edges that must appear in some solution path. See Subset constraints for details.</li> <li>The paths can start/end not only in source/sink nodes, but also in given sets of start/end nodes (set parameters <code>additional_starts</code> and <code>additional_ends</code>). See also Additional start/end nodes.</li> <li>The above summation can happen only over a given subset \\(E' \\subseteq E\\) of the edges (set parameter <code>elements_to_ignore</code> to be \\(E \\setminus E'\\)), </li> <li>The error (i.e. the above absolute of the difference) of every edge can contribute differently to the objective function, according to a scale factor \\(\\in [0,1]\\). Set these via a dictionary that you pass to <code>error_scaling</code>, which stores the scale factor \\(\\lambda_{(u,v)} \\in [0,1]\\) of each edge \\((u,v)\\) in the dictionary. Setting \\(\\lambda_{(u,v)} = 0\\) is equivalent to adding the edge \\((u,v)\\) to <code>elements_to_ignore</code>; the latter option is more efficient, as it results in a smaller model.</li> </ol> <p>Generalized objective function</p> <p>Formally, the minimized objective function generalized as in 3. and 4. above is: $$ \\sum_{(u,v) \\in E\u2019} \\lambda_{(u,v)} \\cdot \\left|f(u,v) - \\sum_{i \\in \\{1,\\dots,k\\} : (u,v) \\in P_i }w_i\\right|. $$</p>"},{"location":"k-least-absolute-errors-cycles.html#flowpaths.kleastabserrorscycles.kLeastAbsErrorsCycles","title":"kLeastAbsErrorsCycles","text":"<pre><code>kLeastAbsErrorsCycles(\n    G: DiGraph,\n    flow_attr: str,\n    k: int = None,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1.0,\n    elements_to_ignore: list = [],\n    error_scaling: dict = {},\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = None,\n    solver_options: dict = {},\n    trusted_edges_for_safety: list = None,\n    trusted_edges_for_safety_percentile: float = None,\n)\n</code></pre> <p>               Bases: <code>AbstractWalkModelDiGraph</code></p> <p>This class implements the k-LeastAbsoluteErrors problem, namely it looks for a decomposition of a weighted general directed graph, possibly with cycles, into  \\(k\\) weighted walks, minimizing the absolute errors on the edges. The error on an edge  is defined as the absolute value of the difference between the weight of the edge and the sum of the weights of  the walks that go through it.</p>"},{"location":"k-least-absolute-errors-cycles.html#flowpaths.kleastabserrorscycles.kLeastAbsErrorsCycles--parameters","title":"Parameters","text":"<ul> <li> <p><code>G: nx.DiGraph</code></p> <p>The input directed graph, as networkx DiGraph, which can have cycles.</p> </li> <li> <p><code>flow_attr: str</code></p> <p>The attribute name from where to get the flow values on the edges.</p> </li> <li> <p><code>k: int</code></p> <p>The number of walks to decompose in.</p> <p>Unknown \\(k\\)</p> <p>If you do not have a good guess for \\(k\\), you can pass <code>k=None</code> and the model will set \\(k\\) to the condensation width of the graph (i.e. the minimum number of \\(s\\)-\\(t\\) walks needed to cover all the edges of the graph, except those in <code>edges_to_ignore</code>).</p> </li> <li> <p><code>flow_attr_origin: str</code>, optional</p> <p>The origin of the flow attribute. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: the flow attribute is assumed to be on the edges of the graph.</li> <li><code>\"node\"</code>: the flow attribute is assumed to be on the nodes of the graph. See the documentation on how node-weighted graphs are handled.</li> </ul> </li> <li> <p><code>weight_type: int | float</code>, optional</p> <p>The type of the weights and slacks (<code>int</code> or <code>float</code>). Default is <code>float</code>.</p> </li> <li> <p><code>subset_constraints: list</code>, optional</p> <p>List of subset constraints. Default is an empty list.  Each subset constraint is a list of edges that must be covered by some solution walk, in any order, according  to the <code>subset_constraints_coverage</code> parameter (see below).</p> </li> <li> <p><code>subset_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subset constraints that must be covered by some solution walk. </p> <p>Defaults to <code>1.0</code>, meaning that 100% of the edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) of  the constraint need to be covered by some solution walk).  See subset constraints documentation</p> </li> <li> <p><code>elements_to_ignore: list</code>, optional</p> <p>List of edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) to ignore when adding constrains on flow explanation by the weighted walks.  Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>error_scaling: dict</code>, optional</p> <p>Dictionary <code>edge: factor</code> (or <code>node: factor</code>, if <code>flow_attr_origin</code> is <code>\"node\"</code>)) storing the error scale factor (in [0,1]) of every edge, which scale the allowed difference between edge/node weight and walk weights. Default is an empty dict. If an edge/node has a missing error scale factor, it is assumed to be 1. The factors are used to scale the  difference between the flow value of the edge/node and the sum of the weights of the walks going through the edge/node. See ignoring edges documentation</p> </li> <li> <p><code>additional_starts: list</code>, optional</p> <p>List of additional start nodes of the walks. Default is an empty list.</p> </li> <li> <p><code>additional_ends: list</code>, optional</p> <p>List of additional end nodes of the walks. Default is an empty list.</p> </li> <li> <p><code>optimization_options: dict</code>, optional</p> <p>Dictionary with the optimization options. Default is <code>None</code>. See optimization options documentation.</p> </li> <li> <p><code>solver_options: dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>{}</code>. See solver options documentation.</p> </li> <li> <p><code>trusted_edges_for_safety: list</code>, optional</p> <p>List of edges that are trusted to appear in an optimal solution. Default is <code>None</code>.  If set, the model can apply the safety optimizations for these edges, so it can be significantly faster. See optimizations documentation</p> </li> <li> <p><code>trusted_edges_for_safety_percentile: float</code>, optional</p> <p>If set to a value different than <code>None</code>, this will be used to select edges to trust for safety (i.e. they are guaranteed to appear in any optimal solution).  Edges whose weight (<code>flow_attr</code>) is greater than or equal to the percentile value will be trusted for safety. Default is <code>None</code>. This is ignored if <code>trusted_edges_for_safety</code> is set.</p> </li> </ul>"},{"location":"k-least-absolute-errors-cycles.html#flowpaths.kleastabserrorscycles.kLeastAbsErrorsCycles--raises","title":"Raises","text":"<ul> <li> <p><code>ValueError</code></p> <ul> <li>If <code>weight_type</code> is not <code>int</code> or <code>float</code>.</li> <li>If the edge error scaling factor is not in [0,1].</li> <li>If the flow attribute <code>flow_attr</code> is not specified in some edge.</li> <li>If the graph contains edges with negative flow values.</li> <li>ValueError: If <code>flow_attr_origin</code> is not \u201cnode\u201d or \u201cedge\u201d.</li> </ul> </li> </ul> Source code in <code>flowpaths/kleastabserrorscycles.py</code> <pre><code>def __init__(\n    self,\n    G: nx.DiGraph,\n    flow_attr: str,\n    k: int = None,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1.0,\n    elements_to_ignore: list = [],\n    error_scaling: dict = {},\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = None,\n    solver_options: dict = {},\n    trusted_edges_for_safety: list = None,\n    trusted_edges_for_safety_percentile: float = None,\n):\n    \"\"\"\n    This class implements the k-LeastAbsoluteErrors problem, namely it looks for a decomposition of a weighted general directed graph, possibly with cycles, into \n    $k$ weighted walks, minimizing the absolute errors on the edges. The error on an edge \n    is defined as the absolute value of the difference between the weight of the edge and the sum of the weights of \n    the walks that go through it.\n\n    Parameters\n    ----------\n    - `G: nx.DiGraph`\n\n        The input directed graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html), which can have cycles.\n\n    - `flow_attr: str`\n\n        The attribute name from where to get the flow values on the edges.\n\n    - `k: int`\n\n        The number of walks to decompose in.\n\n        !!! note \"Unknown $k$\"\n            If you do not have a good guess for $k$, you can pass `k=None` and the model will set $k$ to the condensation width of the graph (i.e. the minimum number of $s$-$t$ walks needed to cover all the edges of the graph, except those in `edges_to_ignore`).\n\n    - `flow_attr_origin: str`, optional\n\n        The origin of the flow attribute. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: the flow attribute is assumed to be on the edges of the graph.\n        - `\"node\"`: the flow attribute is assumed to be on the nodes of the graph. See [the documentation](node-expanded-digraph.md) on how node-weighted graphs are handled.\n\n    - `weight_type: int | float`, optional\n\n        The type of the weights and slacks (`int` or `float`). Default is `float`.\n\n     - `subset_constraints: list`, optional\n\n        List of subset constraints. Default is an empty list. \n        Each subset constraint is a list of edges that must be covered by some solution walk, in any order, according \n        to the `subset_constraints_coverage` parameter (see below).\n\n    - `subset_constraints_coverage: float`, optional\n\n        Coverage fraction of the subset constraints that must be covered by some solution walk. \n\n        Defaults to `1.0`, meaning that 100% of the edges (or nodes, if `flow_attr_origin` is `\"node\"`) of \n        the constraint need to be covered by some solution walk). \n        See [subset constraints documentation](subset-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `elements_to_ignore: list`, optional\n\n        List of edges (or nodes, if `flow_attr_origin` is `\"node\"`) to ignore when adding constrains on flow explanation by the weighted walks. \n        Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `error_scaling: dict`, optional\n\n        Dictionary `edge: factor` (or `node: factor`, if `flow_attr_origin` is `\"node\"`)) storing the error scale factor (in [0,1]) of every edge, which scale the allowed difference between edge/node weight and walk weights.\n        Default is an empty dict. If an edge/node has a missing error scale factor, it is assumed to be 1. The factors are used to scale the \n        difference between the flow value of the edge/node and the sum of the weights of the walks going through the edge/node. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `additional_starts: list`, optional\n\n        List of additional start nodes of the walks. Default is an empty list.\n\n    - `additional_ends: list`, optional\n\n        List of additional end nodes of the walks. Default is an empty list.\n\n    - `optimization_options: dict`, optional\n\n        Dictionary with the optimization options. Default is `None`. See [optimization options documentation](solver-options-optimizations.md).\n\n    - `solver_options: dict`, optional\n\n        Dictionary with the solver options. Default is `{}`. See [solver options documentation](solver-options-optimizations.md).\n\n    - `trusted_edges_for_safety: list`, optional\n\n        List of edges that are trusted to appear in an optimal solution. Default is `None`. \n        If set, the model can apply the safety optimizations for these edges, so it can be significantly faster.\n        See [optimizations documentation](solver-options-optimizations.md#2-optimizations)\n\n    - `trusted_edges_for_safety_percentile: float`, optional\n\n        If set to a value different than `None`, this will be used to select edges to trust for safety (i.e. they are guaranteed to appear in any optimal solution). \n        Edges whose weight (`flow_attr`) is greater than or equal to the percentile value will be trusted for safety. Default is `None`. This is ignored if `trusted_edges_for_safety` is set.\n\n    Raises\n    ------\n    - `ValueError`\n\n        - If `weight_type` is not `int` or `float`.\n        - If the edge error scaling factor is not in [0,1].\n        - If the flow attribute `flow_attr` is not specified in some edge.\n        - If the graph contains edges with negative flow values.\n        - ValueError: If `flow_attr_origin` is not \"node\" or \"edge\".\n    \"\"\"\n\n    # Handling node-weighted graphs\n    self.flow_attr_origin = flow_attr_origin\n    if self.flow_attr_origin == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n        self.G_internal = nedg.NodeExpandedDiGraph(G, node_flow_attr=flow_attr)\n        subset_constraints_internal = self.G_internal.get_expanded_subpath_constraints(subset_constraints)\n        additional_starts_internal = self.G_internal.get_expanded_additional_starts(additional_starts)\n        additional_ends_internal = self.G_internal.get_expanded_additional_ends(additional_ends)\n\n        if not all(isinstance(element_to_ignore, str) for element_to_ignore in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n        edges_to_ignore_internal = list(set(edges_to_ignore_internal))\n        trusted_edges_for_safety_internal = [self.G_internal.get_expanded_edge(edge) for edge in trusted_edges_for_safety] if trusted_edges_for_safety else []\n\n        error_scaling_internal = {self.G_internal.get_expanded_edge(node): error_scaling[node] for node in error_scaling}\n\n    elif self.flow_attr_origin == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n        self.G_internal = G\n        subset_constraints_internal = subset_constraints\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n        additional_starts_internal = additional_starts\n        additional_ends_internal = additional_ends\n        trusted_edges_for_safety_internal = trusted_edges_for_safety or []\n        error_scaling_internal = error_scaling\n    else:\n        utils.logger.error(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n        raise ValueError(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n\n    self.G = stdigraph.stDiGraph(self.G_internal, additional_starts=additional_starts_internal, additional_ends=additional_ends_internal)\n    self.subset_constraints = subset_constraints_internal\n    self.edges_to_ignore = self.G.source_sink_edges.union(edges_to_ignore_internal)\n    self.trusted_edges_for_safety = set(trusted_edges_for_safety_internal)\n\n    if len(self.trusted_edges_for_safety) == 0 and trusted_edges_for_safety_percentile is not None:            \n        # Select edges where the flow_attr value is &gt;= trusted_edges_for_safety_percentile (using self.G)\n        flow_values = [self.G.edges[edge][flow_attr] for edge in self.G.edges() if flow_attr in self.G.edges[edge]]\n        percentile = np.percentile(flow_values, trusted_edges_for_safety_percentile) if flow_values else 0\n        self.trusted_edges_for_safety = set(edge for edge in self.G.edges() if flow_attr in self.G.edges[edge] and self.G.edges[edge][flow_attr] &gt;= percentile)\n        utils.logger.info(f\"{__name__}: trusted_edges_for_safety set using using percentile {trusted_edges_for_safety_percentile} = {percentile} to {self.trusted_edges_for_safety}\")\n\n    self.edge_error_scaling = error_scaling_internal\n    # If the error scaling factor is 0, we ignore the edge\n    self.edges_to_ignore |= {edge for edge, factor in self.edge_error_scaling.items() if factor == 0}\n\n    # Remove from trusted_edges_for_safety the edges in edges_to_ignore\n    self.trusted_edges_for_safety -= self.edges_to_ignore\n\n    # Checking that every entry in self.error_scaling is between 0 and 1\n    for key, value in error_scaling.items():\n        if value &lt; 0 or value &gt; 1:\n            utils.logger.error(f\"{__name__}: Error scaling factor for {key} must be between 0 and 1.\")\n            raise ValueError(f\"Error scaling factor for {key} must be between 0 and 1.\")\n\n    if weight_type not in [int, float]:\n        utils.logger.error(f\"{__name__}: weight_type must be either int or float, not {weight_type}\")\n        raise ValueError(f\"weight_type must be either int or float, not {weight_type}\")\n    self.weight_type = weight_type\n\n    self.k = k\n    # If k is not specified, we set k to the edge width of the graph\n    if self.k is None:\n        self.k = self.G.get_width(list(self.edges_to_ignore))\n    self.optimization_options = optimization_options or {}        \n\n    self.subset_constraints_coverage = subset_constraints_coverage\n\n    self.flow_attr = flow_attr\n    self.w_max = self.k * self.weight_type(\n        self.G.get_max_flow_value_and_check_non_negative_flow(\n            flow_attr=self.flow_attr, edges_to_ignore=self.edges_to_ignore\n        )\n    )\n\n    self.pi_vars = {}\n    self.path_weights_vars = {}\n    self.edge_errors_vars = {}\n\n    self.path_weights_sol = None\n    self.edge_errors_sol = None\n    self._solution = None\n    self._lowerbound_k = None\n\n    self.solve_statistics = {}\n    self.solve_time_start = time.perf_counter()\n\n    # If we get subset constraints, and the coverage fraction is 1\n    # then we know their edges must appear in the solution, so we add their edges to the trusted edges for safety\n    self.optimization_options[\"trusted_edges_for_safety\"] = self.trusted_edges_for_safety or set()\n    if self.subset_constraints is not None:\n        if self.subset_constraints_coverage == 1.0:\n            for constraint in self.subset_constraints:\n                self.optimization_options[\"trusted_edges_for_safety\"].update(constraint)\n\n    # Call the constructor of the parent class AbstractWalkModelDiGraph\n    super().__init__(\n        G=self.G,\n        k=self.k,\n        # max_edge_repetition=self.w_max,\n        max_edge_repetition_dict=self.G.compute_edge_max_reachable_value(flow_attr=self.flow_attr),\n        subset_constraints=self.subset_constraints,\n        subset_constraints_coverage=self.subset_constraints_coverage,\n        optimization_options=self.optimization_options,\n        solver_options=solver_options,\n        solve_statistics=self.solve_statistics\n    )\n\n    # This method is called from the super class AbstractWalkModelDiGraph\n    self.create_solver_and_walks()\n\n    # This method is called from the current class \n    self._encode_leastabserrors_decomposition()\n\n    # This method is called from the current class to add the objective function\n    self._encode_objective()\n\n    utils.logger.info(f\"{__name__}: initialized with graph id = {utils.fpid(G)}, k = {self.k}\")\n</code></pre>"},{"location":"k-least-absolute-errors-cycles.html#flowpaths.kleastabserrorscycles.kLeastAbsErrorsCycles.get_solution","title":"get_solution","text":"<pre><code>get_solution(\n    remove_empty_walks=True,\n)\n</code></pre> <p>Retrieves the solution for the flow decomposition problem.</p> <p>If the solution has already been computed and cached as <code>self.solution</code>, it returns the cached solution. Otherwise, it checks if the problem has been solved, computes the solution walks, weights, slacks and caches the solution.</p>"},{"location":"k-least-absolute-errors-cycles.html#flowpaths.kleastabserrorscycles.kLeastAbsErrorsCycles.get_solution--returns","title":"Returns","text":"<ul> <li> <p><code>solution: dict</code></p> <p>A dictionary containing the solution walks (key <code>\"walks\"</code>) and their corresponding weights (key <code>\"weights\"</code>), and the edge errors (key <code>\"edge_errors\"</code>).</p> </li> </ul>"},{"location":"k-least-absolute-errors-cycles.html#flowpaths.kleastabserrorscycles.kLeastAbsErrorsCycles.get_solution--raises","title":"Raises","text":"<ul> <li><code>exception</code> If model is not solved.</li> </ul> Source code in <code>flowpaths/kleastabserrorscycles.py</code> <pre><code>def get_solution(self, remove_empty_walks=True):\n    \"\"\"\n    Retrieves the solution for the flow decomposition problem.\n\n    If the solution has already been computed and cached as `self.solution`, it returns the cached solution.\n    Otherwise, it checks if the problem has been solved, computes the solution walks, weights, slacks\n    and caches the solution.\n\n\n    Returns\n    -------\n    - `solution: dict`\n\n        A dictionary containing the solution walks (key `\"walks\"`) and their corresponding weights (key `\"weights\"`), and the edge errors (key `\"edge_errors\"`).\n\n    Raises\n    -------\n    - `exception` If model is not solved.\n    \"\"\"\n\n    if self._solution is not None:\n        return self._remove_empty_walks(self._solution) if remove_empty_walks else self._solution\n\n    self.check_is_solved()\n\n    weights_sol_dict = self.solver.get_values(self.path_weights_vars)\n\n    utils.logger.debug(f\"{__name__}: weights_sol_dict = {weights_sol_dict}\")\n\n    self.path_weights_sol = [\n        (\n            round(weights_sol_dict[i])\n            if self.weight_type == int\n            else float(weights_sol_dict[i])\n        )\n        for i in range(self.k)\n    ]\n    self.edge_errors_sol = self.solver.get_values(self.edge_errors_vars)\n    for (u,v) in self.edge_indexes_basic:\n        self.edge_errors_sol[(u,v)] = round(self.edge_errors_sol[(u,v)]) if self.weight_type == int else float(self.edge_errors_sol[(u,v)])\n\n    if self.flow_attr_origin == \"edge\":\n        self._solution = {\n            \"walks\": self.get_solution_walks(),\n            \"weights\": self.path_weights_sol,\n            \"edge_errors\": self.edge_errors_sol # This is a dictionary with keys (u,v) and values the error on the edge (u,v)\n        }\n    elif self.flow_attr_origin == \"node\":\n        self._solution = {\n            \"_walks_internal\": self.get_solution_walks(),\n            \"walks\": self.G_internal.get_condensed_paths(self.get_solution_walks()),\n            \"weights\": self.path_weights_sol,\n            \"edge_errors\": self.edge_errors_sol # This is a dictionary with keys (u,v) and values the error on the edge (u,v)\n        }\n\n    return self._remove_empty_walks(self._solution) if remove_empty_walks else self._solution\n</code></pre>"},{"location":"k-least-absolute-errors-cycles.html#flowpaths.kleastabserrorscycles.kLeastAbsErrorsCycles.is_valid_solution","title":"is_valid_solution","text":"<pre><code>is_valid_solution(\n    tolerance=0.001,\n)\n</code></pre> <p>Checks if the solution is valid by comparing the flow from walks with the flow attribute in the graph edges.</p>"},{"location":"k-least-absolute-errors-cycles.html#flowpaths.kleastabserrorscycles.kLeastAbsErrorsCycles.is_valid_solution--raises","title":"Raises","text":"<ul> <li>ValueError: If the solution is not available (i.e., self.solution is None).</li> </ul>"},{"location":"k-least-absolute-errors-cycles.html#flowpaths.kleastabserrorscycles.kLeastAbsErrorsCycles.is_valid_solution--returns","title":"Returns","text":"<ul> <li>bool: True if the solution is valid, False otherwise.</li> </ul>"},{"location":"k-least-absolute-errors-cycles.html#flowpaths.kleastabserrorscycles.kLeastAbsErrorsCycles.is_valid_solution--notes","title":"Notes","text":"<ul> <li><code>get_solution()</code> must be called before this method.</li> <li>The solution is considered valid if the flow from walks is equal     (up to <code>TOLERANCE * num_edge_walks_on_edges[(u, v)]</code>) to the flow value of the graph edges.</li> </ul> Source code in <code>flowpaths/kleastabserrorscycles.py</code> <pre><code>def is_valid_solution(self, tolerance=0.001):\n    \"\"\"\n    Checks if the solution is valid by comparing the flow from walks with the flow attribute in the graph edges.\n\n    Raises\n    ------\n    - ValueError: If the solution is not available (i.e., self.solution is None).\n\n    Returns\n    -------\n    - bool: True if the solution is valid, False otherwise.\n\n    Notes\n    -------\n    - `get_solution()` must be called before this method.\n    - The solution is considered valid if the flow from walks is equal\n        (up to `TOLERANCE * num_edge_walks_on_edges[(u, v)]`) to the flow value of the graph edges.\n    \"\"\"\n\n    if self._solution is None:\n        self.get_solution()\n\n    solution_walks = self._solution.get(\"_walks_internal\", self._solution[\"walks\"])\n    solution_weights = self._solution[\"weights\"]\n    solution_errors = self._solution[\"edge_errors\"]\n    solution_walks_of_edges = [\n        [(walk[i], walk[i + 1]) for i in range(len(walk) - 1)]\n        for walk in solution_walks\n    ]\n\n    weight_from_walks = {(u, v): 0 for (u, v) in self.G.edges()}\n    num_edge_walks_on_edges = {e: 0 for e in self.G.edges()}\n    for weight, walk in zip(solution_weights, solution_walks_of_edges):\n        for e in walk:\n            weight_from_walks[e] += weight\n            num_edge_walks_on_edges[e] += 1\n\n    for u, v, data in self.G.edges(data=True):\n        if self.flow_attr in data and (u,v) not in self.edges_to_ignore:\n            if (\n                abs(data[self.flow_attr] - weight_from_walks[(u, v)])\n                &gt; tolerance * max(1,num_edge_walks_on_edges[(u, v)]) + solution_errors[(u, v)]\n            ):\n                utils.logger.debug(\n                    f\"{__name__}: Invalid solution for edge ({u}, {v}): \"\n                    f\"flow value {data[self.flow_attr]} != weight from walks {weight_from_walks[(u, v)]} \"\n                    f\"+ error {solution_errors[(u, v)]} (tolerance: {tolerance * max(1,num_edge_walks_on_edges[(u, v)])})\"\n                )\n                return False\n\n    if abs(self.get_objective_value() - self.solver.get_objective_value()) &gt; tolerance * self.k:\n        utils.logger.debug(\n            f\"{__name__}: Invalid solution: objective value {self.get_objective_value()} != solver objective value {self.solver.get_objective_value()} (tolerance: {tolerance * self.k})\"\n        )\n        return False\n\n    return True\n</code></pre>"},{"location":"k-least-absolute-errors.html","title":"$k$-Least Absolute Errors","text":"<p>See also</p> <ul> <li>An Optimization Routine for the Number k of Paths</li> <li>Handling graphs with flows / weights on nodes</li> </ul>"},{"location":"k-least-absolute-errors.html#k-least-absolute-errors","title":"k-Least Absolute Errors","text":""},{"location":"k-least-absolute-errors.html#1-definition","title":"1. Definition","text":"<p>The k-Least Absolute Errors problem on a directed acyclic graph (DAG) is defined as follows:</p> <ul> <li> <p>INPUT: </p> <ul> <li>A directed graph \\(G = (V,E)\\), and a weight function on \\(G\\), namely weights \\(f(u,v)\\) for every edge \\((u,v)\\) of \\(G\\). The weights are arbitrary non-negative numbers and do not need to satisfy flow conservation.</li> <li>\\(k \\in \\mathbb{Z}\\)</li> </ul> </li> <li> <p>OUTPUT: A list of \\(k\\) of source-to-sink paths, \\(P_1,\\dots,P_k\\), with a weight \\(w_i\\) associated to each \\(P_i\\), that minimize the objective function: $$ \\sum_{(u,v) \\in E} \\left|f(u,v) - \\sum_{i \\in \\{1,\\dots,k\\} : (u,v) \\in P_i }w_i\\right|. $$</p> </li> </ul> <p>Note</p> <ul> <li>This class support also graphs with flow values on nodes. Set the parameter <code>flow_attr_origin = \"node\"</code>. For details on how these are handled internally, see Handling graphs with flows / weights on nodes.</li> <li>The graph may have more than one source or sink nodes, in which case the solution paths are just required to start in any source node, and end in any sink node.</li> </ul>"},{"location":"k-least-absolute-errors.html#2-generalizations","title":"2. Generalizations","text":"<p>This class implements a more general version, as follows:</p> <ol> <li>This class supports adding subpath constraints, that is, lists of edges that must appear in some solution path. See Subpath constraints for details.</li> <li>The paths can start/end not only in source/sink nodes, but also in given sets of start/end nodes (set parameters <code>additional_starts</code> and <code>additional_ends</code>). See also Additional start/end nodes.</li> <li>The above summation can happen only over a given subset \\(E' \\subseteq E\\) of the edges (set parameter <code>elements_to_ignore</code> to be \\(E \\setminus E'\\)), </li> <li>The error (i.e. the above absolute of the difference) of every edge can contribute differently to the objective function, according to a scale factor \\(\\in [0,1]\\). Set these via a dictionary that you pass to <code>error_scaling</code>, which stores the scale factor \\(\\lambda_{(u,v)} \\in [0,1]\\) of each edge \\((u,v)\\) in the dictionary. Setting \\(\\lambda_{(u,v)} = 0\\) is equivalent to adding the edge \\((u,v)\\) to <code>elements_to_ignore</code>; the latter option is more efficient, as it results in a smaller model.</li> </ol> <p>Generalized objective function</p> <p>Formally, the minimized objective function generalized as in 3. and 4. above is: $$ \\sum_{(u,v) \\in E\u2019} \\lambda_{(u,v)} \\cdot \\left|f(u,v) - \\sum_{i \\in \\{1,\\dots,k\\} : (u,v) \\in P_i }w_i\\right|. $$</p>"},{"location":"k-least-absolute-errors.html#flowpaths.kleastabserrors.kLeastAbsErrors","title":"kLeastAbsErrors","text":"<pre><code>kLeastAbsErrors(\n    G: DiGraph,\n    flow_attr: str,\n    k: int,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1.0,\n    subpath_constraints_coverage_length: float = None,\n    length_attr: str = None,\n    elements_to_ignore: list = [],\n    error_scaling: dict = {},\n    additional_starts: list = [],\n    additional_ends: list = [],\n    solution_weights_superset: list = None,\n    optimization_options: dict = None,\n    solver_options: dict = {},\n    trusted_edges_for_safety: list = None,\n)\n</code></pre> <p>               Bases: <code>AbstractPathModelDAG</code></p> <p>This class implements the k-LeastAbsoluteErrors problem, namely it looks for a decomposition of a weighted DAG into  \\(k\\) weighted paths, minimizing the absolute errors on the edges. The error on an edge  is defined as the absolute value of the difference between the weight of the edge and the sum of the weights of  the paths that go through it.</p>"},{"location":"k-least-absolute-errors.html#flowpaths.kleastabserrors.kLeastAbsErrors--parameters","title":"Parameters","text":"<ul> <li> <p><code>G: nx.DiGraph</code></p> <p>The input directed acyclic graph, as networkx DiGraph.</p> </li> <li> <p><code>flow_attr: str</code></p> <p>The attribute name from where to get the flow values on the edges.</p> </li> <li> <p><code>k: int</code></p> <p>The number of paths to decompose in.</p> </li> <li> <p><code>flow_attr_origin: str</code>, optional</p> <p>The origin of the flow attribute. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: the flow attribute is assumed to be on the edges of the graph.</li> <li><code>\"node\"</code>: the flow attribute is assumed to be on the nodes of the graph. See the documentation on how node-weighted graphs are handled.</li> </ul> </li> <li> <p><code>weight_type: int | float</code>, optional</p> <p>The type of the weights and slacks (<code>int</code> or <code>float</code>). Default is <code>float</code>.</p> </li> <li> <p><code>subpath_constraints: list</code>, optional</p> <p>List of subpath constraints. Default is an empty list.  Each subpath constraint is a list of edges that must be covered by some solution path, according  to the <code>subpath_constraints_coverage</code> or <code>subpath_constraints_coverage_length</code> parameters (see below).</p> </li> <li> <p><code>subpath_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subpath constraints that must be covered by some solution paths. </p> <p>Defaults to <code>1.0</code>, meaning that 100% of the edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) of  the constraint need to be covered by some solution path).  See subpath constraints documentation</p> </li> <li> <p><code>subpath_constraints_coverage_length: float</code>, optional</p> <p>Coverage length of the subpath constraints. Default is <code>None</code>. If set, this overrides <code>subpath_constraints_coverage</code>,  and the coverage constraint is expressed in terms of the subpath constraint length.  <code>subpath_constraints_coverage_length</code> is then the fraction of the total length of the constraint (specified via <code>length_attr</code>) needs to appear in some solution path. See subpath constraints documentation</p> </li> <li> <p><code>length_attr: str</code>, optional</p> <p>The attribute name from where to get the edge lengths (or node length, if <code>flow_attr_origin</code> is <code>\"node\"</code>). Defaults to <code>None</code>.</p> <ul> <li>If set, then the subpath lengths (above) are in terms of the edge/node lengths specified in the <code>length_attr</code> field of each edge/node.</li> <li>If set, and an edge/node has a missing edge length, then it gets length 1.</li> </ul> </li> <li> <p><code>elements_to_ignore: list</code>, optional</p> <p>List of edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) to ignore when adding constrains on flow explanation by the weighted paths.  Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>error_scaling: dict</code>, optional</p> <p>Dictionary <code>edge: factor</code> (or <code>node: factor</code>, if <code>flow_attr_origin</code> is <code>\"node\"</code>)) storing the error scale factor (in [0,1]) of every edge, which scale the allowed difference between edge/node weight and path weights. Default is an empty dict. If an edge/node has a missing error scale factor, it is assumed to be 1. The factors are used to scale the  difference between the flow value of the edge/node and the sum of the weights of the paths going through the edge/node. See ignoring edges documentation</p> </li> <li> <p><code>additional_starts: list</code>, optional</p> <p>List of additional start nodes of the paths. Default is an empty list.</p> </li> <li> <p><code>additional_ends: list</code>, optional</p> <p>List of additional end nodes of the paths. Default is an empty list.</p> </li> <li> <p><code>solution_weights_superset: list</code>, optional</p> <p>List of allowed weights for the paths. Default is <code>None</code>.  If set, the model will use the solution path weights only from this set, with the property that every weight in this list appears at most once in the solution weight. That is, if you want to have more paths with the same weight, add it more times to <code>solution_weights_superset</code>.</p> </li> <li> <p><code>optimization_options: dict</code>, optional</p> <p>Dictionary with the optimization options. Default is <code>None</code>. See optimization options documentation.</p> </li> <li> <p><code>solver_options: dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>{}</code>. See solver options documentation.</p> </li> <li> <p><code>trusted_edges_for_safety: list</code>, optional</p> <p>List of edges that are trusted to appear in an optimal solution. Default is <code>None</code>.  If set, the model can apply the safety optimizations for these edges, so it can be significantly faster. See optimizations documentation</p> </li> </ul>"},{"location":"k-least-absolute-errors.html#flowpaths.kleastabserrors.kLeastAbsErrors--raises","title":"Raises","text":"<ul> <li> <p><code>ValueError</code></p> <ul> <li>If <code>weight_type</code> is not <code>int</code> or <code>float</code>.</li> <li>If the edge error scaling factor is not in [0,1].</li> <li>If the flow attribute <code>flow_attr</code> is not specified in some edge.</li> <li>If the graph contains edges with negative flow values.</li> <li>ValueError: If <code>flow_attr_origin</code> is not \u201cnode\u201d or \u201cedge\u201d.</li> </ul> </li> </ul> Source code in <code>flowpaths/kleastabserrors.py</code> <pre><code>def __init__(\n    self,\n    G: nx.DiGraph,\n    flow_attr: str,\n    k: int,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1.0,\n    subpath_constraints_coverage_length: float = None,\n    length_attr: str = None,\n    elements_to_ignore: list = [],\n    error_scaling: dict = {},\n    additional_starts: list = [],\n    additional_ends: list = [],\n    solution_weights_superset: list = None,\n    optimization_options: dict = None,\n    solver_options: dict = {},\n    trusted_edges_for_safety: list = None,\n):\n    \"\"\"\n    This class implements the k-LeastAbsoluteErrors problem, namely it looks for a decomposition of a weighted DAG into \n    $k$ weighted paths, minimizing the absolute errors on the edges. The error on an edge \n    is defined as the absolute value of the difference between the weight of the edge and the sum of the weights of \n    the paths that go through it.\n\n    Parameters\n    ----------\n    - `G: nx.DiGraph`\n\n        The input directed acyclic graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html).\n\n    - `flow_attr: str`\n\n        The attribute name from where to get the flow values on the edges.\n\n    - `k: int`\n\n        The number of paths to decompose in.\n\n    - `flow_attr_origin: str`, optional\n\n        The origin of the flow attribute. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: the flow attribute is assumed to be on the edges of the graph.\n        - `\"node\"`: the flow attribute is assumed to be on the nodes of the graph. See [the documentation](node-expanded-digraph.md) on how node-weighted graphs are handled.\n\n    - `weight_type: int | float`, optional\n\n        The type of the weights and slacks (`int` or `float`). Default is `float`.\n\n     - `subpath_constraints: list`, optional\n\n        List of subpath constraints. Default is an empty list. \n        Each subpath constraint is a list of edges that must be covered by some solution path, according \n        to the `subpath_constraints_coverage` or `subpath_constraints_coverage_length` parameters (see below).\n\n    - `subpath_constraints_coverage: float`, optional\n\n        Coverage fraction of the subpath constraints that must be covered by some solution paths. \n\n        Defaults to `1.0`, meaning that 100% of the edges (or nodes, if `flow_attr_origin` is `\"node\"`) of \n        the constraint need to be covered by some solution path). \n        See [subpath constraints documentation](subpath-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `subpath_constraints_coverage_length: float`, optional\n\n        Coverage length of the subpath constraints. Default is `None`. If set, this overrides `subpath_constraints_coverage`, \n        and the coverage constraint is expressed in terms of the subpath constraint length. \n        `subpath_constraints_coverage_length` is then the fraction of the total length of the constraint (specified via `length_attr`) needs to appear in some solution path.\n        See [subpath constraints documentation](subpath-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `length_attr: str`, optional\n\n        The attribute name from where to get the edge lengths (or node length, if `flow_attr_origin` is `\"node\"`). Defaults to `None`.\n\n        - If set, then the subpath lengths (above) are in terms of the edge/node lengths specified in the `length_attr` field of each edge/node.\n        - If set, and an edge/node has a missing edge length, then it gets length 1.\n\n    - `elements_to_ignore: list`, optional\n\n        List of edges (or nodes, if `flow_attr_origin` is `\"node\"`) to ignore when adding constrains on flow explanation by the weighted paths. \n        Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `error_scaling: dict`, optional\n\n        Dictionary `edge: factor` (or `node: factor`, if `flow_attr_origin` is `\"node\"`)) storing the error scale factor (in [0,1]) of every edge, which scale the allowed difference between edge/node weight and path weights.\n        Default is an empty dict. If an edge/node has a missing error scale factor, it is assumed to be 1. The factors are used to scale the \n        difference between the flow value of the edge/node and the sum of the weights of the paths going through the edge/node. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `additional_starts: list`, optional\n\n        List of additional start nodes of the paths. Default is an empty list.\n\n    - `additional_ends: list`, optional\n\n        List of additional end nodes of the paths. Default is an empty list.\n\n    - `solution_weights_superset: list`, optional\n\n        List of allowed weights for the paths. Default is `None`. \n        If set, the model will use the solution path weights only from this set, with the property that **every weight in this list\n        appears at most once in the solution weight**. That is, if you want to have more paths with the same weight, add it more times to `solution_weights_superset`.\n\n    - `optimization_options: dict`, optional\n\n        Dictionary with the optimization options. Default is `None`. See [optimization options documentation](solver-options-optimizations.md).\n\n    - `solver_options: dict`, optional\n\n        Dictionary with the solver options. Default is `{}`. See [solver options documentation](solver-options-optimizations.md).\n\n    - `trusted_edges_for_safety: list`, optional\n\n        List of edges that are trusted to appear in an optimal solution. Default is `None`. \n        If set, the model can apply the safety optimizations for these edges, so it can be significantly faster.\n        See [optimizations documentation](solver-options-optimizations.md#2-optimizations)\n\n    Raises\n    ------\n    - `ValueError`\n\n        - If `weight_type` is not `int` or `float`.\n        - If the edge error scaling factor is not in [0,1].\n        - If the flow attribute `flow_attr` is not specified in some edge.\n        - If the graph contains edges with negative flow values.\n        - ValueError: If `flow_attr_origin` is not \"node\" or \"edge\".\n    \"\"\"\n\n    utils.logger.info(f\"{__name__}: START initialized with graph id = {utils.fpid(G)}, k = {k}\")\n\n    # Handling node-weighted graphs\n    self.flow_attr_origin = flow_attr_origin\n    if self.flow_attr_origin == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n        self.G_internal = nedg.NodeExpandedDiGraph(G, node_flow_attr=flow_attr, node_length_attr=length_attr)\n        subpath_constraints_internal = self.G_internal.get_expanded_subpath_constraints(subpath_constraints)\n        additional_starts_internal = self.G_internal.get_expanded_additional_starts(additional_starts)\n        additional_ends_internal = self.G_internal.get_expanded_additional_ends(additional_ends)\n\n        if not all(isinstance(element_to_ignore, str) for element_to_ignore in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n        edges_to_ignore_internal = list(set(edges_to_ignore_internal))\n        trusted_edges_for_safety_internal = [self.G_internal.get_expanded_edge(edge) for edge in trusted_edges_for_safety] if trusted_edges_for_safety else []\n\n        error_scaling_internal = {self.G_internal.get_expanded_edge(node): error_scaling[node] for node in error_scaling}\n\n    elif self.flow_attr_origin == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n        self.G_internal = G\n        subpath_constraints_internal = subpath_constraints\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n        additional_starts_internal = additional_starts\n        additional_ends_internal = additional_ends\n        trusted_edges_for_safety_internal = trusted_edges_for_safety or []\n        error_scaling_internal = error_scaling\n    else:\n        utils.logger.error(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n        raise ValueError(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n\n    self.G = stdag.stDAG(self.G_internal, additional_starts=additional_starts_internal, additional_ends=additional_ends_internal)\n    self.subpath_constraints = subpath_constraints_internal\n    self.edges_to_ignore = self.G.source_sink_edges.union(edges_to_ignore_internal)\n    self.trusted_edges_for_safety = trusted_edges_for_safety_internal\n    self.edge_error_scaling = error_scaling_internal\n    # If the error scaling factor is 0, we ignore the edge\n    self.edges_to_ignore |= {edge for edge, factor in self.edge_error_scaling.items() if factor == 0}\n\n    # Checking that every entry in self.error_scaling is between 0 and 1\n    for key, value in error_scaling.items():\n        if value &lt; 0 or value &gt; 1:\n            utils.logger.error(f\"{__name__}: Error scaling factor for {key} must be between 0 and 1.\")\n            raise ValueError(f\"Error scaling factor for {key} must be between 0 and 1.\")\n\n\n    if weight_type not in [int, float]:\n        utils.logger.error(f\"{__name__}: weight_type must be either int or float, not {weight_type}\")\n        raise ValueError(f\"weight_type must be either int or float, not {weight_type}\")\n    self.weight_type = weight_type\n\n\n    self.k = k\n    self.original_k = k\n    self.solution_weights_superset = solution_weights_superset\n    self.optimization_options = optimization_options or {}        \n\n    self.subpath_constraints_coverage = subpath_constraints_coverage\n    self.subpath_constraints_coverage_length = subpath_constraints_coverage_length\n    self.length_attr = length_attr\n\n    if self.solution_weights_superset is not None:\n        self.k = len(self.solution_weights_superset)\n        self.optimization_options[\"allow_empty_paths\"] = True\n        self.optimization_options[\"optimize_with_safe_paths\"] = False\n        self.optimization_options[\"optimize_with_safe_sequences\"] = False\n        self.optimization_options[\"optimize_with_safe_zero_edges\"] = False\n        if len(self.subpath_constraints) &gt; 0:\n            self.optimization_options[\"optimize_with_subpath_constraints_as_safe_sequences\"] = True\n            self.optimization_options[\"optimize_with_safety_as_subpath_constraints\"] = True\n\n    self.flow_attr = flow_attr\n    self.w_max = self.k * self.weight_type(\n        self.G.get_max_flow_value_and_check_non_negative_flow(\n            flow_attr=self.flow_attr, edges_to_ignore=self.edges_to_ignore\n        )\n    )\n    self.w_max = max(self.w_max, max(self.solution_weights_superset or [0]))\n\n    self.pi_vars = {}\n    self.path_weights_vars = {}\n    self.edge_errors_vars = {}\n\n    self.path_weights_sol = None\n    self.edge_errors_sol = None\n    self._solution = None\n    self._lowerbound_k = None\n\n    self.solve_statistics = {}\n\n    # If we get subpath constraints, and the coverage fraction is 1\n    # then we know their edges must appear in the solution, so we add their edges to the trusted edges for safety\n    self.optimization_options[\"trusted_edges_for_safety\"] = set(self.trusted_edges_for_safety or [])\n    if self.subpath_constraints is not None:\n        if (self.subpath_constraints_coverage == 1.0 and self.subpath_constraints_coverage_length is None) \\\n            or self.subpath_constraints_coverage_length == 1:\n            for constraint in self.subpath_constraints:\n                self.optimization_options[\"trusted_edges_for_safety\"].update(constraint)\n\n    # Call the constructor of the parent class AbstractPathModelDAG\n    super().__init__(\n        self.G, \n        self.k,\n        subpath_constraints=self.subpath_constraints, \n        subpath_constraints_coverage=self.subpath_constraints_coverage, \n        subpath_constraints_coverage_length=self.subpath_constraints_coverage_length,\n        length_attr=self.length_attr,\n        optimization_options=self.optimization_options,\n        solver_options=solver_options,\n        solve_statistics=self.solve_statistics\n    )\n\n    # This method is called from the super class AbstractPathModelDAG\n    self.create_solver_and_paths()\n\n    # This method is called from the current class \n    if self.solution_weights_superset is not None:\n        self._encode_leastabserrors_decomposition_with_given_weights()\n    else:\n        self._encode_leastabserrors_decomposition()\n\n    # This method is called from the current class to add the objective function\n    self._encode_objective()\n\n    utils.logger.info(f\"{__name__}: END initialized with graph id = {utils.fpid(G)}, k = {self.k}\")\n</code></pre>"},{"location":"k-least-absolute-errors.html#flowpaths.kleastabserrors.kLeastAbsErrors.get_solution","title":"get_solution","text":"<pre><code>get_solution(\n    remove_empty_paths=True,\n)\n</code></pre> <p>Retrieves the solution for the flow decomposition problem.</p> <p>If the solution has already been computed and cached as <code>self.solution</code>, it returns the cached solution. Otherwise, it checks if the problem has been solved, computes the solution paths, weights, slacks and caches the solution.</p>"},{"location":"k-least-absolute-errors.html#flowpaths.kleastabserrors.kLeastAbsErrors.get_solution--returns","title":"Returns","text":"<ul> <li> <p><code>solution: dict</code></p> <p>A dictionary containing the solution paths (key <code>\"paths\"</code>) and their corresponding weights (key <code>\"weights\"</code>), and the edge errors (key <code>\"edge_errors\"</code>).</p> </li> </ul>"},{"location":"k-least-absolute-errors.html#flowpaths.kleastabserrors.kLeastAbsErrors.get_solution--raises","title":"Raises","text":"<ul> <li><code>exception</code> If model is not solved.</li> </ul> Source code in <code>flowpaths/kleastabserrors.py</code> <pre><code>def get_solution(self, remove_empty_paths=True):\n    \"\"\"\n    Retrieves the solution for the flow decomposition problem.\n\n    If the solution has already been computed and cached as `self.solution`, it returns the cached solution.\n    Otherwise, it checks if the problem has been solved, computes the solution paths, weights, slacks\n    and caches the solution.\n\n\n    Returns\n    -------\n    - `solution: dict`\n\n        A dictionary containing the solution paths (key `\"paths\"`) and their corresponding weights (key `\"weights\"`), and the edge errors (key `\"edge_errors\"`).\n\n    Raises\n    -------\n    - `exception` If model is not solved.\n    \"\"\"\n\n    if self._solution is not None:\n        return self._remove_empty_paths(self._solution) if remove_empty_paths else self._solution\n\n    self.check_is_solved()\n\n    if self.solution_weights_superset is None:\n        weights_sol_dict = self.solver.get_values(self.path_weights_vars)\n    else:\n        weights_sol_dict = {i: self.solution_weights_superset[i] for i in range(self.k)}\n\n    self.path_weights_sol = [\n        (\n            round(weights_sol_dict[i])\n            if self.weight_type == int\n            else float(weights_sol_dict[i])\n        )\n        for i in range(self.k)\n    ]\n    self.edge_errors_sol = self.solver.get_values(self.edge_errors_vars)\n    for (u,v) in self.edge_indexes_basic:\n        self.edge_errors_sol[(u,v)] = round(self.edge_errors_sol[(u,v)]) if self.weight_type == int else float(self.edge_errors_sol[(u,v)])\n\n    if self.flow_attr_origin == \"edge\":\n        self._solution = {\n            \"paths\": self.get_solution_paths(),\n            \"weights\": self.path_weights_sol,\n            \"edge_errors\": self.edge_errors_sol # This is a dictionary with keys (u,v) and values the error on the edge (u,v)\n        }\n    elif self.flow_attr_origin == \"node\":\n        self._solution = {\n            \"_paths_internal\": self.get_solution_paths(),\n            \"paths\": self.G_internal.get_condensed_paths(self.get_solution_paths()),\n            \"weights\": self.path_weights_sol,\n            \"edge_errors\": self.edge_errors_sol # This is a dictionary with keys (u,v) and values the error on the edge (u,v)\n        }\n\n    return self._remove_empty_paths(self._solution) if remove_empty_paths else self._solution\n</code></pre>"},{"location":"k-least-absolute-errors.html#flowpaths.kleastabserrors.kLeastAbsErrors.is_valid_solution","title":"is_valid_solution","text":"<pre><code>is_valid_solution(\n    tolerance=0.001,\n)\n</code></pre> <p>Checks if the solution is valid by comparing the flow from paths with the flow attribute in the graph edges.</p>"},{"location":"k-least-absolute-errors.html#flowpaths.kleastabserrors.kLeastAbsErrors.is_valid_solution--raises","title":"Raises","text":"<ul> <li>ValueError: If the solution is not available (i.e., self.solution is None).</li> </ul>"},{"location":"k-least-absolute-errors.html#flowpaths.kleastabserrors.kLeastAbsErrors.is_valid_solution--returns","title":"Returns","text":"<ul> <li>bool: True if the solution is valid, False otherwise.</li> </ul>"},{"location":"k-least-absolute-errors.html#flowpaths.kleastabserrors.kLeastAbsErrors.is_valid_solution--notes","title":"Notes","text":"<ul> <li><code>get_solution()</code> must be called before this method.</li> <li>The solution is considered valid if the flow from paths is equal     (up to <code>TOLERANCE * num_paths_on_edges[(u, v)]</code>) to the flow value of the graph edges.</li> </ul> Source code in <code>flowpaths/kleastabserrors.py</code> <pre><code>def is_valid_solution(self, tolerance=0.001):\n    \"\"\"\n    Checks if the solution is valid by comparing the flow from paths with the flow attribute in the graph edges.\n\n    Raises\n    ------\n    - ValueError: If the solution is not available (i.e., self.solution is None).\n\n    Returns\n    -------\n    - bool: True if the solution is valid, False otherwise.\n\n    Notes\n    -------\n    - `get_solution()` must be called before this method.\n    - The solution is considered valid if the flow from paths is equal\n        (up to `TOLERANCE * num_paths_on_edges[(u, v)]`) to the flow value of the graph edges.\n    \"\"\"\n\n    if self._solution is None:\n        self.get_solution()\n\n    solution_paths = self._solution.get(\"_paths_internal\", self._solution[\"paths\"])\n    solution_weights = self._solution[\"weights\"]\n    solution_errors = self._solution[\"edge_errors\"]\n    solution_paths_of_edges = [\n        [(path[i], path[i + 1]) for i in range(len(path) - 1)]\n        for path in solution_paths\n    ]\n\n    weight_from_paths = {(u, v): 0 for (u, v) in self.G.edges()}\n    num_paths_on_edges = {e: 0 for e in self.G.edges()}\n    for weight, path in zip(solution_weights, solution_paths_of_edges):\n        for e in path:\n            weight_from_paths[e] += weight\n            num_paths_on_edges[e] += 1\n\n    for u, v, data in self.G.edges(data=True):\n        if self.flow_attr in data and (u,v) not in self.edges_to_ignore:\n            if (\n                abs(data[self.flow_attr] - weight_from_paths[(u, v)])\n                &gt; tolerance * max(1,num_paths_on_edges[(u, v)]) + solution_errors[(u, v)]\n            ):\n                utils.logger.debug(\n                    f\"{__name__}: Invalid solution for edge ({u}, {v}): \"\n                    f\"flow value {data[self.flow_attr]} != weight from paths {weight_from_paths[(u, v)]} \"\n                    f\"+ error {solution_errors[(u, v)]} (tolerance: {tolerance * max(1,num_paths_on_edges[(u, v)])})\"\n                )\n                return False\n\n    if abs(self.get_objective_value() - self.solver.get_objective_value()) &gt; tolerance * self.original_k:\n        utils.logger.debug(\n            f\"{__name__}: Invalid solution: objective value {self.get_objective_value()} != solver objective value {self.solver.get_objective_value()} (tolerance: {tolerance * self.original_k})\"\n        )\n        return False\n\n    return True\n</code></pre>"},{"location":"k-min-path-error-cycles.html","title":"k-Minimum Path Error in General Graphs","text":"<p>See also</p> <ul> <li>k-Minimum Path Error in DAGs</li> <li>An Optimization Routine for the Number k of Paths</li> <li>Handling graphs with flows / weights on nodes</li> </ul> <p>The k-Minimum Path Error problem tries to model cases where the weight along a walk is not constant. As such, edges that appear in more solution walks will be allowed to have a higher error (i.e. difference between their input weight/flow value and the sum of the weights of the walks that use them). More formally, walks now receive also a slack, which intuitively models how much the weight along a walk can vary. Ideally, we can decompose the weighted graphs with \\(k\\) walks that overall have small slack values.</p>"},{"location":"k-min-path-error-cycles.html#1-definition","title":"1. Definition","text":"<p>The k-Minimum Path Error problem on a directed graphs, possibly with cycles, is defined as follows. For a walk \\(W\\) and an edge \\((u,v)\\), we denote by \\(W(u,v)\\) the number of times that the walk goes through the edge \\((u,v)\\). If \\(W(u,v)\\) does not contain \\((u,v)\\) , then \\(W(u,v) = 0\\).</p> <ul> <li> <p>INPUT: </p> <ul> <li>A directed graph \\(G = (V,E)\\).</li> <li>Node subsets \\(S \\subseteq V\\) and \\(T \\subseteq V\\), where the walks are allowed to start and allowed to end, respectively.</li> <li>A weight function on \\(G\\), namely weights \\(f(u,v)\\) for every edge \\((u,v)\\) of \\(G\\). The weights are arbitrary non-negative numbers and do not need to satisfy flow conservation.</li> <li>\\(k \\in \\mathbb{Z}_+\\).</li> </ul> </li> <li> <p>OUTPUT: A list of \\(k\\) of walks \\(W_1,\\dots,W_k\\), starting in some node in \\(S\\) and ending in some node in \\(T\\), with a weight \\(w_i\\), and a slack \\(\\rho_i\\) associated to each \\(W_i\\), that satisfy the constraint $$ \\left|f(u,v) - \\sum_{i \\in \\{1,\\dots,k\\}} w_i \\cdot W_i(u,v)\\right| \\leq \\sum_{i \\in \\{1,\\dots,k\\}}\\rho_i\\cdot W_i(u,v), ~\\forall (u,v) \\in E, $$ and minimize the objective function $$ \\rho_1 + \\cdots + \\rho_k. $$</p> </li> </ul> <p>Note</p> <ul> <li>This class support also graphs with flow values on nodes. Set the parameter <code>flow_attr_origin = \"node\"</code>. For details on how these are handled internally, see Handling graphs with flows / weights on nodes.</li> <li>The graph may have more than one source or sink nodes, in which case the solution walks are just required to start in any source node, and end in any sink node.</li> </ul>"},{"location":"k-min-path-error-cycles.html#2-generalizations","title":"2. Generalizations","text":"<p>This class implements a more general version, as follows:</p> <ol> <li>The walks can start/end not only in source/sink nodes, but also in given sets of start/end nodes (set parameters <code>additional_starts</code> and <code>additional_ends</code>). See also Additional start/end nodes.</li> <li>This class supports adding subset constraints, that is, lists of edges that must appear in some solution walks. See Subset constraints for details.</li> <li>The above constraint can happen only over a given subset \\(E' \\subseteq E\\) of the edges (set parameter <code>elements_to_ignore</code> to be \\(E \\setminus E'\\)). See also ignoring edges documentation.</li> <li>The error (i.e. the above absolute of the difference) of every edge can contribute differently to the objective function, according to a scale factor \\(\\in [0,1]\\). Set these via a dictionary that you pass to <code>error_scaling</code>, which stores the scale factor \\(\\lambda_{(u,v)} \\in [0,1]\\) of each edge \\((u,v)\\) in the dictionary. Setting \\(\\lambda_{(u,v)} = 0\\) will add the edge \\((u,v)\\) to <code>elements_to_ignore</code>, because the constraint for \\((u,v)\\) becomes always true. See also ignoring edges documentation.</li> </ol> <p>Generalized constraint</p> <p>Formally, the constraint generalized as in 3., 4. and 5. above is: $$ \\lambda_{(u,v)} \\cdot \\left|f(u,v) - \\sum_{i \\in \\{1,\\dots,k\\}}w_i \\cdot W_i(u,v)\\right| \\leq \\sum_{i \\in \\{1,\\dots,k\\}}\\rho_i \\cdot W_i(u,v), ~\\forall (u,v) \\in E\u2019. $$</p> <p>A lowerbound on \\(k\\)</p> <p>The value of \\(k\\) must be at least the edge width of graph, meaning the minimum number of walks to cover all the edges in \\(E'\\), except those edges \\((u,v)\\) for which \\(\\lambda_{u,v} = 0\\). This value always gives a feasible model. </p> <p>If you do not know this lower bound, you can pass <code>k = None</code> and the model will automatically set <code>k</code> to this lowerbound value.</p>"},{"location":"k-min-path-error-cycles.html#3-references","title":"3. References","text":"<ol> <li> <p>Fernando H. C. Dias, Alexandru I. Tomescu Accurate Flow Decomposition via Robust Integer Linear Programming IEEE/ACM Transactions on Computational Biology and Bioinformatics 21(6), 1955-1964, 2024 (preprint)</p> </li> <li> <p>Francisco Sena, Alexandru I. Tomescu Fast and Flexible Flow Decompositions in General Graphs via Dominators, arXiv, 2025</p> </li> </ol>"},{"location":"k-min-path-error-cycles.html#flowpaths.kminpatherrorcycles.kMinPathErrorCycles","title":"kMinPathErrorCycles","text":"<pre><code>kMinPathErrorCycles(\n    G: DiGraph,\n    flow_attr: str,\n    k: int = None,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1.0,\n    elements_to_ignore: list = [],\n    elements_to_ignore_percentile: float = None,\n    error_scaling: dict = {},\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = None,\n    solver_options: dict = {},\n    trusted_edges_for_safety_percentile: float = None,\n)\n</code></pre> <p>               Bases: <code>AbstractWalkModelDiGraph</code></p> <p>This class implements the k-MinPathError problem on general directed graphs. Given an edge-weighted DAG, this model looks for k walks, with associated weights and slacks, such that for every edge (u,v),  the sum of the weights of the walks going through (u,v) minus the flow value of (u,v) is at most  the sum of the slacks of the walks going through (u,v). The objective is to minimize the sum of the slacks.</p>"},{"location":"k-min-path-error-cycles.html#flowpaths.kminpatherrorcycles.kMinPathErrorCycles--parameters","title":"Parameters","text":"<ul> <li> <p><code>G: nx.DiGraph</code></p> <p>The input directed graph, as networkx DiGraph, which can have cycles.</p> </li> <li> <p><code>flow_attr: str</code></p> <p>The attribute name from where to get the flow values on the edges.</p> </li> <li> <p><code>k: int</code></p> <p>The number of walks to decompose in.</p> <p>Unknown \\(k\\)</p> <p>If you do not have a good guess for \\(k\\), you can pass <code>k=None</code> and the model will set \\(k\\) to the condensation width of the graph (i.e. the minimum number of \\(s\\)-\\(t\\) walks needed to cover all the edges of the graph, except those in <code>edges_to_ignore</code>).</p> </li> <li> <p><code>flow_attr_origin: str</code>, optional</p> <p>The origin of the flow attribute. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: the flow attribute is assumed to be on the edges of the graph.</li> <li><code>\"node\"</code>: the flow attribute is assumed to be on the nodes of the graph. See the documentation on how node-weighted graphs are handled.</li> </ul> </li> <li> <p><code>weight_type: int | float</code>, optional</p> <p>The type of the weights and slacks (<code>int</code> or <code>float</code>). Default is <code>float</code>.</p> </li> <li> <p><code>subset_constraints: list</code>, optional</p> <p>List of subset constraints. Default is an empty list.  Each subset constraint is a list of edges that must be covered by some solution walk, in any order, according  to the <code>subset_constraints_coverage</code> parameter (see below).</p> </li> <li> <p><code>subset_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subset constraints that must be covered by some solution walk. </p> <p>Defaults to <code>1.0</code>, meaning that 100% of the edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) of  the constraint need to be covered by some solution walk).  See subset constraints documentation</p> </li> <li> <p><code>elements_to_ignore: list</code>, optional</p> <p>List of edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) to ignore when adding constrains on flow explanation by the weighted walks.  Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>elements_to_ignore_percentile: float</code>, optional</p> <p>If provided, ignores elements automatically based on a percentile threshold of their flow values (<code>flow_attr</code>). Elements (edges, or nodes if <code>flow_attr_origin</code> is <code>\"node\"</code>) whose flow is below this percentile are ignored when enforcing the error constraints. Must be in the range <code>[0, 100]</code>. This is mutually exclusive with <code>elements_to_ignore</code> (setting both raises a <code>ValueError</code>). See ignoring edges documentation.</p> </li> <li> <p><code>error_scaling: dict</code>, optional</p> <p>Dictionary <code>edge: factor</code> (or <code>node: factor</code>, if <code>flow_attr_origin</code> is <code>\"node\"</code>)) storing the error scale factor (in [0,1]) of every edge, which scale the allowed difference between edge/node weight and walk weights. Default is an empty dict. If an edge/node has a missing error scale factor, it is assumed to be 1. The factors are used to scale the  difference between the flow value of the edge/node and the sum of the weights of the walks going through the edge/node. See ignoring edges documentation</p> </li> <li> <p><code>additional_starts: list</code>, optional</p> <p>List of additional start nodes of the walks. Default is an empty list.</p> </li> <li> <p><code>additional_ends: list</code>, optional</p> <p>List of additional end nodes of the walks. Default is an empty list.</p> </li> <li> <p><code>optimization_options: dict</code>, optional</p> <p>Dictionary with the optimization options. Default is <code>None</code>. See optimization options documentation.</p> </li> <li> <p><code>solver_options: dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>{}</code>. See solver options documentation.</p> </li> <li> <p><code>trusted_edges_for_safety_percentile: float</code>, optional</p> <p>If set to a value different than <code>None</code>, this will be used to select edges to trust for safety (i.e. they are guaranteed to appear in any optimal solution).  Edges whose weight (<code>flow_attr</code>) is greater than or equal to the percentile value will be trusted for safety. Default is <code>None</code>. This is ignored if <code>trusted_edges_for_safety</code> is set.</p> </li> </ul>"},{"location":"k-min-path-error-cycles.html#flowpaths.kminpatherrorcycles.kMinPathErrorCycles--raises","title":"Raises","text":"<ul> <li> <p><code>ValueError</code></p> <ul> <li>If <code>weight_type</code> is not <code>int</code> or <code>float</code>.</li> <li>If the edge error scaling factor is not in [0,1].</li> <li>If the flow attribute <code>flow_attr</code> is not specified in some edge.</li> <li>If the graph contains edges with negative flow values.</li> <li>ValueError: If <code>flow_attr_origin</code> is not \u201cnode\u201d or \u201cedge\u201d.</li> <li>If <code>elements_to_ignore_percentile</code> is set and is not in <code>[0, 100]</code>.</li> <li>If <code>elements_to_ignore_percentile</code> is set together with <code>elements_to_ignore</code>.</li> </ul> </li> </ul> Source code in <code>flowpaths/kminpatherrorcycles.py</code> <pre><code>def __init__(\n    self,\n    G: nx.DiGraph,\n    flow_attr: str,\n    k: int = None,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1.0,\n    elements_to_ignore: list = [],\n    elements_to_ignore_percentile: float = None,\n    error_scaling: dict = {},\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = None,\n    solver_options: dict = {},\n    trusted_edges_for_safety_percentile: float = None,\n):\n    \"\"\"\n    This class implements the k-MinPathError problem on general directed graphs. Given an edge-weighted DAG, this model looks for k walks, with associated weights and slacks, such that for every edge (u,v), \n    the sum of the weights of the walks going through (u,v) minus the flow value of (u,v) is at most \n    the sum of the slacks of the walks going through (u,v). The objective is to minimize the sum of the slacks.\n\n    Parameters\n    ----------\n    - `G: nx.DiGraph`\n\n        The input directed graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html), which can have cycles.\n\n    - `flow_attr: str`\n\n        The attribute name from where to get the flow values on the edges.\n\n    - `k: int`\n\n        The number of walks to decompose in.\n\n        !!! note \"Unknown $k$\"\n            If you do not have a good guess for $k$, you can pass `k=None` and the model will set $k$ to the condensation width of the graph (i.e. the minimum number of $s$-$t$ walks needed to cover all the edges of the graph, except those in `edges_to_ignore`).\n\n    - `flow_attr_origin: str`, optional\n\n        The origin of the flow attribute. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: the flow attribute is assumed to be on the edges of the graph.\n        - `\"node\"`: the flow attribute is assumed to be on the nodes of the graph. See [the documentation](node-expanded-digraph.md) on how node-weighted graphs are handled.\n\n    - `weight_type: int | float`, optional\n\n        The type of the weights and slacks (`int` or `float`). Default is `float`.\n\n     - `subset_constraints: list`, optional\n\n        List of subset constraints. Default is an empty list. \n        Each subset constraint is a list of edges that must be covered by some solution walk, in any order, according \n        to the `subset_constraints_coverage` parameter (see below).\n\n    - `subset_constraints_coverage: float`, optional\n\n        Coverage fraction of the subset constraints that must be covered by some solution walk. \n\n        Defaults to `1.0`, meaning that 100% of the edges (or nodes, if `flow_attr_origin` is `\"node\"`) of \n        the constraint need to be covered by some solution walk). \n        See [subset constraints documentation](subset-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `elements_to_ignore: list`, optional\n\n        List of edges (or nodes, if `flow_attr_origin` is `\"node\"`) to ignore when adding constrains on flow explanation by the weighted walks. \n        Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `elements_to_ignore_percentile: float`, optional\n\n        If provided, ignores elements automatically based on a percentile threshold of their flow values (`flow_attr`).\n        Elements (edges, or nodes if `flow_attr_origin` is `\"node\"`) whose flow is below this percentile\n        are ignored when enforcing the error constraints. Must be in the range `[0, 100]`.\n        This is mutually exclusive with `elements_to_ignore` (setting both raises a `ValueError`).\n        See [ignoring edges documentation](ignoring-edges.md).\n\n    - `error_scaling: dict`, optional\n\n        Dictionary `edge: factor` (or `node: factor`, if `flow_attr_origin` is `\"node\"`)) storing the error scale factor (in [0,1]) of every edge, which scale the allowed difference between edge/node weight and walk weights.\n        Default is an empty dict. If an edge/node has a missing error scale factor, it is assumed to be 1. The factors are used to scale the \n        difference between the flow value of the edge/node and the sum of the weights of the walks going through the edge/node. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `additional_starts: list`, optional\n\n        List of additional start nodes of the walks. Default is an empty list.\n\n    - `additional_ends: list`, optional\n\n        List of additional end nodes of the walks. Default is an empty list.\n\n    - `optimization_options: dict`, optional\n\n        Dictionary with the optimization options. Default is `None`. See [optimization options documentation](solver-options-optimizations.md).\n\n    - `solver_options: dict`, optional\n\n        Dictionary with the solver options. Default is `{}`. See [solver options documentation](solver-options-optimizations.md).\n\n    - `trusted_edges_for_safety_percentile: float`, optional\n\n        If set to a value different than `None`, this will be used to select edges to trust for safety (i.e. they are guaranteed to appear in any optimal solution). \n        Edges whose weight (`flow_attr`) is greater than or equal to the percentile value will be trusted for safety. Default is `None`. This is ignored if `trusted_edges_for_safety` is set.\n\n\n    Raises\n    ------\n    - `ValueError`\n\n        - If `weight_type` is not `int` or `float`.\n        - If the edge error scaling factor is not in [0,1].\n        - If the flow attribute `flow_attr` is not specified in some edge.\n        - If the graph contains edges with negative flow values.\n        - ValueError: If `flow_attr_origin` is not \"node\" or \"edge\".\n        - If `elements_to_ignore_percentile` is set and is not in `[0, 100]`.\n        - If `elements_to_ignore_percentile` is set together with `elements_to_ignore`.\n    \"\"\"\n\n    # Handling node-weighted graphs\n    self.flow_attr_origin = flow_attr_origin\n    if self.flow_attr_origin == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n        self.G_internal = nedg.NodeExpandedDiGraph(G, node_flow_attr=flow_attr)\n        subset_constraints_internal = self.G_internal.get_expanded_subpath_constraints(subset_constraints)\n        additional_starts_internal = self.G_internal.get_expanded_additional_starts(additional_starts)\n        additional_ends_internal = self.G_internal.get_expanded_additional_ends(additional_ends)\n\n        if not all(isinstance(element_to_ignore, str) for element_to_ignore in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n        edges_to_ignore_internal = list(set(edges_to_ignore_internal))\n\n        error_scaling_internal = {self.G_internal.get_expanded_edge(node): error_scaling[node] for node in error_scaling}\n\n    elif self.flow_attr_origin == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n        self.G_internal = G\n        subset_constraints_internal = subset_constraints\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n        additional_starts_internal = additional_starts\n        additional_ends_internal = additional_ends\n        error_scaling_internal = error_scaling\n    else:\n        utils.logger.error(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n        raise ValueError(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n\n    self.G = stdigraph.stDiGraph(self.G_internal, additional_starts=additional_starts_internal, additional_ends=additional_ends_internal)\n    self.subset_constraints = subset_constraints_internal\n\n    if elements_to_ignore_percentile is not None:\n        if elements_to_ignore_percentile &lt; 0 or elements_to_ignore_percentile &gt; 100:\n            utils.logger.error(f\"{__name__}: elements_to_ignore_percentile must be between 0 and 100, not {elements_to_ignore_percentile}\")\n            raise ValueError(f\"elements_to_ignore_percentile must be between 0 and 100, not {elements_to_ignore_percentile}\")\n        if len(elements_to_ignore) &gt; 0:\n            utils.logger.critical(f\"{__name__}: you cannot set elements_to_ignore when elements_to_ignore_percentile is set.\")\n            raise ValueError(f\"you cannot set elements_to_ignore when elements_to_ignore_percentile is set.\")\n\n        # Select edges where the flow_attr value is &gt;= elements_to_ignore_percentile (using self.G)\n        flow_values = [self.G.edges[edge][flow_attr] for edge in self.G.edges() if flow_attr in self.G.edges[edge]]\n        percentile = np.percentile(flow_values, elements_to_ignore_percentile) if flow_values else 0\n        edges_to_ignore_internal = [edge for edge in self.G.edges() if flow_attr in self.G.edges[edge] and self.G.edges[edge][flow_attr] &lt; percentile]\n\n    utils.logger.debug(f\"{__name__}: edges_to_ignore_internal set to {edges_to_ignore_internal}\")\n\n    self.edges_to_ignore = self.G.source_sink_edges.union(edges_to_ignore_internal)\n    self.edge_error_scaling = error_scaling_internal\n    # If the error scaling factor is 0, we ignore the edge\n    self.edges_to_ignore |= {edge for edge, factor in self.edge_error_scaling.items() if factor == 0}\n\n    # Checking that every entry in self.error_scaling is between 0 and 1\n    for key, value in error_scaling.items():\n        if value &lt; 0 or value &gt; 1:\n            utils.logger.error(f\"{__name__}: Error scaling factor for {key} must be between 0 and 1.\")\n            raise ValueError(f\"Error scaling factor for {key} must be between 0 and 1.\")\n\n    if weight_type not in [int, float]:\n        utils.logger.error(f\"{__name__}: weight_type must be either int or float, not {weight_type}\")\n        raise ValueError(f\"weight_type must be either int or float, not {weight_type}\")\n    self.weight_type = weight_type\n\n    self.k = k\n    # If k is not specified, we set k to the edge width of the graph\n    if self.k is None:\n        self.k = self.G.get_width(edges_to_ignore=self.edges_to_ignore)\n        utils.logger.info(f\"{__name__}: k received as None, we set it to {self.k} (edge width of the graph)\")\n    self.optimization_options = optimization_options or {}\n    self.subset_constraints_coverage = subset_constraints_coverage\n\n    self.flow_attr = flow_attr\n    self.w_max = self.k * self.weight_type(\n        self.G.get_max_flow_value_and_check_non_negative_flow(\n            flow_attr=self.flow_attr, edges_to_ignore=self.edges_to_ignore\n        )\n    )\n\n    self.pi_vars = {}\n    self.path_weights_vars = {}\n    self.path_slacks_vars = {}\n\n    self.path_weights_sol = None\n    self.path_slacks_sol = None\n    self.path_slacks_scaled_sol = None\n    self._solution = None\n    self._lowerbound_k = None\n\n    self.solve_statistics = {}\n    self.solve_time_start = time.perf_counter()\n\n    if trusted_edges_for_safety_percentile is not None:\n        if trusted_edges_for_safety_percentile &lt; 0 or trusted_edges_for_safety_percentile &gt; 100:\n            utils.logger.error(f\"{__name__}: trusted_edges_for_safety_percentile must be between 0 and 100.\")\n            raise ValueError(f\"trusted_edges_for_safety_percentile must be between 0 and 100.\")\n\n        # Select edges where the flow_attr value is &gt;= trusted_edges_for_safety_percentile (using self.G)\n        flow_values = [self.G.edges[edge][flow_attr] for edge in self.G.edges() if flow_attr in self.G.edges[edge]]\n        percentile = np.percentile(flow_values, trusted_edges_for_safety_percentile) if flow_values else 0\n        self.trusted_edges_for_safety = list(edge for edge in self.G.edges() if flow_attr in self.G.edges[edge] and self.G.edges[edge][flow_attr] &gt;= percentile)\n        # Remove from trusted_edges_for_safety the edges in edges_to_ignore\n        self.trusted_edges_for_safety = set(edge for edge in self.trusted_edges_for_safety if edge not in self.edges_to_ignore)\n        utils.logger.info(f\"{__name__}: trusted_edges_for_safety set using using percentile {trusted_edges_for_safety_percentile} = {percentile} to {self.trusted_edges_for_safety}\")\n    else:\n        # We trust for safety all edges with non-zero flow and which are not in edges_to_ignore\n        self.trusted_edges_for_safety = self.G.get_non_zero_flow_edges(\n            flow_attr=self.flow_attr, edges_to_ignore=self.edges_to_ignore\n        ).difference(self.edges_to_ignore)\n\n    self.optimization_options[\"trusted_edges_for_safety\"] = self.trusted_edges_for_safety\n\n    # If we get subset constraints, and the coverage fraction is 1\n    # then we know their edges must appear in the solution, so we add their edges to the trusted edges for safety\n    if self.subset_constraints is not None:\n        if self.subset_constraints_coverage == 1.0:\n            for constraint in self.subset_constraints:\n                # Convert to set if it's a list\n                self.optimization_options[\"trusted_edges_for_safety\"].update(constraint)\n\n    # Call the constructor of the parent class AbstractWalkModelDiGraph\n    super().__init__(\n        G=self.G,\n        k=self.k,\n        # max_edge_repetition=self.w_max,\n        max_edge_repetition_dict=self.G.compute_edge_max_reachable_value(flow_attr=self.flow_attr),\n        subset_constraints=self.subset_constraints,\n        subset_constraints_coverage=self.subset_constraints_coverage,\n        optimization_options=self.optimization_options,\n        solver_options=solver_options,\n        solve_statistics=self.solve_statistics\n    )\n\n    # This method is called from the super class AbstractWalkModelDiGraph\n    self.create_solver_and_walks()\n\n    # This method is called from the current class \n    self._encode_minpatherror_decomposition()\n\n    # This method is called from the current class to add the objective function\n    self._encode_objective()\n\n    utils.logger.info(f\"{__name__}: initialized with graph id = {utils.fpid(G)}, k = {self.k}\")\n</code></pre>"},{"location":"k-min-path-error-cycles.html#flowpaths.kminpatherrorcycles.kMinPathErrorCycles.get_solution","title":"get_solution","text":"<pre><code>get_solution(\n    remove_empty_walks=True,\n)\n</code></pre> <p>Retrieves the solution for the flow decomposition problem.</p> <p>If the solution has already been computed and cached as <code>self.solution</code>, it returns the cached solution. Otherwise, it checks if the problem has been solved, computes the solution walks, weights, slacks and caches the solution.</p> <p>Warning</p> <p>Make sure you called <code>.solve()</code> before calling this method.</p>"},{"location":"k-min-path-error-cycles.html#flowpaths.kminpatherrorcycles.kMinPathErrorCycles.get_solution--returns","title":"Returns","text":"<ul> <li> <p><code>solution: dict</code></p> <p>A dictionary containing the solution walks (key <code>\"walks\"</code>) and their corresponding weights (key <code>\"weights\"</code>) and slacks (key <code>\"slacks\"</code>).</p> </li> </ul>"},{"location":"k-min-path-error-cycles.html#flowpaths.kminpatherrorcycles.kMinPathErrorCycles.get_solution--raises","title":"Raises","text":"<ul> <li><code>exception</code> If model is not solved.</li> </ul> Source code in <code>flowpaths/kminpatherrorcycles.py</code> <pre><code>def get_solution(self, remove_empty_walks=True):\n    \"\"\"\n    Retrieves the solution for the flow decomposition problem.\n\n    If the solution has already been computed and cached as `self.solution`, it returns the cached solution.\n    Otherwise, it checks if the problem has been solved, computes the solution walks, weights, slacks\n    and caches the solution.\n\n    !!! warning \"Warning\"\n        Make sure you called `.solve()` before calling this method.\n\n    Returns\n    -------\n    - `solution: dict`\n\n        A dictionary containing the solution walks (key `\"walks\"`) and their corresponding weights (key `\"weights\"`) and slacks (key `\"slacks\"`).\n\n    Raises\n    -------\n    - `exception` If model is not solved.\n    \"\"\"\n\n    if self._solution is not None:\n        return self._remove_empty_walks(self._solution) if remove_empty_walks else self._solution\n\n    self.check_is_solved()\n\n    weights_sol_dict = self.solver.get_values(self.path_weights_vars)\n    self.path_weights_sol = [\n        (\n            round(weights_sol_dict[i])\n            if self.weight_type == int\n            else float(weights_sol_dict[i])\n        )\n        for i in range(self.k)\n    ]\n    slacks_sol_dict = self.solver.get_values(self.path_slacks_vars)\n    self.path_slacks_sol = [\n        (\n            round(slacks_sol_dict[i])\n            if self.weight_type == int\n            else float(slacks_sol_dict[i])\n        )\n        for i in range(self.k)\n    ]\n\n    if self.flow_attr_origin == \"edge\":\n        self._solution = {\n            \"walks\": self.get_solution_walks(),\n            \"weights\": self.path_weights_sol,\n            \"slacks\": self.path_slacks_sol\n            }\n    elif self.flow_attr_origin == \"node\":\n        self._solution = {\n            \"_walks_internal\": self.get_solution_walks(),\n            \"walks\": self.G_internal.get_condensed_paths(self.get_solution_walks()),\n            \"weights\": self.path_weights_sol,\n            \"slacks\": self.path_slacks_sol\n            }\n\n    return self._remove_empty_walks(self._solution) if remove_empty_walks else self._solution\n</code></pre>"},{"location":"k-min-path-error-cycles.html#flowpaths.kminpatherrorcycles.kMinPathErrorCycles.is_valid_solution","title":"is_valid_solution","text":"<pre><code>is_valid_solution(\n    tolerance=0.001,\n)\n</code></pre> <p>Checks if the solution is valid by checking of the weighted walks and their slacks satisfy the constraints of the problem. </p> <p>Warning</p> <p>Make sure you called <code>.solve()</code> before calling this method.</p>"},{"location":"k-min-path-error-cycles.html#flowpaths.kminpatherrorcycles.kMinPathErrorCycles.is_valid_solution--raises","title":"Raises","text":"<ul> <li><code>ValueError</code>: If the solution is not available.</li> </ul>"},{"location":"k-min-path-error-cycles.html#flowpaths.kminpatherrorcycles.kMinPathErrorCycles.is_valid_solution--returns","title":"Returns","text":"<ul> <li><code>bool</code>: <code>True</code> if the solution is valid, <code>False</code> otherwise.</li> </ul>"},{"location":"k-min-path-error-cycles.html#flowpaths.kminpatherrorcycles.kMinPathErrorCycles.is_valid_solution--notes","title":"Notes","text":"<ul> <li><code>get_solution()</code> must be called before this method.</li> <li>The solution is considered valid if the flow from walks is equal     (up to <code>tolerance * num_edge_walks_on_edges[(u, v)]</code>) to the flow value of the graph edges.</li> </ul> Source code in <code>flowpaths/kminpatherrorcycles.py</code> <pre><code>def is_valid_solution(self, tolerance=0.001):\n    \"\"\"\n    Checks if the solution is valid by checking of the weighted walks and their slacks satisfy the constraints of the problem. \n\n    !!! warning \"Warning\"\n        Make sure you called `.solve()` before calling this method.\n\n    Raises\n    ------\n    - `ValueError`: If the solution is not available.\n\n    Returns\n    -------\n    - `bool`: `True` if the solution is valid, `False` otherwise.\n\n    Notes\n    -------\n    - `get_solution()` must be called before this method.\n    - The solution is considered valid if the flow from walks is equal\n        (up to `tolerance * num_edge_walks_on_edges[(u, v)]`) to the flow value of the graph edges.\n    \"\"\"\n\n    if self._solution is None:\n        self.get_solution()\n\n    if tolerance &lt; 0:\n        utils.logger.error(f\"{__name__}: tolerance must be non-negative, not {tolerance}\")\n        raise ValueError(f\"tolerance must be non-negative, not {tolerance}\")\n\n    solution_walks = self._solution.get(\"_walks_internal\", self._solution[\"walks\"])\n    solution_weights = self._solution[\"weights\"]\n    solution_slacks = self._solution[\"slacks\"]\n    for walk in solution_walks:\n        if len(walk) == 1:\n            utils.logger.error(f\"{__name__}: Encountered a solution walk with length 1, which is not allowed.\")\n            raise ValueError(\"Solution walk with length 1 encountered.\")\n    solution_walks_of_edges = [\n        [(walk[i], walk[i + 1]) for i in range(len(walk) - 1)]\n        for walk in solution_walks\n    ]\n\n    weight_from_walks = {e: 0 for e in self.G.edges()}\n    slack_from_walks = {e: 0 for e in self.G.edges()}\n    num_edge_walks_on_edges = {e: 0 for e in self.G.edges()}\n    for weight, slack, walk in zip(\n        solution_weights, solution_slacks, solution_walks_of_edges\n    ):\n        for e in walk:\n            if e in weight_from_walks:\n                weight_from_walks[e] += weight\n                slack_from_walks[e] += slack\n                num_edge_walks_on_edges[e] += 1\n\n    for u, v, data in self.G.edges(data=True):\n        if self.flow_attr in data and (u,v) not in self.edges_to_ignore:\n            if (\n                abs(data[self.flow_attr] - weight_from_walks[(u, v)])\n                &gt; tolerance * num_edge_walks_on_edges[(u, v)] + slack_from_walks[(u, v)]\n            ):\n                utils.logger.debug(f\"{__name__}: Solution: {self._solution}\")\n                utils.logger.debug(f\"{__name__}: num_edge_walks_on_edges[(u, v)] = {num_edge_walks_on_edges[(u, v)]}\")\n                utils.logger.debug(f\"{__name__}: slack_from_walks[(u, v)] = {slack_from_walks[(u, v)]}\")\n                utils.logger.debug(f\"{__name__}: data[self.flow_attr] = {data[self.flow_attr]}\")\n                utils.logger.debug(f\"{__name__}: weight_from_walks[(u, v)] = {weight_from_walks[(u, v)]}\")\n                utils.logger.debug(f\"{__name__}: &gt; {tolerance * num_edge_walks_on_edges[(u, v)] + slack_from_walks[(u, v)]}\")\n\n                var_dict = {var: val for var, val in zip(self.solver.get_all_variable_names(), self.solver.get_all_variable_values())}\n                utils.logger.debug(f\"{__name__}: Variable dictionary: {var_dict}\")\n\n                return False\n\n    if abs(self.get_objective_value() - self.solver.get_objective_value()) &gt; tolerance * self.k:\n        utils.logger.info(f\"{__name__}: self.get_objective_value() = {self.get_objective_value()} self.solver.get_objective_value() = {self.solver.get_objective_value()}\")\n        return False\n\n    return True\n</code></pre>"},{"location":"k-min-path-error.html","title":"k-Minimum Path Error","text":"<p>See also</p> <ul> <li>k-Minimum Path Error in General Graphs</li> <li>An Optimization Routine for the Number k of Paths</li> <li>Handling graphs with flows / weights on nodes</li> </ul> <p>The k-Minimum Path Error problem tries to model cases where the weight along a path is not constant. As such, edges that appear in more solution paths will be allowed to have a higher error (i.e. difference between their input weight/flow value and the sum of the weights of the paths that use them). More formally, paths now receive also a slack, which intuitively models how much the weight along a path can vary. Ideally, we can decompose the weighted graphs with \\(k\\) paths that overall have small slack values.</p>"},{"location":"k-min-path-error.html#1-definition","title":"1. Definition","text":"<p>The k-Minimum Path Error problem on a directed acyclic graph (DAG) is defined as follows:</p> <ul> <li> <p>INPUT: </p> <ul> <li>A directed graph \\(G = (V,E)\\), and a weight function on \\(G\\), namely weights \\(f(u,v)\\) for every edge \\((u,v)\\) of \\(G\\). The weights are arbitrary non-negative numbers and do not need to satisfy flow conservation.</li> <li>\\(k \\in \\mathbb{Z}_+\\)</li> </ul> </li> <li> <p>OUTPUT: A list of \\(k\\) of source-to-sink paths, \\(P_1,\\dots,P_k\\), with a weight \\(w_i\\), and a slack \\(\\rho_i\\) associated to each \\(P_i\\), that satisfy the constraint $$ \\left|f(u,v) - \\sum_{i \\in \\{1,\\dots,k\\} : (u,v) \\in P_i }w_i\\right| \\leq \\sum_{i \\in \\{1,\\dots,k\\} : (u,v) \\in P_i }\\rho_i, ~\\forall (u,v) \\in E, $$ and minimize the objective function $$ \\rho_1 + \\cdots + \\rho_k. $$</p> </li> </ul> <p>Note</p> <ul> <li>This class support also graphs with flow values on nodes. Set the parameter <code>flow_attr_origin = \"node\"</code>. For details on how these are handled internally, see Handling graphs with flows / weights on nodes.</li> <li>The graph may have more than one source or sink nodes, in which case the solution paths are just required to start in any source node, and end in any sink node.</li> </ul>"},{"location":"k-min-path-error.html#2-generalizations","title":"2. Generalizations","text":"<p>This class implements a more general version, as follows:</p> <ol> <li>The paths can start/end not only in source/sink nodes, but also in given sets of start/end nodes (set parameters <code>additional_starts</code> and <code>additional_ends</code>). See also Additional start/end nodes.</li> <li>This class supports adding subpath constraints, that is, lists of edges that must appear in some solution path. See Subpath constraints for details.</li> <li>The above constraint can happen only over a given subset \\(E' \\subseteq E\\) of the edges (set parameter <code>elements_to_ignore</code> to be \\(E \\setminus E'\\)). See also ignoring edges documentation.</li> <li>The error (i.e. the above absolute of the difference) of every edge can contribute differently to the objective function, according to a scale factor \\(\\in [0,1]\\). Set these via a dictionary that you pass to <code>error_scaling</code>, which stores the scale factor \\(\\lambda_{(u,v)} \\in [0,1]\\) of each edge \\((u,v)\\) in the dictionary. Setting \\(\\lambda_{(u,v)} = 0\\) will add the edge \\((u,v)\\) to <code>elements_to_ignore</code>, because the constraint for \\((u,v)\\) becomes always true. See also ignoring edges documentation.</li> <li>Another way to relax the constraint is to allow also some looseness in the slack value, based on the length of the solution path. Intuitively, suppose that longer paths have even higher variance in their weight across the edges of the path, while shorter paths less. Formally, suppose that we have a function \\(\\alpha : \\mathbb{N} \\rightarrow \\mathbb{R}^+\\) that for every solution path length \\(\\ell\\), it returns a multiplicative factor \\(\\alpha(\\ell)\\). Then, we can multiply each path slack \\(\\rho_i\\) by \\(\\alpha(|P_i|)\\) in the constraint of the problem (where \\(|P_i|\\) denotes the length of solution path \\(P_i\\)). In the above example, we could set \\(\\alpha(\\ell) &gt; 1\\) for \u201clarge\u201d lengths \\(\\ell\\). Note that in this model we keep the same objective function (i.e. sum of slacks), and thus this multiplier has no effect on the objective value. You can pass the function \\(\\alpha\\) to the class as a piecewise encoding, via parameters <code>path_length_ranges</code> and <code>path_length_factors</code>, see kMinPathError().</li> </ol> <p>Generalized constraint</p> <p>Formally, the constraint generalized as in 3., 4. and 5. above is: $$ \\lambda_{(u,v)} \\cdot \\left|f(u,v) - \\sum_{i \\in \\{1,\\dots,k\\} : (u,v) \\in P_i }w_i\\right| \\leq \\sum_{i \\in \\{1,\\dots,k\\} : (u,v) \\in P_i }\\rho_i \\cdot \\alpha(|P_i|), ~\\forall (u,v) \\in E\u2019. $$</p> <p>A lowerbound on \\(k\\)</p> <p>The value of \\(k\\) must be at least the edge width of graph, meaning the minimum number of paths to cover all the edges in \\(E'\\), except those edges \\((u,v)\\) for which \\(\\lambda_{u,v} = 0\\). This value always gives a feasible model. </p> <p>If you do not know this lower bound, you can pass <code>k = None</code> and the model will automatically set <code>k</code> to this lowerbound value.</p>"},{"location":"k-min-path-error.html#3-references","title":"3. References","text":"<ol> <li>Fernando H. C. Dias, Alexandru I. Tomescu Accurate Flow Decomposition via Robust Integer Linear Programming IEEE/ACM Transactions on Computational Biology and Bioinformatics 21(6), 1955-1964, 2024 (preprint)</li> </ol>"},{"location":"k-min-path-error.html#flowpaths.kminpatherror.kMinPathError","title":"kMinPathError","text":"<pre><code>kMinPathError(\n    G: DiGraph,\n    flow_attr: str,\n    k: int,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1.0,\n    subpath_constraints_coverage_length: float = None,\n    length_attr: str = None,\n    elements_to_ignore: list = [],\n    error_scaling: dict = {},\n    path_length_ranges: list = [],\n    path_length_factors: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    solution_weights_superset: list = None,\n    optimization_options: dict = None,\n    solver_options: dict = None,\n)\n</code></pre> <p>               Bases: <code>AbstractPathModelDAG</code></p> <p>This class implements the k-MinPathError model from  Dias, Tomescu, Accurate Flow Decomposition via Robust Integer Linear Programming, IEEE/ACM TCBB 2024 (see preprint)</p> <p>Given an edge-weighted DAG, this model looks for k paths, with associated weights and slacks, such that for every edge (u,v),  the sum of the weights of the paths going through (u,v) minus the flow value of (u,v) is at most  the sum of the slacks of the paths going through (u,v). The objective is to minimize the sum of the slacks.</p> <p>The paths start in any source node of the graph and end in any sink node of the graph. You can allow for additional  start or end nodes by specifying them in the <code>additional_starts</code> and <code>additional_ends</code> parameters.</p>"},{"location":"k-min-path-error.html#flowpaths.kminpatherror.kMinPathError--parameters","title":"Parameters","text":"<ul> <li> <p><code>G: nx.DiGraph</code></p> <p>The input directed acyclic graph, as networkx DiGraph.</p> </li> <li> <p><code>flow_attr: str</code></p> <p>The attribute name from where to get the flow values on the edges.</p> </li> <li> <p><code>k: int</code></p> <p>The number of paths to decompose in. </p> <p>Unknown \\(k\\)</p> <p>If you do not have a good guess for \\(k\\), you can pass <code>k=None</code> and the model will set \\(k\\) to the edge width of the graph.</p> </li> <li> <p><code>flow_attr_origin: str</code>, optional</p> <p>The origin of the flow attribute. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: the flow attribute is assumed to be on the edges of the graph.</li> <li><code>\"node\"</code>: the flow attribute is assumed to be on the nodes of the graph. See the documentation on how node-weighted graphs are handled.</li> </ul> </li> <li> <p><code>weight_type: int | float</code>, optional</p> <p>The type of the weights and slacks (<code>int</code> or <code>float</code>). Default is <code>float</code>.</p> </li> <li> <p><code>subpath_constraints: list</code>, optional</p> <p>List of subpath constraints. Default is an empty list.  Each subpath constraint is a list of edges that must be covered by some solution path, according  to the <code>subpath_constraints_coverage</code> or <code>subpath_constraints_coverage_length</code> parameters (see below).</p> </li> <li> <p><code>subpath_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subpath constraints that must be covered by some solution paths. </p> <p>Defaults to <code>1.0</code>, meaning that 100% of the edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) of  the constraint need to be covered by some solution path).  See subpath constraints documentation</p> </li> <li> <p><code>subpath_constraints_coverage_length: float</code>, optional</p> <p>Coverage length of the subpath constraints. Default is <code>None</code>. If set, this overrides <code>subpath_constraints_coverage</code>,  and the coverage constraint is expressed in terms of the subpath constraint length.  <code>subpath_constraints_coverage_length</code> is then the fraction of the total length of the constraint (specified via <code>length_attr</code>, see below) needs to appear in some solution path. See subpath constraints documentation</p> </li> <li> <p><code>length_attr: str</code>, optional</p> <p>The attribute name from where to get the edge lengths (or node length, if <code>flow_attr_origin</code> is <code>\"node\"</code>). Defaults to <code>None</code>.</p> <ul> <li>If set, then the subpath lengths (above) are in terms of the edge/node lengths specified in the <code>length_attr</code> field of each edge/node.</li> <li>If set, and an edge/node has a missing edge length, then it gets length 1.</li> </ul> </li> <li> <p><code>elements_to_ignore: list</code>, optional</p> <p>List of edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) to ignore when adding constrains on flow explanation by the weighted paths.  Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>error_scaling: dict</code>, optional</p> <p>Dictionary <code>edge: factor</code> (or <code>node: factor</code>, if <code>flow_attr_origin</code> is <code>\"node\"</code>)) storing the error scale factor (in [0,1]) of every edge, which scale the allowed difference between edge/node weight and path weights. Default is an empty dict. If an edge/node has a missing error scale factor, it is assumed to be 1. The factors are used to scale the  difference between the flow value of the edge/node and the sum of the weights of the paths going through the edge/node. See ignoring edges documentation</p> </li> <li> <p><code>path_length_ranges: list</code>, optional</p> <p>List of ranges for the solution path lengths. Default is an empty list. If this list is not empty, the solution path slacks are scaled by the corresponding factor in <code>path_length_factors</code> depending on the length of the solution path.</p> <p>Example</p> <p>If you pass <pre><code>path_length_ranges    = [[0, 15], [16, 18], [19, 20], [21, 30], [31, 100000]]\npath_length_factors   = [ 1.6   ,  1.0    ,  1.3    ,  1.7    ,  1.0        ]    \n</code></pre> For example, if a path has length in the range [0, 15], its slack will be multiplied by 1.6 when comparing the  flow value of the edge to the sum of path slacks, but this multiplier will have no effect on the objective function. That is, in the objective function we still minimize the sum of path slacks, not the sum of scaled path slacks.</p> </li> <li> <p><code>path_length_factors: list</code>, optional</p> <p>List of slack scale factors, based on the path lengths. Default is an empty list. If this list is not empty, the path slacks are scaled by the corresponding factor in <code>path_length_factors</code> depending on the length of the path. See the above example.</p> </li> <li> <p><code>additional_starts: list</code>, optional</p> <p>List of additional start nodes of the paths. Default is an empty list. See additional start/end nodes documentation.</p> </li> <li> <p><code>additional_ends: list</code>, optional</p> <p>List of additional end nodes of the paths. Default is an empty list. See additional start/end nodes documentation.</p> </li> <li> <p><code>solution_weights_superset: list</code>, optional</p> <p>List of allowed weights for the paths. Default is <code>None</code>.  If set, the model will use the solution path weights only from this set, with the property that every weight in this list appears at most once in the solution weight. That is, if you want to have more paths with the same weight, add it more times to <code>solution_weights_superset</code>.</p> </li> <li> <p><code>optimization_options: dict</code>, optional</p> <p>Dictionary with the optimization options. Default is <code>None</code>. See optimization options documentation.</p> </li> <li> <p><code>solver_options: dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>{}</code>. See solver options documentation.</p> </li> </ul>"},{"location":"k-min-path-error.html#flowpaths.kminpatherror.kMinPathError--raises","title":"Raises","text":"<ul> <li> <p><code>ValueError</code></p> <ul> <li>If <code>weight_type</code> is not int or float.</li> <li>If some edge does not have the flow attribute specified as <code>flow_attr</code>.</li> <li>If <code>path_length_factors</code> is not empty and <code>weight_type</code> is float.</li> <li>If the number of path length ranges is not equal to the number of error scale factors.</li> <li>If the edge error scaling factor is not between 0 and 1.</li> <li>If the graph contains edges with negative (&lt;0) flow values.  </li> <li>ValueError: If <code>flow_attr_origin</code> is not \u201cnode\u201d or \u201cedge\u201d.</li> </ul> </li> </ul> Source code in <code>flowpaths/kminpatherror.py</code> <pre><code>def __init__(\n    self,\n    G: nx.DiGraph,\n    flow_attr: str,\n    k: int,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1.0,\n    subpath_constraints_coverage_length: float = None,\n    length_attr: str = None,\n    elements_to_ignore: list = [],\n    error_scaling: dict = {},\n    path_length_ranges: list = [],\n    path_length_factors: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    solution_weights_superset: list = None,\n    optimization_options: dict = None,\n    solver_options: dict = None,\n):\n    \"\"\"\n    This class implements the k-MinPathError model from \n    Dias, Tomescu, [Accurate Flow Decomposition via Robust Integer Linear Programming](https://doi.org/10.1109/TCBB.2024.3433523), IEEE/ACM TCBB 2024 (see [preprint](https://helda.helsinki.fi/server/api/core/bitstreams/96693568-d973-4b43-a68f-bc796bbeb225/content))\n\n    Given an edge-weighted DAG, this model looks for k paths, with associated weights and slacks, such that for every edge (u,v), \n    the sum of the weights of the paths going through (u,v) minus the flow value of (u,v) is at most \n    the sum of the slacks of the paths going through (u,v). The objective is to minimize the sum of the slacks.\n\n    The paths start in any source node of the graph and end in any sink node of the graph. You can allow for additional \n    start or end nodes by specifying them in the `additional_starts` and `additional_ends` parameters.\n\n    Parameters\n    ----------\n    - `G: nx.DiGraph`\n\n        The input directed acyclic graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html).\n\n    - `flow_attr: str`\n\n        The attribute name from where to get the flow values on the edges.\n\n    - `k: int`\n\n        The number of paths to decompose in. \n\n        !!! note \"Unknown $k$\"\n            If you do not have a good guess for $k$, you can pass `k=None` and the model will set $k$ to the edge width of the graph.\n\n    - `flow_attr_origin: str`, optional\n\n        The origin of the flow attribute. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: the flow attribute is assumed to be on the edges of the graph.\n        - `\"node\"`: the flow attribute is assumed to be on the nodes of the graph. See [the documentation](node-expanded-digraph.md) on how node-weighted graphs are handled.\n\n    - `weight_type: int | float`, optional\n\n        The type of the weights and slacks (`int` or `float`). Default is `float`.\n\n     - `subpath_constraints: list`, optional\n\n        List of subpath constraints. Default is an empty list. \n        Each subpath constraint is a list of edges that must be covered by some solution path, according \n        to the `subpath_constraints_coverage` or `subpath_constraints_coverage_length` parameters (see below).\n\n    - `subpath_constraints_coverage: float`, optional\n\n        Coverage fraction of the subpath constraints that must be covered by some solution paths. \n\n        Defaults to `1.0`, meaning that 100% of the edges (or nodes, if `flow_attr_origin` is `\"node\"`) of \n        the constraint need to be covered by some solution path). \n        See [subpath constraints documentation](subpath-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `subpath_constraints_coverage_length: float`, optional\n\n        Coverage length of the subpath constraints. Default is `None`. If set, this overrides `subpath_constraints_coverage`, \n        and the coverage constraint is expressed in terms of the subpath constraint length. \n        `subpath_constraints_coverage_length` is then the fraction of the total length of the constraint (specified via `length_attr`, see below) needs to appear in some solution path.\n        See [subpath constraints documentation](subpath-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `length_attr: str`, optional\n\n        The attribute name from where to get the edge lengths (or node length, if `flow_attr_origin` is `\"node\"`). Defaults to `None`.\n\n        - If set, then the subpath lengths (above) are in terms of the edge/node lengths specified in the `length_attr` field of each edge/node.\n        - If set, and an edge/node has a missing edge length, then it gets length 1.\n\n    - `elements_to_ignore: list`, optional\n\n        List of edges (or nodes, if `flow_attr_origin` is `\"node\"`) to ignore when adding constrains on flow explanation by the weighted paths. \n        Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `error_scaling: dict`, optional\n\n        Dictionary `edge: factor` (or `node: factor`, if `flow_attr_origin` is `\"node\"`)) storing the error scale factor (in [0,1]) of every edge, which scale the allowed difference between edge/node weight and path weights.\n        Default is an empty dict. If an edge/node has a missing error scale factor, it is assumed to be 1. The factors are used to scale the \n        difference between the flow value of the edge/node and the sum of the weights of the paths going through the edge/node. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `path_length_ranges: list`, optional\n\n        List of ranges for the solution path lengths. Default is an empty list. If this list is not empty, the solution path slacks are scaled by the\n        corresponding factor in `path_length_factors` depending on the length of the solution path.\n\n        !!! example \"Example\"\n            If you pass\n            ```\n            path_length_ranges    = [[0, 15], [16, 18], [19, 20], [21, 30], [31, 100000]]\n            path_length_factors   = [ 1.6   ,  1.0    ,  1.3    ,  1.7    ,  1.0        ]    \n            ```\n            For example, if a path has length in the range [0, 15], its slack will be multiplied by 1.6 when comparing the \n            flow value of the edge to the sum of path slacks, but this multiplier will have no effect on the objective function.\n            That is, in the objective function we still minimize the sum of path slacks, not the sum of scaled path slacks.\n\n    - `path_length_factors: list`, optional\n\n        List of slack scale factors, based on the path lengths. Default is an empty list. If this list is not empty, the path slacks are scaled by the\n        corresponding factor in `path_length_factors` depending on the length of the path. See the above example.\n\n    - `additional_starts: list`, optional\n\n        List of additional start nodes of the paths. Default is an empty list. See [additional start/end nodes documentation](additional-start-end-nodes.md).\n\n    - `additional_ends: list`, optional\n\n        List of additional end nodes of the paths. Default is an empty list. See [additional start/end nodes documentation](additional-start-end-nodes.md).\n\n    - `solution_weights_superset: list`, optional\n\n        List of allowed weights for the paths. Default is `None`. \n        If set, the model will use the solution path weights only from this set, with the property that **every weight in this list\n        appears at most once in the solution weight**. That is, if you want to have more paths with the same weight, add it more times to `solution_weights_superset`.\n\n    - `optimization_options: dict`, optional\n\n        Dictionary with the optimization options. Default is `None`. See [optimization options documentation](solver-options-optimizations.md).\n\n    - `solver_options: dict`, optional\n\n        Dictionary with the solver options. Default is `{}`. See [solver options documentation](solver-options-optimizations.md).\n\n    Raises\n    ----------\n    - `ValueError`\n\n        - If `weight_type` is not int or float.\n        - If some edge does not have the flow attribute specified as `flow_attr`.\n        - If `path_length_factors` is not empty and `weight_type` is float.\n        - If the number of path length ranges is not equal to the number of error scale factors.\n        - If the edge error scaling factor is not between 0 and 1.\n        - If the graph contains edges with negative (&lt;0) flow values.  \n        - ValueError: If `flow_attr_origin` is not \"node\" or \"edge\".          \n    \"\"\"\n\n    utils.logger.info(f\"{__name__}: START initialized with graph id = {utils.fpid(G)}, k = {k}\")\n\n    # Handling node-weighted graphs\n    self.flow_attr_origin = flow_attr_origin\n    if self.flow_attr_origin == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n        self.G_internal = nedg.NodeExpandedDiGraph(G, node_flow_attr=flow_attr, node_length_attr=length_attr)\n        subpath_constraints_internal = self.G_internal.get_expanded_subpath_constraints(subpath_constraints)\n        additional_starts_internal = self.G_internal.get_expanded_additional_starts(additional_starts)\n        additional_ends_internal = self.G_internal.get_expanded_additional_ends(additional_ends)\n\n        if not all(isinstance(element_to_ignore, str) for element_to_ignore in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n        edges_to_ignore_internal = list(set(edges_to_ignore_internal))\n\n        error_scaling_internal = {self.G_internal.get_expanded_edge(node): error_scaling[node] for node in error_scaling}\n\n    elif self.flow_attr_origin == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n        self.G_internal = G\n        subpath_constraints_internal = subpath_constraints\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n        additional_starts_internal = additional_starts\n        additional_ends_internal = additional_ends\n        error_scaling_internal = error_scaling\n    else:\n        utils.logger.error(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n        raise ValueError(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n\n    self.G = stdag.stDAG(self.G_internal, additional_starts=additional_starts_internal, additional_ends=additional_ends_internal)\n    self.subpath_constraints = subpath_constraints_internal\n    self.edges_to_ignore = self.G.source_sink_edges.union(edges_to_ignore_internal)\n    self.edge_error_scaling = error_scaling_internal\n    # If the error scaling factor is 0, we ignore the edge\n    self.edges_to_ignore |= {edge for edge, factor in self.edge_error_scaling.items() if factor == 0}\n\n    # Checking that every entry in self.error_scaling is between 0 and 1\n    for key, value in error_scaling.items():\n        if value &lt; 0 or value &gt; 1:\n            utils.logger.error(f\"{__name__}: Error scaling factor for {key} must be between 0 and 1.\")\n            raise ValueError(f\"Error scaling factor for {key} must be between 0 and 1.\")\n\n    if weight_type not in [int, float]:\n        utils.logger.error(f\"{__name__}: weight_type must be either int or float, not {weight_type}\")\n        raise ValueError(f\"weight_type must be either int or float, not {weight_type}\")\n    self.weight_type = weight_type\n\n    self.subpath_constraints_coverage = subpath_constraints_coverage\n    self.subpath_constraints_coverage_length = subpath_constraints_coverage_length\n    self.length_attr = length_attr\n\n    self.flow_attr = flow_attr\n\n    self.k = k\n    # If k is not specified, we set k to the edge width of the graph\n    if self.k is None:\n        self.k = self.G.get_width(list(self.edges_to_ignore))\n    self.original_k = self.k\n    self.solution_weights_superset = solution_weights_superset\n    self.optimization_options = optimization_options or {}        \n\n    if self.solution_weights_superset is not None:\n        self.k = len(self.solution_weights_superset)\n        self.optimization_options[\"allow_empty_paths\"] = True\n        self.optimization_options[\"optimize_with_safe_paths\"] = False\n        self.optimization_options[\"optimize_with_safe_sequences\"] = False\n        self.optimization_options[\"optimize_with_safe_zero_edges\"] = False\n        self.optimization_options[\"optimize_with_subpath_constraints_as_safe_sequences\"] = True\n        self.optimization_options[\"optimize_with_safety_as_subpath_constraints\"] = True\n\n    self.w_max = self.k * self.weight_type(\n        self.G.get_max_flow_value_and_check_non_negative_flow(\n            flow_attr=self.flow_attr, edges_to_ignore=self.edges_to_ignore\n        )\n    )\n    self.w_max = max(self.w_max, max(self.solution_weights_superset or [0]))\n\n    self.path_length_ranges = path_length_ranges\n    self.path_length_factors = path_length_factors\n    if len(self.path_length_ranges) != len(self.path_length_factors):\n        utils.logger.error(f\"{__name__}: The number of path length ranges must be equal to the number of error scale factors.\")\n        raise ValueError(\"The number of path length ranges must be equal to the number of error scale factors.\")\n    if len(self.path_length_factors) &gt; 0 and self.weight_type == float:\n        utils.logger.error(f\"{__name__}: Error scale factors are only allowed for integer weights.\")\n        raise ValueError(\"Error scale factors are only allowed for integer weights.\")\n\n    self.pi_vars = {}\n    self.path_weights_vars = {}\n    self.path_slacks_vars = {}\n\n    self.path_weights_sol = None\n    self.path_slacks_sol = None\n    self.path_slacks_scaled_sol = None\n    self._solution = None\n    self._lowerbound_k = None\n\n    self.solve_statistics = {}\n\n    self.optimization_options[\"trusted_edges_for_safety\"] = self.G.get_non_zero_flow_edges(\n        flow_attr=self.flow_attr, edges_to_ignore=self.edges_to_ignore\n    ).difference(self.edges_to_ignore)\n\n    # Call the constructor of the parent class AbstractPathModelDAG\n    super().__init__(\n        self.G, \n        self.k, \n        subpath_constraints=self.subpath_constraints, \n        subpath_constraints_coverage=self.subpath_constraints_coverage, \n        subpath_constraints_coverage_length=self.subpath_constraints_coverage_length,\n        length_attr=self.length_attr,\n        encode_edge_position=True,\n        encode_path_length=True,\n        optimization_options=self.optimization_options,\n        solver_options=solver_options,\n        solve_statistics=self.solve_statistics,\n    )\n\n    # This method is called from the super class AbstractPathModelDAG\n    self.create_solver_and_paths()\n\n    # This method is called from the current class \n    if self.solution_weights_superset is None:\n        self._encode_minpatherror_decomposition()\n    else:\n        self._encode_minpatherror_decomposition_with_given_weights()\n\n    # This method is called from the current class to add the objective function\n    self._encode_objective()\n\n    utils.logger.info(f\"{__name__}: END initialized with graph id = {utils.fpid(G)}, k = {self.k}\")\n</code></pre>"},{"location":"k-min-path-error.html#flowpaths.kminpatherror.kMinPathError.get_solution","title":"get_solution","text":"<pre><code>get_solution(\n    remove_empty_paths=True,\n)\n</code></pre> <p>Retrieves the solution for the flow decomposition problem.</p> <p>If the solution has already been computed and cached as <code>self.solution</code>, it returns the cached solution. Otherwise, it checks if the problem has been solved, computes the solution paths, weights, slacks and caches the solution.</p> <p>Warning</p> <p>Make sure you called <code>.solve()</code> before calling this method.</p>"},{"location":"k-min-path-error.html#flowpaths.kminpatherror.kMinPathError.get_solution--returns","title":"Returns","text":"<ul> <li> <p><code>solution: dict</code></p> <p>A dictionary containing the solution paths (key <code>\"paths\"</code>) and their corresponding weights (key <code>\"weights\"</code>) and slacks (key <code>\"slacks\"</code>).  If <code>path_length_factors</code> is not empty, it also contains the scaled slacks (key <code>\"scaled_slacks\"</code>).</p> </li> </ul>"},{"location":"k-min-path-error.html#flowpaths.kminpatherror.kMinPathError.get_solution--raises","title":"Raises","text":"<ul> <li><code>exception</code> If model is not solved.</li> </ul> Source code in <code>flowpaths/kminpatherror.py</code> <pre><code>def get_solution(self, remove_empty_paths=True):\n    \"\"\"\n    Retrieves the solution for the flow decomposition problem.\n\n    If the solution has already been computed and cached as `self.solution`, it returns the cached solution.\n    Otherwise, it checks if the problem has been solved, computes the solution paths, weights, slacks\n    and caches the solution.\n\n    !!! warning \"Warning\"\n        Make sure you called `.solve()` before calling this method.\n\n    Returns\n    -------\n    - `solution: dict`\n\n        A dictionary containing the solution paths (key `\"paths\"`) and their corresponding weights (key `\"weights\"`) and slacks (key `\"slacks\"`). \n        If `path_length_factors` is not empty, it also contains the scaled slacks (key `\"scaled_slacks\"`).\n\n    Raises\n    -------\n    - `exception` If model is not solved.\n    \"\"\"\n\n    if self._solution is not None:\n        return self._remove_empty_paths(self._solution) if remove_empty_paths else self._solution\n\n    self.check_is_solved()\n\n    if self.solution_weights_superset is None:\n        weights_sol_dict = self.solver.get_values(self.path_weights_vars)\n    else:\n        weights_sol_dict = {i: self.solution_weights_superset[i] for i in range(self.k)}\n\n    self.path_weights_sol = [\n        (\n            round(weights_sol_dict[i])\n            if self.weight_type == int\n            else float(weights_sol_dict[i])\n        )\n        for i in range(self.k)\n    ]\n    slacks_sol_dict = self.solver.get_values(self.path_slacks_vars)\n    self.path_slacks_sol = [\n        (\n            round(slacks_sol_dict[i])\n            if self.weight_type == int\n            else float(slacks_sol_dict[i])\n        )\n        for i in range(self.k)\n    ]\n\n    if self.flow_attr_origin == \"edge\":\n        self._solution = {\n            \"paths\": self.get_solution_paths(),\n            \"weights\": self.path_weights_sol,\n            \"slacks\": self.path_slacks_sol\n            }\n    elif self.flow_attr_origin == \"node\":\n        self._solution = {\n            \"_paths_internal\": self.get_solution_paths(),\n            \"paths\": self.G_internal.get_condensed_paths(self.get_solution_paths()),\n            \"weights\": self.path_weights_sol,\n            \"slacks\": self.path_slacks_sol\n            }\n\n    if len(self.path_length_factors) &gt; 0:\n        slacks_scaled_sol_dict = self.solver.get_values(self.scaled_slack_vars)\n        self.path_slacks_scaled_sol = [slacks_scaled_sol_dict[i] for i in range(self.k)]\n\n        self._solution[\"scaled_slacks\"] = self.path_slacks_scaled_sol\n\n    return self._remove_empty_paths(self._solution) if remove_empty_paths else self._solution\n</code></pre>"},{"location":"k-min-path-error.html#flowpaths.kminpatherror.kMinPathError.is_valid_solution","title":"is_valid_solution","text":"<pre><code>is_valid_solution(\n    tolerance=0.001,\n)\n</code></pre> <p>Checks if the solution is valid by checking of the weighted paths and their slacks satisfy the constraints of the problem. </p> <p>Warning</p> <p>Make sure you called <code>.solve()</code> before calling this method.</p>"},{"location":"k-min-path-error.html#flowpaths.kminpatherror.kMinPathError.is_valid_solution--raises","title":"Raises","text":"<ul> <li><code>ValueError</code>: If the solution is not available.</li> </ul>"},{"location":"k-min-path-error.html#flowpaths.kminpatherror.kMinPathError.is_valid_solution--returns","title":"Returns","text":"<ul> <li><code>bool</code>: <code>True</code> if the solution is valid, <code>False</code> otherwise.</li> </ul>"},{"location":"k-min-path-error.html#flowpaths.kminpatherror.kMinPathError.is_valid_solution--notes","title":"Notes","text":"<ul> <li><code>get_solution()</code> must be called before this method.</li> <li>The solution is considered valid if the flow from paths is equal     (up to <code>tolerance * num_paths_on_edges[(u, v)]</code>) to the flow value of the graph edges.</li> </ul> Source code in <code>flowpaths/kminpatherror.py</code> <pre><code>def is_valid_solution(self, tolerance=0.001):\n    \"\"\"\n    Checks if the solution is valid by checking of the weighted paths and their slacks satisfy the constraints of the problem. \n\n    !!! warning \"Warning\"\n        Make sure you called `.solve()` before calling this method.\n\n    Raises\n    ------\n    - `ValueError`: If the solution is not available.\n\n    Returns\n    -------\n    - `bool`: `True` if the solution is valid, `False` otherwise.\n\n    Notes\n    -------\n    - `get_solution()` must be called before this method.\n    - The solution is considered valid if the flow from paths is equal\n        (up to `tolerance * num_paths_on_edges[(u, v)]`) to the flow value of the graph edges.\n    \"\"\"\n\n    if self._solution is None:\n        self.get_solution()\n\n    if tolerance &lt; 0:\n        utils.logger.error(f\"{__name__}: tolerance must be non-negative, not {tolerance}\")\n        raise ValueError(f\"tolerance must be non-negative, not {tolerance}\")\n\n    solution_paths = self._solution.get(\"_paths_internal\", self._solution[\"paths\"])\n    solution_weights = self._solution[\"weights\"]\n    solution_slacks = self._solution[\"slacks\"]\n    if len(self.path_length_factors) &gt; 0:\n        solution_slacks = self._solution[\"scaled_slacks\"]\n    for path in solution_paths:\n        if len(path) == 1:\n            utils.logger.error(f\"{__name__}: Encountered a solution path with length 1, which is not allowed.\")\n            raise ValueError(\"Solution path with length 1 encountered.\")\n    solution_paths_of_edges = [\n        [(path[i], path[i + 1]) for i in range(len(path) - 1)]\n        for path in solution_paths\n    ]\n\n    weight_from_paths = {e: 0 for e in self.G.edges()}\n    slack_from_paths = {e: 0 for e in self.G.edges()}\n    num_paths_on_edges = {e: 0 for e in self.G.edges()}\n    for weight, slack, path in zip(\n        solution_weights, solution_slacks, solution_paths_of_edges\n    ):\n        for e in path:\n            if e in weight_from_paths:\n                weight_from_paths[e] += weight\n                slack_from_paths[e] += slack\n                num_paths_on_edges[e] += 1\n\n    for u, v, data in self.G.edges(data=True):\n        if self.flow_attr in data and (u,v) not in self.edges_to_ignore:\n            if (\n                abs(data[self.flow_attr] - weight_from_paths[(u, v)])\n                &gt; tolerance * num_paths_on_edges[(u, v)] + slack_from_paths[(u, v)]\n            ):\n                utils.logger.debug(f\"{__name__}: Solution: {self._solution}\")\n                utils.logger.debug(f\"{__name__}: num_paths_on_edges[(u, v)] = {num_paths_on_edges[(u, v)]}\")\n                utils.logger.debug(f\"{__name__}: slack_from_paths[(u, v)] = {slack_from_paths[(u, v)]}\")\n                utils.logger.debug(f\"{__name__}: data[self.flow_attr] = {data[self.flow_attr]}\")\n                utils.logger.debug(f\"{__name__}: weight_from_paths[(u, v)] = {weight_from_paths[(u, v)]}\")\n                utils.logger.debug(f\"{__name__}: &gt; {tolerance * num_paths_on_edges[(u, v)] + slack_from_paths[(u, v)]}\")\n\n                var_dict = {var: val for var, val in zip(self.solver.get_all_variable_names(), self.solver.get_all_variable_values())}\n                utils.logger.debug(f\"{__name__}: Variable dictionary: {var_dict}\")\n\n                return False\n\n    if abs(self.get_objective_value() - self.solver.get_objective_value()) &gt; tolerance * self.k:\n        utils.logger.info(f\"{__name__}: self.get_objective_value() = {self.get_objective_value()} self.solver.get_objective_value() = {self.solver.get_objective_value()}\")\n        return False\n\n    # Checking that the error scale factor is correctly encoded\n    if len(self.path_length_factors) &gt; 0:\n        path_length_sol = self.solver.get_values(self.path_length_vars)\n        slack_sol = self.solver.get_values(self.path_slacks_vars)\n        path_slack_scaled_sol = self.solver.get_values(self.slack_factors_vars)\n        scaled_slack_sol = self.solver.get_values(self.scaled_slack_vars) \n\n        for i in range(self.k):\n            # Checking which interval the path length is in,\n            # and then checking if the error scale factor is correctly encoded, \n            for index, interval in enumerate(self.path_length_ranges):\n                if path_length_sol[i] &gt;= interval[0] and path_length_sol[i] &lt;= interval[1]:\n                    if abs(path_slack_scaled_sol[i] - self.path_length_factors[index]) &gt; tolerance:\n                        utils.logger.debug(f\"{__name__}: path_length_sol: {path_length_sol}\")\n                        utils.logger.debug(f\"{__name__}: slack_sol: {slack_sol}\")\n                        utils.logger.debug(f\"{__name__}: path_slack_scaled_sol: {path_slack_scaled_sol}\")\n                        utils.logger.debug(f\"{__name__}: scaled_slack_sol: {scaled_slack_sol}\")\n\n                        return False\n\n    if not self.verify_edge_position():\n        return False\n\n    if not self.verify_path_length():\n        return False\n\n    return True\n</code></pre>"},{"location":"minimum-error-flow.html","title":"Minimum Correction of Weights to a Flow","text":"<p>Often, the edge weights of a graph are not a flow (i.e. do not satisfy flow conservation for non- source/sink nodes). While the models k-Minimum Path Error or k-Least Absolute Errors can decompose such graphs, as a less principled approach, one can first minimally correct the graph weights to become a flow, and then optimally decompose the resulting flow using the Minimum Flow Decomposition model. </p> <p>This is faster in practice, because the Minimum Flow Decomposition solver is faster than the ones decomposing graphs without flow conservation. We are thus delegating error correction to a pre-processing step, and then avoiding the error-handling difficulty when decomposing the resulting graph.</p>"},{"location":"minimum-error-flow.html#1-definition","title":"1. Definition","text":"<p>This class solves the following problem.</p> <ul> <li> <p>INPUT: A directed graph \\(G = (V,E)\\) and a weight \\(w(u,v)\\) for every edge \\((u,v)\\) of \\(G\\). Weights do not necessarily satisfy flow conservation. </p> </li> <li> <p>OUTPUT: A flow value \\(f(u,v)\\) for every edge \\((u,v) \\in E\\), satisfying the flow conservation property for all non-source and non-sink nodes \\(v\\): $$ \\sum_{(u,v) \\in E} f(u,v) = \\sum_{(v,u) \\in E} f(v,u), $$ minimizing the sum of absolute errors: $$ \\sum_{(u,v) \\in E}\\Big|f(u,v) - w(u,v)\\Big|. $$</p> </li> </ul> <p>Note</p> <ul> <li>This class support also graphs with flow values on nodes. Set the parameter <code>flow_attr_origin = \"node\"</code>. For details on how these are handled internally, see Handling graphs with flows / weights on nodes.</li> </ul>"},{"location":"minimum-error-flow.html#2-examples","title":"2. Examples","text":"<p>Let\u2019s consider the following weighted graph, whose weights do not satisfy flow conservation, because the edges shown in brown are erroneous.</p> <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|7| a\n    a --&gt;|2| b\n    s --&gt;|7| b\n    a --&gt;|4| c\n    b --&gt;|9| c\n    c --&gt;|7| d\n    d --&gt;|6| t\n    c --&gt;|7| t\n\n    linkStyle 0,5 stroke:brown,stroke-width:3;</code></pre> <p>Let\u2019s then minimally correct its weights with default settings.</p> <pre><code>import flowpaths as fp\nimport networkx as nx\n\ngraph = nx.DiGraph()\ngraph.add_edge(\"s\", \"a\", flow=7)\ngraph.add_edge(\"s\", \"b\", flow=7)\ngraph.add_edge(\"a\", \"b\", flow=2)\ngraph.add_edge(\"a\", \"c\", flow=4)\ngraph.add_edge(\"b\", \"c\", flow=9)\ngraph.add_edge(\"c\", \"d\", flow=7)\ngraph.add_edge(\"c\", \"t\", flow=7)\ngraph.add_edge(\"d\", \"t\", flow=6)\n\n# We create a the Minimum Error Flow solver with default settings\ncorrection_model = fp.MinErrorFlow(graph, flow_attr=\"flow\")\ncorrection_model.solve()\n</code></pre> <p>The resulting graph is below. The edges whose weights have been corrected are in green.</p> <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|6| a\n    a --&gt;|2| b\n    s --&gt;|7| b\n    a --&gt;|4| c\n    b --&gt;|9| c\n    c --&gt;|6| d\n    d --&gt;|6| t\n    c --&gt;|7| t\n\n    linkStyle 0,5 stroke:green,stroke-width:3;</code></pre> <p>Once we have corrected the weights, we can get the corrected graph and e.g. apply the minimum flow decomposition model on it.</p> <pre><code>if correction_model.is_solved():\n    corrected_graph = correction_model.get_corrected_graph()\n    # This is equivalent to: corrected_graph = correction_model.get_solution()[\"graph\"]\n    mfd_model = fp.MinFlowDecomp(corrected_graph, flow_attr=\"flow\")\n    mfd_model.solve()\n    if mfd_model.is_solved():\n        print(mfd_model.get_solution())\n        # {'paths': [\n        #   ['s', 'b', 'c', 't'], \n        #   ['s', 'a', 'c', 'd', 't'], \n        #   ['s', 'a', 'b', 'c', 'd', 't']], \n        # 'weights': [7.0, 4.0, 2.0]}\n</code></pre> <p>This gives the following paths.</p> <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|4| a\n    a --&gt;|4| c\n    c --&gt;|4| d\n    d --&gt;|4| t\n    linkStyle 0,1,2,3 stroke:red,stroke-width:3;\n    s --&gt;|2| a\n    a --&gt;|2| b\n    b --&gt;|2| c\n    c --&gt;|2| d\n    d --&gt;|2| t\n    linkStyle 4,5,6,7,8 stroke:orange,stroke-width:3;\n    s --&gt;|7| b\n    b --&gt;|7| c\n    c --&gt;|7| t\n    linkStyle 9,10,11 stroke:blue,stroke-width:3;</code></pre>"},{"location":"minimum-error-flow.html#3-generalizations","title":"3. Generalizations","text":"<p>This class implements a more general version, as follows:</p> <ol> <li>For acyclic graphs, the corrected flow can start/end not only in source/sink nodes, but also in given sets of start/end nodes (set parameters <code>additional_starts</code> and <code>additional_ends</code>). See also Additional start/end nodes.</li> <li>The error can count only for a given subset \\(E' \\subseteq E\\) of the edges (set parameter <code>elements_to_ignore</code> to be \\(E \\setminus E'\\)). See also ignoring edges documentation.</li> <li>The error (i.e. the above absolute of the difference) of every edge can contribute differently to the objective function, according to a scale factor \\(\\in [0,1]\\). Set these via a dictionary that you pass to <code>error_scaling</code>, which stores the scale factor \\(\\lambda_{(u,v)} \\in [0,1]\\) of each edge \\((u,v)\\) in the dictionary. Setting \\(\\lambda_{(u,v)} = 0\\) will add the edge \\((u,v)\\) to <code>elements_to_ignore</code>, because the constraint for \\((u,v)\\) becomes always true. See also ignoring edges documentation.</li> <li>For acyclic graphs, one can also ensure some \u201csparsity\u201d in the solution, meaning the total corrected flow exiting the source node is counts also in the minimization function, with a given multiplier \\(\\lambda\\) (see ref. [2]). If \\(\\lambda = 0\\), this has no effect.</li> </ol> <p>Generalized objective function</p> <p>Formally, the objective function generalized as in 2., 3. and 4. above is: $$ \\sum_{(u,v) \\in E\u2019}\\lambda_{(u,v)} \\cdot \\Big|f(u,v) - w(u,v)\\Big| + \\lambda \\sum_{(s,v) \\in E} f(s,v). $$</p>"},{"location":"minimum-error-flow.html#4-references","title":"4. References","text":"<ol> <li>Alexandru I. Tomescu, Anna Kuosmanen, Romeo Rizzi, Veli M\u00e4kinen A novel min-cost flow method for estimating transcript expression with RNA-Seq BMC Bioinformatics 14(S-5), S15, 2013 (preprint)</li> <li>Elsa Bernard, Laurent Jacob, Julien Mairal, Jean-Philippe Vert Efficient RNA isoform identification and quantification from RNA-Seq data with network flows, Bioinformatics, Volume 30, Issue 17, September 2014, Pages 2447\u20132455</li> </ol>"},{"location":"minimum-error-flow.html#flowpaths.minerrorflow.MinErrorFlow","title":"MinErrorFlow","text":"<pre><code>MinErrorFlow(\n    G: DiGraph,\n    flow_attr: str,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    sparsity_lambda: float = 0,\n    few_flow_values_epsilon: float = None,\n    elements_to_ignore: list = [],\n    error_scaling: dict = {},\n    additional_starts: list = [],\n    additional_ends: list = [],\n    solver_options: dict = {},\n)\n</code></pre> <p>This class implements a method to optimally correct the weights of a directed acyclic graph, so that:</p> <ul> <li>The resulting weights become a flow, i.e. they become a non-negative flow, namely they satisfy the flow conservation constraints.</li> <li>The resulting weights are as close as possible to the original weights, i.e. the sum of the absolute difference between an edge weight and the corrected flow value of the edge, for all edges, is minimized.</li> </ul>"},{"location":"minimum-error-flow.html#flowpaths.minerrorflow.MinErrorFlow--parameters","title":"Parameters","text":"<ul> <li> <p><code>G: networkx.DiGraph</code></p> <p>The directed graph to be corrected (which does not need to be acyclic).</p> </li> <li> <p><code>flow_attr: str</code></p> <p>The name of the attribute in the edges of the graph that contains the weight of the edge.</p> </li> <li> <p><code>flow_attr_origin : str</code>, optional</p> <p>The origin of the flow attribute. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: the flow attribute is assumed to be on the edges of the graph.</li> <li><code>\"node\"</code>: the flow attribute is assumed to be on the nodes of the graph. See the documentation on how node-weighted graphs are handled.</li> </ul> </li> <li> <p><code>weight_type: type</code>, optional</p> <p>The type of the weights of the edges. It can be either <code>int</code> or <code>float</code>. Default is <code>float</code>.</p> </li> <li> <p><code>sparsity_lambda: float</code>, optional</p> <p>The sparsity parameter, used to control the trade-off between the sparsity of the solution and the closeness to the original weights. Default is <code>0</code>. If <code>sparsity_lambda</code> is set to <code>0</code>, then the solution will be as close as possible to the original weights. If <code>sparsity_lambda</code> is set to a positive value, then the solution will be sparser, i.e. it will have less flow going out of the source. The higher the value of <code>sparsity_lambda</code>, the sparser the solution will be. You can use a value different than <code>0</code> only for acyclic graphs. If you set it to a value different than <code>0</code> for a cyclic graph, the class will raise an error.</p> </li> <li> <p><code>few_flow_values_epsilon: float</code>, optional</p> <p>The epsilon value (at least zero) used to control the number of distinct values in the corrected flow. If <code>few_flow_values_epsilon</code> is set to <code>None</code>, then the solution will be as close as possible to the original weights, and there is no bound on the number of distinct values in the corrected flow. If <code>few_flow_values_epsilon</code> is set to a positive value, then the solution will have fewer distinct flow values in the corrected flow, while ensuring that the objective value of the resulting problem is within \\((1+\u000barepsilon)\\) of the optimal solution (with this parameter set to <code>None</code>). The higher the value of <code>few_flow_values_epsilon</code>, the smaller the number of flow values in the corrected flow, but possibly higher the sum of edge errors in the corrected flow. Default is <code>None</code>.</p> <p>Warning</p> <p>Setting this can be slow on larger graphs.</p> </li> <li> <p><code>elements_to_ignore : list</code>, optional</p> <p>List of edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) to ignore when adding constrains on flow explanation by the weighted paths.  Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>error_scaling: dict</code>, optional</p> <p>Dictionary <code>edge: factor</code> (or <code>node: factor</code>, if <code>flow_attr_origin</code> is <code>\"node\"</code>)) storing the error scale factor (in [0,1]) of every edge, which scale the allowed difference between edge/node weight and path weights. Default is an empty dict. If an edge/node has a missing error scale factor, it is assumed to be 1. The factors are used to scale the  difference between the flow value of the edge/node and the sum of the weights of the paths going through the edge/node. See ignoring edges documentation</p> </li> <li> <p><code>additional_starts: list</code>, optional</p> <p>A list of nodes to be added as additional sources. This applies only to acyclic graphs. Flow is allowed to start start at these nodes, meaning that their out going flow can be greater than their incoming flow. Default is <code>[]</code>. See also additional start/end nodes documentation.</p> </li> <li> <p><code>additional_ends: list</code>, optional</p> <p>A list of nodes to be added as additional sinks. This applies only to acyclic graphs. Flow is allowed to end at these nodes, meaning that their incoming flow can be greater than their outgoing flow. Default is <code>[]</code>. See also additional start/end nodes documentation.</p> </li> <li> <p><code>solver_options: dict</code>, optional</p> <p>A dictionary containing the options for the solver. The options are passed to the solver wrapper. Default is <code>{}</code>. See solver options documentation.</p> </li> </ul> Source code in <code>flowpaths/minerrorflow.py</code> <pre><code>def __init__(\n        self, \n        G: nx.DiGraph,\n        flow_attr: str,\n        flow_attr_origin: str = \"edge\",\n        weight_type: type = float,\n        sparsity_lambda: float = 0,\n        few_flow_values_epsilon: float = None,\n        elements_to_ignore: list = [],\n        error_scaling: dict = {},\n        additional_starts: list = [],\n        additional_ends: list = [],\n        solver_options: dict = {},\n        ):\n    \"\"\"\n    This class implements a method to optimally correct the weights of a directed acyclic graph, so that:\n\n    - The resulting weights become a flow, i.e. they become a non-negative flow, namely they satisfy the flow conservation constraints.\n    - The resulting weights are as close as possible to the original weights, i.e. the sum of the absolute difference between an edge weight and the corrected flow value of the edge, for all edges, is minimized.\n\n    Parameters\n    ----------\n\n    - `G: networkx.DiGraph`\n\n        The directed graph to be corrected (which does not need to be acyclic).\n\n    - `flow_attr: str`\n\n        The name of the attribute in the edges of the graph that contains the weight of the edge.\n\n    - `flow_attr_origin : str`, optional\n\n        The origin of the flow attribute. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: the flow attribute is assumed to be on the edges of the graph.\n        - `\"node\"`: the flow attribute is assumed to be on the nodes of the graph. See [the documentation](node-expanded-digraph.md) on how node-weighted graphs are handled.\n\n    - `weight_type: type`, optional\n\n        The type of the weights of the edges. It can be either `int` or `float`. Default is `float`.\n\n    - `sparsity_lambda: float`, optional\n\n        The sparsity parameter, used to control the trade-off between the sparsity of the solution and the closeness to the original weights. Default is `0`.\n        If `sparsity_lambda` is set to `0`, then the solution will be as close as possible to the original weights. If `sparsity_lambda` is set to a positive value, then the solution will be sparser, i.e. it will have less flow going out of the source.\n        The higher the value of `sparsity_lambda`, the sparser the solution will be. **You can use a value different than `0` only for acyclic graphs.** If you set it to a value different than `0` for a cyclic graph, the class will raise an error.\n\n    - `few_flow_values_epsilon: float`, optional\n\n        The epsilon value (at least zero) used to control the number of distinct values in the corrected flow. If `few_flow_values_epsilon` is set to `None`, then the solution will be as close as possible to the original weights,\n        and there is no bound on the number of distinct values in the corrected flow.\n        If `few_flow_values_epsilon` is set to a positive value, then the solution will have fewer distinct flow values in the corrected flow, while ensuring that the objective value of the resulting problem is within $(1+\\varepsilon)$ of the optimal solution (with this parameter set to `None`).\n        The higher the value of `few_flow_values_epsilon`, the smaller the number of flow values in the corrected flow, but possibly higher the sum of edge errors in the corrected flow. Default is `None`.\n\n        !!! warning \"Warning\"\n\n            Setting this can be slow on larger graphs.\n\n    - `elements_to_ignore : list`, optional\n\n        List of edges (or nodes, if `flow_attr_origin` is `\"node\"`) to ignore when adding constrains on flow explanation by the weighted paths. \n        Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `error_scaling: dict`, optional\n\n        Dictionary `edge: factor` (or `node: factor`, if `flow_attr_origin` is `\"node\"`)) storing the error scale factor (in [0,1]) of every edge, which scale the allowed difference between edge/node weight and path weights.\n        Default is an empty dict. If an edge/node has a missing error scale factor, it is assumed to be 1. The factors are used to scale the \n        difference between the flow value of the edge/node and the sum of the weights of the paths going through the edge/node. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `additional_starts: list`, optional\n\n        A list of nodes to be added as additional sources. **This applies only to acyclic graphs.** Flow is allowed to start start at these nodes, meaning that their out going flow can be greater than their incoming flow. Default is `[]`. See also [additional start/end nodes documentation](additional-start-end-nodes.md).\n\n    - `additional_ends: list`, optional\n\n        A list of nodes to be added as additional sinks. **This applies only to acyclic graphs.** Flow is allowed to end at these nodes, meaning that their incoming flow can be greater than their outgoing flow. Default is `[]`. See also [additional start/end nodes documentation](additional-start-end-nodes.md).\n\n    - `solver_options: dict`, optional\n\n        A dictionary containing the options for the solver. The options are passed to the solver wrapper. Default is `{}`. See [solver options documentation](solver-options-optimizations.md).\n    \"\"\"\n\n    # Handling node-weighted graphs\n    self.flow_attr_origin = flow_attr_origin\n    if self.flow_attr_origin == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n\n        self.G_internal = nedg.NodeExpandedDiGraph(G, node_flow_attr=flow_attr)\n        additional_starts_internal = self.G_internal.get_expanded_additional_starts(additional_starts)\n        additional_ends_internal = self.G_internal.get_expanded_additional_ends(additional_ends)\n\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        if not all(isinstance(node, str) for node in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes, i.e. strings, not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes, i.e. strings, not {elements_to_ignore}\")\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n        edges_to_ignore_internal = list(set(edges_to_ignore_internal))\n\n        error_scaling_internal = {self.G_internal.get_expanded_edge(node): error_scaling[node] for node in error_scaling}\n\n    elif self.flow_attr_origin == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n\n        self.G_internal = G\n        additional_starts_internal = additional_starts\n        additional_ends_internal = additional_ends\n\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n\n        error_scaling_internal = error_scaling\n    else:\n        utils.logger.error(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n        raise ValueError(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n\n    self.original_graph_copy = deepcopy(self.G_internal)\n    self.sparsity_lambda = sparsity_lambda\n\n    if nx.is_directed_acyclic_graph(self.G_internal):\n        self.is_acyclic = True\n        self.G = stdag.stDAG(self.G_internal, additional_starts=additional_starts_internal, additional_ends=additional_ends_internal)\n        self.edges_to_ignore = set(edges_to_ignore_internal).union(self.G.source_sink_edges)\n    else:\n        self.G = self.G_internal\n        self.is_acyclic = False\n        self.edges_to_ignore = set(edges_to_ignore_internal)\n        if self.sparsity_lambda != 0:\n            utils.logger.error(f\"{__name__}: You cannot set sparsity_lambda != 0 for a graph with cycles.\")\n            raise ValueError(f\"You cannot set sparsity_lambda != 0 for a graph with cycles.\")\n    self.edge_error_scaling = error_scaling_internal\n    # If the error scaling factor is 0, we ignore the edge\n    self.edges_to_ignore |= {edge for edge, factor in self.edge_error_scaling.items() if factor == 0}\n\n    # Checking that every entry in self.error_scaling is between 0 and 1\n    for key, value in error_scaling.items():\n        if value &lt; 0 or value &gt; 1:\n            utils.logger.error(f\"{__name__}: Error scaling factor for {key} must be between 0 and 1.\")\n            raise ValueError(f\"Error scaling factor for {key} must be between 0 and 1.\")\n\n    self.flow_attr = flow_attr\n    if weight_type not in [int, float]:\n        utils.logger.error(f\"{__name__}: weight_type must be either int or float, not {weight_type}\")\n        raise ValueError(f\"weight_type must be either int or float, not {weight_type}\")\n    self.weight_type = weight_type\n    self.solver_options = solver_options\n\n    # Checking that every entry in self.edge_error_scaling is between 0 and 1\n    for key, value in self.edge_error_scaling.items():\n        if value &lt; 0 or value &gt; 1:\n            utils.logger.error(f\"{__name__}: Error scaling factor for {key} must be between 0 and 1.\")\n            raise ValueError(f\"Error scaling factor for {key} must be between 0 and 1.\")\n\n\n    self.different_flow_values_epsilon = few_flow_values_epsilon\n    if few_flow_values_epsilon is not None:\n        if few_flow_values_epsilon &lt; 0:\n            utils.logger.error(f\"{__name__}: different_flow_values_epsilon must be greater than or equal to 0, not {few_flow_values_epsilon}\")\n            raise ValueError(f\"different_flow_values_epsilon must be greater than or equal to 0, not {few_flow_values_epsilon}\")\n        if few_flow_values_epsilon == 0:\n            self.different_flow_values_epsilon = None        \n\n    self._solution = None\n    self._is_solved = None\n    self.solve_statistics = dict()\n\n    self.edge_vars = {}\n    self.edge_error_vars = {}\n    self.edge_sol = {}\n\n    self.w_max = max(\n        [\n            self.G[u][v].get(self.flow_attr, 0)\n            for (u, v) in self.G.edges() \n        ]\n    )\n    self.ub = self.w_max * self.G.number_of_edges()\n\n    self._create_solver()\n\n    self._encode_flow()\n\n    self._encode_min_sum_errors_objective()  \n\n    utils.logger.info(f\"{__name__}: initialized with graph id = {utils.fpid(G)}\")  \n</code></pre>"},{"location":"minimum-error-flow.html#flowpaths.minerrorflow.MinErrorFlow.get_corrected_graph","title":"get_corrected_graph","text":"<pre><code>get_corrected_graph()\n</code></pre> <p>Returns the corrected graph, as a networkx DiGraph. This is a deep copy of the original graph, but having the corrected weights.</p> <p>Warning</p> <p>Call the <code>solve</code> method first.</p> Source code in <code>flowpaths/minerrorflow.py</code> <pre><code>def get_corrected_graph(self):\n    \"\"\"\n    Returns the corrected graph, as a networkx DiGraph. This is a deep copy of the original graph, but having the corrected weights.\n\n    !!! warning \"Warning\"\n        Call the `solve` method first.\n    \"\"\"\n    solution = self.get_solution()\n    return solution[\"graph\"]\n</code></pre>"},{"location":"minimum-error-flow.html#flowpaths.minerrorflow.MinErrorFlow.get_objective_value","title":"get_objective_value","text":"<pre><code>get_objective_value()\n</code></pre> <p>Returns the sum of the errors of the optimum solution.</p> <p>Warning</p> <p>Call the <code>solve</code> method first.</p> Source code in <code>flowpaths/minerrorflow.py</code> <pre><code>def get_objective_value(self):\n    \"\"\"\n    Returns the sum of the errors of the optimum solution.\n\n    !!! warning \"Warning\"\n        Call the `solve` method first.\n    \"\"\"\n\n    solution = self.get_solution()\n    return solution[\"error\"]\n</code></pre>"},{"location":"minimum-error-flow.html#flowpaths.minerrorflow.MinErrorFlow.get_solution","title":"get_solution","text":"<pre><code>get_solution()\n</code></pre> <p>Returns the solution to the problem, if the model was solved, as a dictionary containing the following keys:</p> <ul> <li><code>graph</code>: the corrected graph, as a networkx DiGraph.</li> <li><code>error</code>: the error of the solution, i.e. the sum of the absolute differences between the original weights and the corrected weights.</li> <li><code>objective_value</code>: the value of the objective function.</li> </ul> <p>Warning</p> <p>Call the <code>solve</code> method first.</p> Source code in <code>flowpaths/minerrorflow.py</code> <pre><code>def get_solution(self):\n    \"\"\"\n    Returns the solution to the problem, if the model was solved, as a dictionary containing the following keys:\n\n    - `graph`: the corrected graph, as a networkx DiGraph.\n    - `error`: the error of the solution, i.e. the sum of the absolute differences between the original weights and the corrected weights.\n    - `objective_value`: the value of the objective function.\n\n    !!! warning \"Warning\"\n        Call the `solve` method first.\n    \"\"\"\n    if self._solution is not None:\n        return self._solution\n\n    self._check_is_solved()\n\n    edge_sol_dict = self.solver.get_values(self.edge_vars)\n    for edge in edge_sol_dict.keys():\n        self.edge_sol[edge] = (\n            round(edge_sol_dict[edge])\n            if self.weight_type == int\n            else float(edge_sol_dict[edge])\n        )\n\n    edge_error_sol_dict = self.solver.get_values(self.edge_error_vars)\n    error = sum(edge_error_sol_dict.values())\n\n    corrected_graph = deepcopy(self.original_graph_copy)\n    for u, v in corrected_graph.edges():\n        if self.flow_attr in corrected_graph[u][v]:\n            corrected_graph[u][v][self.flow_attr] = self.edge_sol[(u, v)]\n\n    if self.flow_attr_origin == \"edge\":\n        self._solution = {\n            \"graph\": corrected_graph,\n            \"error\": error,\n            \"objective_value\": self.solver.get_objective_value(),\n        }\n    elif self.flow_attr_origin == \"node\":\n        self._solution = {\n            \"graph\": corrected_graph.get_condensed_graph(),\n            \"error\": error,\n            \"objective_value\": self.solver.get_objective_value(),\n        }\n\n    return self._solution  \n</code></pre>"},{"location":"minimum-error-flow.html#flowpaths.minerrorflow.MinErrorFlow.is_solved","title":"is_solved","text":"<pre><code>is_solved()\n</code></pre> <p>Returns <code>True</code> if the model was solved, <code>False</code> otherwise.</p> Source code in <code>flowpaths/minerrorflow.py</code> <pre><code>def is_solved(self):\n    \"\"\"\n    Returns `True` if the model was solved, `False` otherwise.\n    \"\"\"\n    return self._is_solved\n</code></pre>"},{"location":"minimum-error-flow.html#flowpaths.minerrorflow.MinErrorFlow.solve","title":"solve","text":"<pre><code>solve()\n</code></pre> <p>Solves the problem. Returns <code>True</code> if the model was solved, <code>False</code> otherwise.</p> Source code in <code>flowpaths/minerrorflow.py</code> <pre><code>def solve(self):\n    \"\"\"\n    Solves the problem. Returns `True` if the model was solved, `False` otherwise.\n    \"\"\"\n    utils.logger.info(f\"{__name__}: solving with graph id = {utils.fpid(self.G)}\")\n    start_time = time.perf_counter()\n    self.solver.optimize()\n    self.solve_statistics[f\"milp_solve_time\"] = (time.perf_counter() - start_time)\n\n    self.solve_statistics[f\"milp_solver_status\"] = self.solver.get_model_status()\n\n    if self.solver.get_model_status() == \"kOptimal\":\n        if self.different_flow_values_epsilon is None:\n            self._is_solved = True\n            utils.logger.info(f\"{__name__}: model solved with objective value = {self.solver.get_objective_value()}\")\n            return True\n        else:\n            # We need to encode the different flow values variant\n            objective_value = self.solver.get_objective_value()\n\n            # If the objective value is 0, then we can stop here\n            # because we cannot get a different solution\n            if objective_value == 0:\n                self._is_solved = True\n                utils.logger.info(f\"{__name__}: model solved with objective value = {objective_value}. We could not find change the flow values because the objective function was 0.\")\n                return True\n\n            self._is_solved = True # START hack to get the corrected graph                \n            corrected_graph = self.get_corrected_graph()\n            self._is_solved = False # END hack to get the corrected graph\n\n            # Pick 30 random edges of G.edges()\n            edge_subset = [e for e in self.original_graph_copy.edges()]\n            # edge_subset = edge_subset[:30]        \n\n            # Getting all the different 'flow_attr' values in the corrected graph\n            ub_different_flow_values = len(set(\n                corrected_graph[u][v].get(self.flow_attr, 0)\n                for (u, v) in edge_subset\n            ))\n\n            utils.logger.info(f\"{__name__}: re-solving now by minimizing the number of different flow values within 1 + epsilon tolerance to the objective value, i.e. &lt;=(1+{self.different_flow_values_epsilon})*{objective_value}\")\n            self._create_solver()\n            self._encode_flow()\n            self._encode_different_flow_values_and_objective(\n                edge_subset=edge_subset,\n                objective_value=objective_value,\n                ub_different_flow_values=ub_different_flow_values,\n            )\n            self.solver.optimize()\n            self.solve_statistics[f\"milp_solve_time\"] += (time.perf_counter() - start_time)\n            self.solve_statistics[f\"milp_solver_status\"] = self.solver.get_model_status()\n\n            if self.solver.get_model_status() == \"kOptimal\":\n                self._is_solved = True\n                utils.logger.info(f\"{__name__}: model solved with objective value = {objective_value}\")\n                return True\n            else:\n                utils.logger.warning(f\"{__name__}: model not solved, status = {self.solver.get_model_status()}\")\n\n    self._is_solved = False\n    return False\n</code></pre>"},{"location":"minimum-flow-decomposition-cycles.html","title":"Minimum Flow Decomposition","text":"<p>See also</p> <ul> <li>k-Flow Decomposition in General Graphs</li> <li>Minimum Flow Decomposition in Acyclic Graphs</li> </ul>"},{"location":"minimum-flow-decomposition-cycles.html#minimum-flow-decomposition-in-general-graphs","title":"Minimum Flow Decomposition in General Graphs","text":""},{"location":"minimum-flow-decomposition-cycles.html#1-definition","title":"1. Definition","text":"<p>The Minimum Flow Decomposition problem on a directed graph (possibly with cycles) is defined as follows. For a walk \\(W\\) and an edge \\((u,v)\\), we denote by \\(W(u,v)\\) the number of times that the walk goes through the edge \\((u,v)\\). If \\(W(u,v)\\) does not contain \\((u,v)\\) , then \\(W(u,v) = 0\\).</p> <ul> <li> <p>INPUT: </p> <ul> <li>A directed graph \\(G = (V,E)\\).</li> <li>Node subsets \\(S \\subseteq V\\) and \\(T \\subseteq V\\), where the walks are allowed to start and allowed to end, respectively.</li> <li>A flow on \\(G\\), namely weights \\(f(u,v)\\) for every edge \\((u,v)\\) of \\(G\\), such that for every node \\(v\\) that is not in \\(S\\) or \\(T\\), it holds that the sum of the flow values entering \\(v\\) equals the sum of the flow values exiting \\(v\\). This property is called flow conservation. </li> <li>Note that for flow conservation to hold, all graph sources (i.e. nodes without incoming edges) must be in \\(S\\), and all graph sinks (i.e. nodes without outgoing edges) must be in \\(T\\).</li> </ul> </li> <li> <p>OUTPUT: A minimum number \\(k\\) of walks \\(W_1,\\dots,W_k\\), starting in some node in \\(S\\) and ending in some node in \\(T\\), and a weight \\(w_i\\) associated to each \\(W_i\\), such that for every edge of the graph it holds that its flow value equals the sum of the weights of the walks going through the edge. Formally,  $$ f(u,v) = \\sum_{i \\in \\{1,\\dots,k\\}}w_i \\cdot W_i(u,v), ~~\\forall (u,v) \\in E. $$</p> </li> </ul> <p>Note</p> <ul> <li>This class support also graphs with flow values on nodes. Set the parameter <code>flow_attr_origin = \"node\"</code>. For details on how these are handled internally, see Handling graphs with flows / weights on nodes.</li> <li>The graph may have more than one source or sink nodes, in which case the solution paths are just required to start in any source node, and end in any sink node.</li> </ul> <p>For example, the directed graph below satisfies the flow conservation property, with \\(S = \\{s\\}\\) and \\(T = \\{t\\}\\): <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    e((e))\n    f((f))\n    g((g))\n    h((h))\n    t((t))\n    s --&gt;|3| a\n    a --&gt;|3| t\n    s --&gt;|6| b\n    b --&gt;|2| a\n    a --&gt;|2| h\n    h --&gt;|6| t\n    b --&gt;|4| c\n    c --&gt;|4| h\n    c --&gt;|4| d\n    d --&gt;|4| e\n    e --&gt;|4| c\n    e --&gt;|8| f\n    f --&gt;|8| g\n    g --&gt;|8| e</code></pre></p> <p>A decomposition into 3 walks, in red, orange and blue, of weights 4, 3 and 2, respectively is shown below. There is no decomposition into a smaller number of \\(s\\)-\\(t\\) walks, and thus this decomposition is also a minimum flow decomposition.</p> <p>Note that the orange and blue walks do not repeat nodes or edges (they are paths), but the red walk \\(s\\), \\(b\\), \\(c\\), \\(d\\), \\(e\\), \\(f\\), \\(g\\), \\(e\\), \\(f\\), \\(g\\), \\(e\\), \\(c\\), \\(h\\), \\(t\\) is a proper walks in the sense that repeats both nodes and edges. <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    e((e))\n    f((f))\n    g((g))\n    h((h))\n    t((t))\n    s --&gt;|3| a\n    a --&gt;|3| t\n    s --&gt;|2| b\n    s --&gt;|4| b\n    b --&gt;|2| a\n    a --&gt;|2| h\n    h --&gt;|2| t\n    h --&gt;|4| t\n    b --&gt;|4| c\n    c --&gt;|4| h\n    c --&gt;|4| d\n    d --&gt;|4| e\n    e --&gt;|4| c\n    e --&gt;|4| f\n    f --&gt;|4| g\n    g --&gt;|4| e\n    e --&gt;|4| f\n    f --&gt;|4| g\n    g --&gt;|4| e\n    linkStyle 0,1 stroke:orange,stroke-width:3;\n    linkStyle 2,4,5,6 stroke:blue,stroke-width:3;\n    linkStyle 3,7,8,9,10,11,12,13,14,15,16,17,18 stroke:red,stroke-width:3;</code></pre></p>"},{"location":"minimum-flow-decomposition-cycles.html#2-solving-the-problem","title":"2. Solving the problem","text":"<p>We create the graph as a networkx DiGraph. In a real project, you will likely have a method that transforms your graph to a networkx DiGraph. We also give an attribute <code>flow</code> for every edge storing its flow value.</p> <p><pre><code>import flowpaths as fp\nimport networkx as nx\n\ngraph = nx.DiGraph()\ngraph.add_edge(\"s\", \"a\", flow=3)\ngraph.add_edge(\"a\", \"t\", flow=3)\ngraph.add_edge(\"s\", \"b\", flow=6)\ngraph.add_edge(\"b\", \"a\", flow=2)\ngraph.add_edge(\"a\", \"h\", flow=2)\ngraph.add_edge(\"h\", \"t\", flow=6)\ngraph.add_edge(\"b\", \"c\", flow=4)\ngraph.add_edge(\"c\", \"d\", flow=4)\ngraph.add_edge(\"c\", \"h\", flow=4)\ngraph.add_edge(\"d\", \"h\", flow=0)\ngraph.add_edge(\"d\", \"e\", flow=4)\ngraph.add_edge(\"e\", \"c\", flow=4)\ngraph.add_edge(\"e\", \"f\", flow=8)\ngraph.add_edge(\"f\", \"g\", flow=8)\ngraph.add_edge(\"g\", \"e\", flow=8)\n</code></pre> We now create a Minimum Flow Decomposition solver with default settings, by specifying that the flow value of each edge is in the attribute <code>flow</code> of the edges. Note that <code>MinFlowDecompCycles</code> just creates the model. You need to call <code>solve()</code> to solve it.</p> <pre><code>mfd_model = fp.MinFlowDecompCycles(G=graph, flow_attr=\"flow\")\nmfd_model.solve()\n</code></pre> <p>The model might not be solved because the MILP solver couldn\u2019t do it in the time it had allocated, or other problems. Thus, you need to check if it was solved, and then get its solution. The solution of <code>MinFlowDecompCycles</code> is a dictionary, with a key <code>'walks'</code>, and a key <code>'weights'</code>:</p> <pre><code>if mfd_model.is_solved():\n    solution = mfd_model.get_solution()\n    print(solution)\n    # {'walks': [\n    #   ['s', 'b', 'c', 'd', 'e', 'f', 'g', 'e', 'f', 'g', 'e', 'c', 'h', 't'], \n    #   ['s', 'a', 't'], \n    #   ['s', 'b', 'a', 'h', 't']]\n    # 'weights': [4, 3, 2]}\n</code></pre>"},{"location":"minimum-flow-decomposition-cycles.html#3-references","title":"3. References","text":"<p>There are several works on this problem, for example.</p> <ol> <li> <p>Vatinlen, Benedicte, et al. Simple bounds and greedy algorithms for decomposing a flow into a minimal set of paths. European Journal of Operational Research 185.3 (2008): 1390-1401.</p> </li> <li> <p>Fernando H. C. Dias, Lucia Williams, Brendan Mumey, Alexandru I. Tomescu Minimum Flow Decomposition in Graphs with Cycles using Integer Linear Programming, arXiv, 2022</p> </li> <li> <p>Francisco Sena, Alexandru I. Tomescu Fast and Flexible Flow Decompositions in General Graphs via Dominators, arXiv, 2025</p> </li> <li> <p>See also flowpaths References, and the other papers cited by these works.</p> </li> </ol>"},{"location":"minimum-flow-decomposition-cycles.html#flowpaths.minflowdecompcycles.MinFlowDecompCycles","title":"MinFlowDecompCycles","text":"<pre><code>MinFlowDecompCycles(\n    G: DiGraph,\n    flow_attr: str,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = int,\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1.0,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = {},\n    solver_options: dict = {},\n)\n</code></pre> <p>               Bases: <code>AbstractWalkModelDiGraph</code></p> <p>A class to decompose a network flow if a general directed graph into a minimum number of weighted s-t walks.</p>"},{"location":"minimum-flow-decomposition-cycles.html#flowpaths.minflowdecompcycles.MinFlowDecompCycles--parameters","title":"Parameters","text":"<ul> <li> <p><code>G : nx.DiGraph</code></p> <p>The input directed graph, as networkx DiGraph, possibly with cycles.</p> </li> <li> <p><code>flow_attr : str</code></p> <p>The attribute name from where to get the flow values on the edges.</p> </li> <li> <p><code>flow_attr_origin : str</code>, optional</p> <p>The origin of the flow attribute. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: the flow attribute is assumed to be on the edges of the graph.</li> <li><code>\"node\"</code>: the flow attribute is assumed to be on the nodes of the graph. See the documentation on how node-weighted graphs are handled.</li> </ul> </li> <li> <p><code>weight_type : type</code>, optional</p> <p>The type of weights (<code>int</code> or <code>float</code>). Default is <code>int</code>.</p> </li> <li> <p><code>subset_constraints : list</code>, optional</p> <p>List of subset constraints. Default is an empty list.  Each subset constraint is a list of edges that must be covered by some solution walks, in any order, according  to the <code>subset_constraints_coverage</code> parameter (see below).</p> </li> <li> <p><code>subset_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subset constraints that must be covered by some solution walk. </p> <p>Defaults to <code>1.0</code>, meaning that 100% of the edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) of the constraint need to be covered by some solution walk). See subset constraints documentation</p> </li> <li> <p><code>elements_to_ignore : list</code>, optional</p> <p>List of edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) to ignore when adding constrains on flow explanation by the weighted walks.  Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>additional_starts: list</code>, optional</p> <p>List of additional start nodes of the walks. Default is an empty list. See additional start/end nodes documentation.</p> </li> <li> <p><code>additional_ends: list</code>, optional</p> <p>List of additional end nodes of the walks. Default is an empty list. See additional start/end nodes documentation.</p> </li> <li> <p><code>optimization_options : dict</code>, optional</p> <p>Dictionary with the optimization options. Default is an empty dict. See optimization options documentation.</p> </li> <li> <p><code>solver_options : dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>{}</code>. See solver options documentation.</p> </li> </ul>"},{"location":"minimum-flow-decomposition-cycles.html#flowpaths.minflowdecompcycles.MinFlowDecompCycles--raises","title":"Raises","text":"<p><code>ValueError</code></p> <ul> <li>If <code>weight_type</code> is not <code>int</code> or <code>float</code>.</li> <li>If some edge does not have the flow attribute specified as <code>flow_attr</code>.</li> <li>If the graph does not satisfy flow conservation on nodes different from source or sink.</li> <li>If the graph contains edges with negative (&lt;0) flow values.</li> <li>If <code>flow_attr_origin</code> is not \u201cnode\u201d or \u201cedge\u201d.</li> </ul> Source code in <code>flowpaths/minflowdecompcycles.py</code> <pre><code>def __init__(\n    self,\n    G: nx.DiGraph,\n    flow_attr: str,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = int,\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1.0,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = {},\n    solver_options: dict = {},\n):\n    \"\"\"\n    Parameters\n    ----------\n    - `G : nx.DiGraph`\n\n        The input directed graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html), possibly with cycles.\n\n    - `flow_attr : str`\n\n        The attribute name from where to get the flow values on the edges.\n\n    - `flow_attr_origin : str`, optional\n\n        The origin of the flow attribute. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: the flow attribute is assumed to be on the edges of the graph.\n        - `\"node\"`: the flow attribute is assumed to be on the nodes of the graph. See [the documentation](node-expanded-digraph.md) on how node-weighted graphs are handled.\n\n    - `weight_type : type`, optional\n\n        The type of weights (`int` or `float`). Default is `int`.\n\n    - `subset_constraints : list`, optional\n\n        List of subset constraints. Default is an empty list. \n        Each subset constraint is a list of edges that must be covered by some solution walks, in any order, according \n        to the `subset_constraints_coverage` parameter (see below).\n\n    - `subset_constraints_coverage: float`, optional\n\n        Coverage fraction of the subset constraints that must be covered by some solution walk. \n\n        Defaults to `1.0`, meaning that 100% of the edges (or nodes, if `flow_attr_origin` is `\"node\"`) of\n        the constraint need to be covered by some solution walk).\n        See [subset constraints documentation](subset-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `elements_to_ignore : list`, optional\n\n        List of edges (or nodes, if `flow_attr_origin` is `\"node\"`) to ignore when adding constrains on flow explanation by the weighted walks. \n        Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `additional_starts: list`, optional\n\n        List of additional start nodes of the walks. Default is an empty list. See [additional start/end nodes documentation](additional-start-end-nodes.md).\n\n    - `additional_ends: list`, optional\n\n        List of additional end nodes of the walks. Default is an empty list. See [additional start/end nodes documentation](additional-start-end-nodes.md).\n\n    - `optimization_options : dict`, optional\n\n        Dictionary with the optimization options. Default is an empty dict. See [optimization options documentation](solver-options-optimizations.md).\n\n    - `solver_options : dict`, optional\n\n        Dictionary with the solver options. Default is `{}`. See [solver options documentation](solver-options-optimizations.md).\n\n    Raises\n    ------\n    `ValueError`\n\n    - If `weight_type` is not `int` or `float`.\n    - If some edge does not have the flow attribute specified as `flow_attr`.\n    - If the graph does not satisfy flow conservation on nodes different from source or sink.\n    - If the graph contains edges with negative (&lt;0) flow values.\n    - If `flow_attr_origin` is not \"node\" or \"edge\".\n    \"\"\"\n\n    # Handling node-weighted graphs\n    self.flow_attr_origin = flow_attr_origin\n    if self.flow_attr_origin == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n        if len(additional_starts) + len(additional_ends) == 0:\n            self.G_internal = nedg.NodeExpandedDiGraph(\n                G=G, \n                node_flow_attr=flow_attr\n            )\n        else:\n            self.G_internal = nedg.NodeExpandedDiGraph(\n                G=G, \n                node_flow_attr=flow_attr,\n                additional_starts=additional_starts,\n                additional_ends=additional_ends,\n            )\n        subset_constraints_internal = self.G_internal.get_expanded_subpath_constraints(subset_constraints)\n        additional_starts_internal = self.G_internal.get_expanded_additional_starts(additional_starts)\n        additional_ends_internal = self.G_internal.get_expanded_additional_ends(additional_ends)\n\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        if not all(isinstance(element_to_ignore, str) for element_to_ignore in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n        edges_to_ignore_internal = list(set(edges_to_ignore_internal))\n\n    elif self.flow_attr_origin == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n        if len(additional_starts) + len(additional_ends) &gt; 0:\n            utils.logger.error(f\"additional_starts and additional_ends are not supported when flow_attr_origin is 'edge'.\")\n            raise ValueError(f\"additional_starts and additional_ends are not supported when flow_attr_origin is 'edge'.\")\n        self.G_internal = G\n        subset_constraints_internal = subset_constraints\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n        additional_starts_internal = additional_starts\n        additional_ends_internal = additional_ends\n\n    else:\n        utils.logger.error(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n        raise ValueError(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n\n    self.G = self.G_internal\n    self.subset_constraints = subset_constraints_internal\n    self.edges_to_ignore = edges_to_ignore_internal\n    self.additional_starts = additional_starts_internal\n    self.additional_ends = additional_ends_internal\n\n    self.flow_attr = flow_attr\n    self.weight_type = weight_type\n    self.subset_constraints_coverage = subset_constraints_coverage\n    self.optimization_options = optimization_options\n    self.solver_options = solver_options\n    self.time_limit = self.solver_options.get(\"time_limit\", sw.SolverWrapper.time_limit)\n    self.solve_time_start = None\n    self.solve_time_ilp_total = 0\n\n    self.solve_statistics = {}\n    self._solution = None\n    self._lowerbound_k = None\n    self._is_solved = False\n\n    # Get the max flow value on an edge\n    self.w_max = max(self.G.edges[edge][self.flow_attr] \n                      for edge in self.G.edges \n                      if self.flow_attr in self.G.edges[edge]\n                      and edge not in self.edges_to_ignore) if self.G.number_of_edges() &gt; 0 else 0\n\n    # Internal variables\n    self._generating_set = None\n    self._given_weights_model = None\n    self._mingenset_model = None\n    self._source_flow = None\n\n    utils.logger.info(f\"{__name__}: initialized with graph id = {utils.fpid(G)}\")\n</code></pre>"},{"location":"minimum-flow-decomposition-cycles.html#flowpaths.minflowdecompcycles.MinFlowDecompCycles.get_solution","title":"get_solution","text":"<pre><code>get_solution()\n</code></pre> <p>Retrieves the solution for the flow decomposition problem.</p>"},{"location":"minimum-flow-decomposition-cycles.html#flowpaths.minflowdecompcycles.MinFlowDecompCycles.get_solution--returns","title":"Returns","text":"<ul> <li> <p><code>solution: dict</code></p> <p>A dictionary containing the solution walks (key <code>\"walks\"</code>) and their corresponding weights (key <code>\"weights\"</code>).</p> </li> </ul>"},{"location":"minimum-flow-decomposition-cycles.html#flowpaths.minflowdecompcycles.MinFlowDecompCycles.get_solution--raises","title":"Raises","text":"<ul> <li><code>exception</code> If model is not solved.</li> </ul> Source code in <code>flowpaths/minflowdecompcycles.py</code> <pre><code>def get_solution(self):\n    \"\"\"\n    Retrieves the solution for the flow decomposition problem.\n\n    Returns\n    -------\n    - `solution: dict`\n\n        A dictionary containing the solution walks (key `\"walks\"`) and their corresponding weights (key `\"weights\"`).\n\n    Raises\n    -------\n    - `exception` If model is not solved.\n    \"\"\"\n    self.check_is_solved()\n    return self._solution\n</code></pre>"},{"location":"minimum-flow-decomposition-cycles.html#flowpaths.minflowdecompcycles.MinFlowDecompCycles.solve","title":"solve","text":"<pre><code>solve() -&gt; bool\n</code></pre> <p>Attempts to solve the flow decomposition problem using a model with varying number of walks.</p> <p>This method iterates over a range of possible walk numbers, creating and solving a flow decomposition model for each count. If a solution is found, it stores the solution and relevant statistics, and returns True. If no solution is found after iterating through all possible walk numbers, it returns False.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution is found, False otherwise.</p> Note <p>This overloads the <code>solve()</code> method from <code>AbstractWalkModelDiGraph</code> class.</p> Source code in <code>flowpaths/minflowdecompcycles.py</code> <pre><code>def solve(self) -&gt; bool:\n    \"\"\"\n    Attempts to solve the flow decomposition problem using a model with varying number of walks.\n\n    This method iterates over a range of possible walk numbers, creating and solving a flow decomposition model for each count.\n    If a solution is found, it stores the solution and relevant statistics, and returns True. If no solution is found after\n    iterating through all possible walk numbers, it returns False.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n\n    Note:\n        This overloads the `solve()` method from `AbstractWalkModelDiGraph` class.\n    \"\"\"\n    self.solve_time_start = time.perf_counter()\n    utils.logger.info(f\"{__name__}: starting to solve the MinFlowDecompCycles model for graph id = {utils.fpid(self.G)}\")\n\n    if self.optimization_options.get(\"optimize_with_guessed_weights\", MinFlowDecompCycles.optimize_with_given_weights):            \n        self._solve_with_given_weights()\n\n    for i in range(self.get_lowerbound_k(), self.G.number_of_edges()):\n        utils.logger.info(f\"{__name__}: solving with k = {i}\")\n        fd_model = None\n        # Checking if we have already found a solution with the same number of walks\n        # via the min gen set and given weights approach\n        if self._given_weights_model is not None and self._given_weights_model.is_solved():\n            if len(self._given_weights_model.get_solution(remove_empty_walks=True)[\"walks\"]) == i:\n                fd_model = self._given_weights_model\n\n        if fd_model is None:\n            fd_solver_options = copy.deepcopy(self.solver_options)\n            fd_solver_options[\"time_limit\"] = self.time_limit - self.solve_time_elapsed\n            fd_model = kflowdecompcycles.kFlowDecompCycles(\n                G=self.G,\n                flow_attr=self.flow_attr,\n                k=i,\n                weight_type=self.weight_type,\n                subset_constraints=self.subset_constraints,\n                subset_constraints_coverage=self.subset_constraints_coverage,\n                elements_to_ignore=self.edges_to_ignore,\n                additional_starts=self.additional_starts,\n                additional_ends=self.additional_ends,\n                optimization_options=self.optimization_options,\n                solver_options=fd_solver_options,\n            )\n            fd_model.solve()\n\n        self.solve_statistics = fd_model.solve_statistics\n        self.solve_time_ilp_total += self.solve_statistics.get(\"solve_time_ilp\", 0)\n        self.solve_statistics[\"solve_time\"] = self.solve_time_elapsed\n        self.solve_statistics[\"solve_time_ilp\"] = self.solve_time_ilp_total\n        self.solve_statistics[\"min_gen_set_solve_time\"] = self._mingenset_model.solve_statistics.get(\"total_solve_time\", 0) if self._mingenset_model is not None else 0\n\n        # If the previous run exceeded the time limit, \n        # we still stop the search, even if we might have managed to solve it\n        if self.solve_time_elapsed &gt; self.time_limit:\n            return False\n\n        if fd_model.is_solved():\n            self._solution = fd_model.get_solution(remove_empty_walks=True)\n            if self.flow_attr_origin == \"node\":\n                # If the flow_attr_origin is \"node\", we need to convert the solution walks from the expanded graph to walks in the original graph.\n                self._solution[\"_walks_internal\"] = self._solution[\"walks\"]\n                self._solution[\"walks\"] = self.G_internal.get_condensed_paths(self._solution[\"walks\"])\n            self.set_solved()\n            self.fd_model = fd_model\n            return True\n        elif fd_model.solver.get_model_status() == sw.SolverWrapper.infeasible_status:\n            utils.logger.info(f\"{__name__}: model is infeasible for k = {i}\")\n        else:\n            # If the model is not solved and the status is not infeasible,\n            # it means that the solver stopped because of an unexpected termination,\n            # thus we cannot conclude that the model is infeasible.\n            # In this case, we stop the search.\n            return False\n\n    return False\n</code></pre>"},{"location":"minimum-flow-decomposition.html","title":"Minimum Flow Decomposition","text":"<p>See also</p> <ul> <li>k-Flow Decomposition</li> <li>Minimum Flow Decomposition with Cycles</li> </ul>"},{"location":"minimum-flow-decomposition.html#minimum-flow-decomposition","title":"Minimum Flow Decomposition","text":""},{"location":"minimum-flow-decomposition.html#1-definition","title":"1. Definition","text":"<p>The Minimum Flow Decomposition problem on a directed acyclic graph (DAG) is defined as follows:</p> <ul> <li> <p>INPUT: A directed graph \\(G = (V,E)\\), and a flow on \\(G\\), namely weights \\(f(u,v)\\) for every edge \\((u,v)\\) of \\(G\\), such that for every node \\(v\\) that is not a source or sink of \\(G\\), it holds that the sum of the flow values entering \\(v\\) equals the sum of the flow values exiting \\(v\\). This property is called flow conservation. </p> </li> <li> <p>OUTPUT: A minimum number \\(k\\) of source-to-sink paths, \\(P_1,\\dots,P_k\\), with a weight \\(w_i\\) associated to each \\(P_i\\), such that for every edge it holds that its flow value equals the sum of the weights of the paths going through the edge. Formally,  $$ f(u,v) = \\sum_{i \\in \\{1,\\dots,k\\} : (u,v) \\in P_i }w_i, ~~\\forall (u,v) \\in E. $$</p> </li> </ul> <p>Note</p> <ul> <li>This class support also graphs with flow values on nodes. Set the parameter <code>flow_attr_origin = \"node\"</code>. For details on how these are handled internally, see Handling graphs with flows / weights on nodes.</li> <li>The graph may have more than one source or sink nodes, in which case the solution paths are just required to start in any source node, and end in any sink node.</li> </ul> <p>For example, the directed graph below satisfies the flow conservation property: <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|6| a\n    a --&gt;|2| b\n    s --&gt;|7| b\n    a --&gt;|4| c\n    b --&gt;|9| c\n    c --&gt;|6| d\n    d --&gt;|6| t\n    c --&gt;|7| t</code></pre></p> <p>A decomposition into 3 paths, in red, orange and blue, of weights 4, 2 and 7, respectively is shown below. There is no decomposition into a smaller number of paths, and thus this decomposition is also a minimum flow decomposition. <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|4| a\n    a --&gt;|4| c\n    c --&gt;|4| d\n    d --&gt;|4| t\n    linkStyle 0,1,2,3 stroke:red,stroke-width:3;\n    s --&gt;|2| a\n    a --&gt;|2| b\n    b --&gt;|2| c\n    c --&gt;|2| d\n    d --&gt;|2| t\n    linkStyle 4,5,6,7,8 stroke:orange,stroke-width:3;\n    s --&gt;|7| b\n    b --&gt;|7| c\n    c --&gt;|7| t\n    linkStyle 9,10,11 stroke:blue,stroke-width:3;</code></pre></p>"},{"location":"minimum-flow-decomposition.html#2-solving-the-problem","title":"2. Solving the problem","text":"<p>We create the graph as a networkx DiGraph. In real project, you will likely have a method that transforms your graph to a DiGraph. We also give an attribute <code>flow</code> for every edge storing its flow value.</p> <p><pre><code>import flowpaths as fp\nimport networkx as nx\n\ngraph = nx.DiGraph()\ngraph.add_edge(\"s\", \"a\", flow=6)\ngraph.add_edge(\"s\", \"b\", flow=7)\ngraph.add_edge(\"a\", \"b\", flow=2)\ngraph.add_edge(\"a\", \"c\", flow=4)\ngraph.add_edge(\"b\", \"c\", flow=9)\ngraph.add_edge(\"c\", \"d\", flow=6)\ngraph.add_edge(\"c\", \"t\", flow=7)\ngraph.add_edge(\"d\", \"t\", flow=6)\n</code></pre> We now create a Minimum Flow Decomposition solver with default settings, by specifying that the flow value of each edge is in the attribute <code>flow</code> of the edges. Note that <code>MinFlowDecomp</code> just creates the model. You need to call <code>solve()</code> to solve it.</p> <pre><code>mfd_model = fp.MinFlowDecomp(graph, flow_attr=\"flow\")\nmfd_model.solve()\n</code></pre> <p>The model might not be solved because the MILP solver couldn\u2019t do it in the time it had allocated, or other problems. Thus, you need to check if it was solved, and then get its solution. The solution of <code>MinFlowDecomp</code> is a dictionary, with an key <code>'paths'</code>, and a key <code>'weights'</code>:</p> <pre><code>if mfd_model.is_solved():\n    solution = mfd_model.get_solution()\n    print(solution)\n    # {'paths': [\n    #   ['s', 'b', 'c', 't'], \n    #   ['s', 'a', 'c', 'd', 't'], \n    #   ['s', 'a', 'b', 'c', 'd', 't']], \n    # 'weights': [7, 4, 2]} \n</code></pre>"},{"location":"minimum-flow-decomposition.html#3-references","title":"3. References","text":"<p>There are several works on this problem, for example.</p> <ol> <li> <p>Vatinlen, Benedicte, et al. Simple bounds and greedy algorithms for decomposing a flow into a minimal set of paths. European Journal of Operational Research 185.3 (2008): 1390-1401.</p> </li> <li> <p>Shao, Mingfu, and Carl Kingsford. Theory and a heuristic for the minimum path flow decomposition problem. IEEE/ACM Transactions on Computational Biology and Bioinformatics 16.2 (2017): 658-670.</p> </li> <li> <p>Kloster, Kyle, et al. A practical fpt algorithm for flow decomposition and transcript assembly 2018 Proceedings of the Twentieth Workshop on Algorithm Engineering and Experiments (ALENEX). Society for Industrial and Applied Mathematics, 2018.</p> </li> <li> <p>See also flowpaths References, and the other papers cited by these works.</p> </li> </ol> <p>               Bases: <code>AbstractPathModelDAG</code></p> <p>A class to decompose a network flow if a directed acyclic graph into a minimum number of weighted paths.</p> <p>Initialize the Minimum Flow Decomposition model, minimizing the number of paths.</p>"},{"location":"minimum-flow-decomposition.html#flowpaths.MinFlowDecomp--parameters","title":"Parameters","text":"<ul> <li> <p><code>G : nx.DiGraph</code></p> <p>The input directed acyclic graph, as networkx DiGraph.</p> </li> <li> <p><code>flow_attr : str</code></p> <p>The attribute name from where to get the flow values on the edges.</p> </li> <li> <p><code>flow_attr_origin : str</code>, optional</p> <p>The origin of the flow attribute. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: the flow attribute is assumed to be on the edges of the graph.</li> <li><code>\"node\"</code>: the flow attribute is assumed to be on the nodes of the graph. See the documentation on how node-weighted graphs are handled.</li> </ul> </li> <li> <p><code>weight_type : type</code>, optional</p> <p>The type of weights (<code>int</code> or <code>float</code>). Default is <code>float</code>.</p> </li> <li> <p><code>subpath_constraints : list</code>, optional</p> <p>List of subpath constraints. Default is an empty list.  Each subpath constraint is a list of edges that must be covered by some solution path, according  to the <code>subpath_constraints_coverage</code> or <code>subpath_constraints_coverage_length</code> parameters (see below).</p> </li> <li> <p><code>subpath_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subpath constraints that must be covered by some solution paths. </p> <p>Defaults to <code>1.0</code>, meaning that 100% of the edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) of  the constraint need to be covered by some solution path).  See subpath constraints documentation</p> </li> <li> <p><code>subpath_constraints_coverage_length : float</code>, optional</p> <p>Coverage length of the subpath constraints. Default is <code>None</code>. If set, this overrides <code>subpath_constraints_coverage</code>,  and the coverage constraint is expressed in terms of the subpath constraint length.  <code>subpath_constraints_coverage_length</code> is then the fraction of the total length of the constraint (specified via <code>length_attr</code>) needs to appear in some solution path. See subpath constraints documentation</p> </li> <li> <p><code>length_attr: str</code>, optional</p> <p>The attribute name from where to get the edge lengths (or node length, if <code>flow_attr_origin</code> is <code>\"node\"</code>). Defaults to <code>None</code>.</p> <ul> <li>If set, then the subpath lengths (above) are in terms of the edge/node lengths specified in the <code>length_attr</code> field of each edge/node.</li> <li>If set, and an edge/node has a missing edge length, then it gets length 1.</li> </ul> </li> <li> <p><code>elements_to_ignore : list</code>, optional</p> <p>List of edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) to ignore when adding constrains on flow explanation by the weighted paths.  Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>additional_starts: list</code>, optional</p> <p>List of additional start nodes of the paths. Default is an empty list. See additional start/end nodes documentation. You can set this only if <code>flow_attr_origin</code> is <code>\"node\"</code>.</p> </li> <li> <p><code>additional_ends: list</code>, optional</p> <p>List of additional end nodes of the paths. Default is an empty list. See additional start/end nodes documentation. You can set this only if <code>flow_attr_origin</code> is <code>\"node\"</code>.</p> </li> <li> <p><code>optimization_options : dict</code>, optional</p> <p>Dictionary with the optimization options. Default is an empty dict. See optimization options documentation. This class also supports the optimization <code>\"optimize_with_greedy\": True</code> (this is the default value). This will use a greedy algorithm to solve the problem, and if the number of paths returned by it equals a lowerbound on the solution size, then we know the greedy solution is optimum, and it will use that. The lowerbound used currently is the edge-width of the graph, meaning the minimum number of paths needed to cover all edges. This is a correct lowerbound because any flow decomposition must cover all edges,  as they have non-zero flow.</p> </li> <li> <p><code>solver_options : dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>{}</code>. See solver options documentation.</p> </li> </ul>"},{"location":"minimum-flow-decomposition.html#flowpaths.MinFlowDecomp--raises","title":"Raises","text":"<p><code>ValueError</code></p> <ul> <li>If <code>weight_type</code> is not <code>int</code> or <code>float</code>.</li> <li>If some edge does not have the flow attribute specified as <code>flow_attr</code>.</li> <li>If the graph does not satisfy flow conservation on nodes different from source or sink.</li> <li>If the graph contains edges with negative (&lt;0) flow values.</li> <li>If the graph is not acyclic.</li> <li>If <code>flow_attr_origin</code> is not \u201cnode\u201d or \u201cedge\u201d.</li> </ul> Source code in <code>flowpaths/minflowdecomp.py</code> <pre><code>def __init__(\n    self,\n    G: nx.DiGraph,\n    flow_attr: str,\n    flow_attr_origin: str = \"edge\",\n    weight_type: type = float,\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1.0,\n    subpath_constraints_coverage_length: float = None,\n    length_attr: str = None,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = {},\n    solver_options: dict = {},\n):\n    \"\"\"\n    Initialize the Minimum Flow Decomposition model, minimizing the number of paths.\n\n    Parameters\n    ----------\n    - `G : nx.DiGraph`\n\n        The input directed acyclic graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html).\n\n    - `flow_attr : str`\n\n        The attribute name from where to get the flow values on the edges.\n\n    - `flow_attr_origin : str`, optional\n\n        The origin of the flow attribute. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: the flow attribute is assumed to be on the edges of the graph.\n        - `\"node\"`: the flow attribute is assumed to be on the nodes of the graph. See [the documentation](node-expanded-digraph.md) on how node-weighted graphs are handled.\n\n    - `weight_type : type`, optional\n\n        The type of weights (`int` or `float`). Default is `float`.\n\n    - `subpath_constraints : list`, optional\n\n        List of subpath constraints. Default is an empty list. \n        Each subpath constraint is a list of edges that must be covered by some solution path, according \n        to the `subpath_constraints_coverage` or `subpath_constraints_coverage_length` parameters (see below).\n\n    - `subpath_constraints_coverage: float`, optional\n\n        Coverage fraction of the subpath constraints that must be covered by some solution paths. \n\n        Defaults to `1.0`, meaning that 100% of the edges (or nodes, if `flow_attr_origin` is `\"node\"`) of \n        the constraint need to be covered by some solution path). \n        See [subpath constraints documentation](subpath-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `subpath_constraints_coverage_length : float`, optional\n\n        Coverage length of the subpath constraints. Default is `None`. If set, this overrides `subpath_constraints_coverage`, \n        and the coverage constraint is expressed in terms of the subpath constraint length. \n        `subpath_constraints_coverage_length` is then the fraction of the total length of the constraint (specified via `length_attr`) needs to appear in some solution path.\n        See [subpath constraints documentation](subpath-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `length_attr: str`, optional\n\n        The attribute name from where to get the edge lengths (or node length, if `flow_attr_origin` is `\"node\"`). Defaults to `None`.\n\n        - If set, then the subpath lengths (above) are in terms of the edge/node lengths specified in the `length_attr` field of each edge/node.\n        - If set, and an edge/node has a missing edge length, then it gets length 1.\n\n    - `elements_to_ignore : list`, optional\n\n        List of edges (or nodes, if `flow_attr_origin` is `\"node\"`) to ignore when adding constrains on flow explanation by the weighted paths. \n        Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `additional_starts: list`, optional\n\n        List of additional start nodes of the paths. Default is an empty list. See [additional start/end nodes documentation](additional-start-end-nodes.md). **You can set this only if `flow_attr_origin` is `\"node\"`**.\n\n    - `additional_ends: list`, optional\n\n        List of additional end nodes of the paths. Default is an empty list. See [additional start/end nodes documentation](additional-start-end-nodes.md). **You can set this only if `flow_attr_origin` is `\"node\"`**.\n\n    - `optimization_options : dict`, optional\n\n        Dictionary with the optimization options. Default is an empty dict. See [optimization options documentation](solver-options-optimizations.md).\n        This class also supports the optimization `\"optimize_with_greedy\": True` (this is the default value). This\n        will use a greedy algorithm to solve the problem, and if the number of paths returned by it equals a lowerbound on the solution size,\n        then we know the greedy solution is optimum, and it will use that. The lowerbound used currently is the edge-width of the graph,\n        meaning the minimum number of paths needed to cover all edges. This is a correct lowerbound because any flow decomposition must cover all edges, \n        as they have non-zero flow.\n\n    - `solver_options : dict`, optional\n\n        Dictionary with the solver options. Default is `{}`. See [solver options documentation](solver-options-optimizations.md).\n\n    Raises\n    ------\n    `ValueError`\n\n    - If `weight_type` is not `int` or `float`.\n    - If some edge does not have the flow attribute specified as `flow_attr`.\n    - If the graph does not satisfy flow conservation on nodes different from source or sink.\n    - If the graph contains edges with negative (&lt;0) flow values.\n    - If the graph is not acyclic.\n    - If `flow_attr_origin` is not \"node\" or \"edge\".\n    \"\"\"\n\n    # Handling node-weighted graphs\n    self.flow_attr_origin = flow_attr_origin\n    if self.flow_attr_origin == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n        if len(additional_starts) + len(additional_ends) == 0:\n            self.G_internal = nedg.NodeExpandedDiGraph(\n                G=G, \n                node_flow_attr=flow_attr, \n                node_length_attr=length_attr)\n        else:\n            self.G_internal = nedg.NodeExpandedDiGraph(\n                G=G, \n                node_flow_attr=flow_attr, \n                node_length_attr=length_attr,\n                try_filling_in_missing_flow_attr=True,\n                additional_starts=additional_starts,\n                additional_ends=additional_ends,\n            )\n        subpath_constraints_internal = self.G_internal.get_expanded_subpath_constraints(subpath_constraints)\n\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        if not all(isinstance(element_to_ignore, str) for element_to_ignore in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n        edges_to_ignore_internal = list(set(edges_to_ignore_internal))\n\n    elif self.flow_attr_origin == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n        if len(additional_starts) + len(additional_ends) &gt; 0:\n            utils.logger.error(f\"additional_starts and additional_ends are not supported when flow_attr_origin is 'edge'.\")\n            raise ValueError(f\"additional_starts and additional_ends are not supported when flow_attr_origin is 'edge'.\")\n        self.G_internal = G\n        subpath_constraints_internal = subpath_constraints\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n\n    else:\n        utils.logger.error(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n        raise ValueError(f\"flow_attr_origin must be either 'node' or 'edge', not {self.flow_attr_origin}\")\n\n    self.G = self.G_internal\n    self.subpath_constraints = subpath_constraints_internal\n    self.edges_to_ignore = edges_to_ignore_internal\n\n    self.flow_attr = flow_attr\n    self.weight_type = weight_type\n    self.subpath_constraints_coverage = subpath_constraints_coverage\n    self.subpath_constraints_coverage_length = subpath_constraints_coverage_length\n    self.length_attr = length_attr\n    self.optimization_options = optimization_options\n    self.solver_options = solver_options\n    self.time_limit = self.solver_options.get(\"time_limit\", sw.SolverWrapper.time_limit)\n    self.solve_time_start = None\n\n    self.solve_statistics = {}\n    self._solution = None\n    self._lowerbound_k = None\n    self._is_solved = False\n\n    # Internal variables\n    self._generating_set = None\n    self._all_subgraph_weights = None\n    self._given_weights_model = None\n    self._source_flow = None\n\n    utils.logger.info(f\"{__name__}: initialized with graph id = {utils.fpid(G)}\")\n</code></pre>"},{"location":"minimum-flow-decomposition.html#flowpaths.MinFlowDecomp.get_solution","title":"get_solution","text":"<pre><code>get_solution()\n</code></pre> <p>Retrieves the solution for the flow decomposition problem.</p>"},{"location":"minimum-flow-decomposition.html#flowpaths.MinFlowDecomp.get_solution--returns","title":"Returns","text":"<ul> <li> <p><code>solution: dict</code></p> <p>A dictionary containing the solution paths (key <code>\"paths\"</code>) and their corresponding weights (key <code>\"weights\"</code>).</p> </li> </ul>"},{"location":"minimum-flow-decomposition.html#flowpaths.MinFlowDecomp.get_solution--raises","title":"Raises","text":"<ul> <li><code>exception</code> If model is not solved.</li> </ul> Source code in <code>flowpaths/minflowdecomp.py</code> <pre><code>def get_solution(self):\n    \"\"\"\n    Retrieves the solution for the flow decomposition problem.\n\n    Returns\n    -------\n    - `solution: dict`\n\n        A dictionary containing the solution paths (key `\"paths\"`) and their corresponding weights (key `\"weights\"`).\n\n    Raises\n    -------\n    - `exception` If model is not solved.\n    \"\"\"\n    self.check_is_solved()\n    return self._solution\n</code></pre>"},{"location":"minimum-flow-decomposition.html#flowpaths.MinFlowDecomp.solve","title":"solve","text":"<pre><code>solve() -&gt; bool\n</code></pre> <p>Attempts to solve the flow decomposition problem using a model with varying number of paths.</p> <p>This method iterates over a range of possible path numbers, creating and solving a flow decomposition model for each count. If a solution is found, it stores the solution and relevant statistics, and returns True. If no solution is found after iterating through all possible path counts, it returns False.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution is found, False otherwise.</p> Note <p>This overloads the <code>solve()</code> method from <code>AbstractPathModelDAG</code> class.</p> Source code in <code>flowpaths/minflowdecomp.py</code> <pre><code>def solve(self) -&gt; bool:\n    \"\"\"\n    Attempts to solve the flow decomposition problem using a model with varying number of paths.\n\n    This method iterates over a range of possible path numbers, creating and solving a flow decomposition model for each count.\n    If a solution is found, it stores the solution and relevant statistics, and returns True. If no solution is found after\n    iterating through all possible path counts, it returns False.\n\n    Returns:\n        bool: True if a solution is found, False otherwise.\n\n    Note:\n        This overloads the `solve()` method from `AbstractPathModelDAG` class.\n    \"\"\"\n    self.solve_time_start = time.perf_counter()\n\n    if self.optimization_options.get(\"optimize_with_guessed_weights\", MinFlowDecomp.optimize_with_given_weights):            \n        self._solve_with_given_weights()\n\n    for i in range(self.get_lowerbound_k(), self.G.number_of_edges()):\n        utils.logger.info(f\"{__name__}: iteration with k = {i}\")\n        fd_model = None\n        # Checking if we have already found a solution with the same number of paths\n        # via the min gen set and given weights approach\n        if self._given_weights_model is not None and self._given_weights_model.is_solved():\n            if len(self._given_weights_model.get_solution(remove_empty_paths=True)[\"paths\"]) == i:\n                fd_model = self._given_weights_model\n\n        fd_solver_options = copy.deepcopy(self.solver_options)\n        if \"time_limit\" in fd_solver_options:\n            fd_solver_options[\"time_limit\"] = self.time_limit - self.solve_time_elapsed\n\n        if fd_model is None:\n            fd_model = kflowdecomp.kFlowDecomp(\n                G=self.G,\n                flow_attr=self.flow_attr,\n                k=i,\n                weight_type=self.weight_type,\n                subpath_constraints=self.subpath_constraints,\n                subpath_constraints_coverage=self.subpath_constraints_coverage,\n                subpath_constraints_coverage_length=self.subpath_constraints_coverage_length,\n                length_attr=self.length_attr,\n                elements_to_ignore=self.edges_to_ignore,\n                optimization_options=self.optimization_options,\n                solver_options=fd_solver_options,\n            )\n            fd_model.solve()\n\n        if fd_model.is_solved():\n            self._solution = fd_model.get_solution(remove_empty_paths=True)\n            if self.flow_attr_origin == \"node\":\n                # If the flow_attr_origin is \"node\", we need to convert the solution paths from the expanded graph to paths in the original graph.\n                self._solution[\"_paths_internal\"] = self._solution[\"paths\"]\n                self._solution[\"paths\"] = self.G_internal.get_condensed_paths(self._solution[\"paths\"])\n            self.set_solved()\n            self.solve_statistics = fd_model.solve_statistics\n            self.solve_statistics[\"mfd_solve_time\"] = time.perf_counter() - self.solve_time_start\n            self.fd_model = fd_model\n            return True\n        elif fd_model.solver.get_model_status() != sw.SolverWrapper.infeasible_status:\n            # If the model is not solved and the status is not infeasible,\n            # it means that the solver stopped because of an unexpected termination,\n            # thus we cannot conclude that the model is infeasible.\n            # In this case, we stop the search.\n            return False\n\n    return False\n</code></pre>"},{"location":"minimum-generating-set.html","title":"Minimum Generating Set","text":""},{"location":"minimum-generating-set.html#flowpaths.mingenset.MinGenSet","title":"MinGenSet","text":"<pre><code>MinGenSet(\n    numbers: list,\n    total: int | float,\n    weight_type: Type[\n        int | float\n    ] = float,\n    max_multiplicity: int = 1,\n    lowerbound: int = 1,\n    partition_constraints: (\n        list | None\n    ) = None,\n    remove_complement_values: bool = True,\n    remove_sums_of_two: bool = False,\n    solver_options: dict = {},\n)\n</code></pre> <p>This class solves the minimum generating set problem. Given a list of numbers <code>a</code> and a total value <code>total</code>,  the goal is to find the smallest list of numbers <code>generating_set</code> such that:</p> <ul> <li>the sum of the elements in <code>generating_set</code> equals <code>total</code>, and</li> <li>every element in <code>a</code> can be expressed as the sum of some elements in <code>generating_set</code>.</li> </ul> <p>This class solves a more general problem, in which we are also given <code>max_multiplicity</code>,  the maximum number of times each element in <code>generating_set</code> can be used to represent elements in <code>a</code>.</p>"},{"location":"minimum-generating-set.html#flowpaths.mingenset.MinGenSet--parameters","title":"Parameters","text":"<ul> <li> <p><code>a</code> : list</p> <p>A list of numbers.</p> </li> <li> <p><code>total</code> : int | float</p> <p>The total value that the sum of the elements in the generating set should equal.</p> </li> <li> <p><code>weight_type</code> : type</p> <p>The type of the numbers in <code>generating_set</code>. Default is <code>float</code>. The other option is <code>int</code>.</p> </li> <li> <p><code>max_multiplicity</code> : int</p> <p>The maximum number of times each element in the generating set can be used to represent elements in <code>a</code>. Default is 1.</p> </li> <li> <p><code>lowerbound</code> : int</p> <p>The minimum number of elements in the generating set. Default is 1.</p> </li> <li> <p><code>partition_constraints</code> : list</p> <p>A list of lists, where each inner list is made up of numbers, such that the sum of the numbers in each inner list is equal to <code>total</code>. That is, each inner list is a number partition of <code>total</code>. These constraints are imposed as: - each number in an inner list must be obtained by summing up a subset of numbers in the generating set, and - each number in the generating set must be used exactly once to obtain the numbers in the inner list.</p> <p>You cannot set this if <code>max_multiplicity &gt; 1</code>.</p> </li> <li> <p><code>remove_complement_values</code> : bool</p> <p>If <code>True</code>, if <code>a</code> contains both <code>x</code> and <code>total - x</code>, it keeps only the smallest of them. Default is <code>True</code>. This is always correct to do. If say the generating set is \\(g_1, g_2, g_3, g_4\\), with \\(g_1 + g_2 + g_3 + g_4 = total\\). If \\(x = g_1 + g_3\\), then \\(total - x = g_2 + g_4\\). So \\(total - x\\) is expressed as a sum of values in the generating set.</p> </li> <li> <p><code>remove_sums_of_two</code> : bool</p> <p>If <code>True</code>, it removes elements from <code>a</code> that are the sum of two other elements in <code>a</code>. Default is <code>False</code>. This is not always correct to do, as it might lead to a smaller generating set. For example, suppose the generating set is \\(g_1, g_2, g_3, g_4\\), with \\(g_1\\) different from \\(g_4\\)  Suppose \\(x = g_1 + g_2\\), \\(y = g_1 + g_3\\) and \\(x+y \\in a\\). Then \\(x+y\\) is expressed as \\(2 g_1 + g_2 + g_3\\),  thus it needs repeating \\(g_1\\) twice. So \\(x+y\\) cannot be expressed as a sum of elements in the generating set. </p> <p>You cannot set this to <code>True</code> if <code>max_multiplicity &gt; 1</code>.</p> <p>Note</p> <p>Setting this to <code>True</code> always gives a generating set smaller or of the same size (i.e., not larger) as setting it to <code>False</code>.  Thus, the size of the former generating set can be used as a lower bound for the size of the latter generating set.</p> </li> <li> <p><code>solver_options : dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>{}</code>. See solver options documentation.</p> </li> </ul> Source code in <code>flowpaths/mingenset.py</code> <pre><code>def __init__(\n        self, \n        numbers: list,\n        total: Union[int, float],\n        weight_type: Type[Union[int, float]] = float,\n        max_multiplicity: int = 1,\n        lowerbound: int = 1,\n        partition_constraints: Optional[list] = None,\n        remove_complement_values: bool = True,\n        remove_sums_of_two: bool = False,\n        solver_options: dict = {}\n        ):\n    \"\"\"\n    This class solves the minimum generating set problem. Given a list of numbers `a` and a total value `total`, \n    the goal is to find the smallest list of numbers `generating_set` such that:\n\n    - the sum of the elements in `generating_set` equals `total`, and\n    - every element in `a` can be expressed as the sum of some elements in `generating_set`.\n\n    This class solves a more general problem, in which we are also given `max_multiplicity`, \n    the maximum number of times each element in `generating_set` can be used to represent elements in `a`.\n\n    Parameters\n    ----------\n\n    - `a` : list\n\n        A list of numbers.\n\n    - `total` : int | float\n\n        The total value that the sum of the elements in the generating set should equal.\n\n    - `weight_type` : type\n\n        The type of the numbers in `generating_set`. Default is `float`. The other option is `int`.\n\n    - `max_multiplicity` : int\n\n        The maximum number of times each element in the generating set can be used to represent elements in `a`. Default is 1.\n\n    - `lowerbound` : int\n\n        The minimum number of elements in the generating set. Default is 1.\n\n    - `partition_constraints` : list\n\n        A list of lists, where each inner list is made up of numbers, such that the sum of the numbers in each inner list is equal to `total`.\n        That is, each inner list is a number partition of `total`.\n        These constraints are imposed as:\n        - each number in an inner list must be obtained by summing up a subset of numbers in the generating set, and\n        - each number in the generating set must be used exactly once to obtain the numbers in the inner list.\n\n        You cannot set this if `max_multiplicity &gt; 1`.\n\n    - `remove_complement_values` : bool\n\n        If `True`, if `a` contains both `x` and `total - x`, it keeps only the smallest of them. Default is `True`.\n        This is always correct to do. If say the generating set is $g_1, g_2, g_3, g_4$, with $g_1 + g_2 + g_3 + g_4 = total$.\n        If $x = g_1 + g_3$, then $total - x = g_2 + g_4$. So $total - x$ is expressed as a sum of values in the generating set.\n\n    - `remove_sums_of_two` : bool\n\n        If `True`, it removes elements from `a` that are the sum of two other elements in `a`. Default is `False`.\n        This is not always correct to do, as it might lead to a smaller generating set. For example, suppose the generating set is $g_1, g_2, g_3, g_4$, with $g_1$ different from $g_4$ \n        Suppose $x = g_1 + g_2$, $y = g_1 + g_3$ and $x+y \\in a$. Then $x+y$ is expressed as $2 g_1 + g_2 + g_3$, \n        thus it needs repeating $g_1$ **twice**. So $x+y$ cannot be expressed as a sum of elements in the generating set. \n\n        You cannot set this to `True` if `max_multiplicity &gt; 1`.\n\n        !!! note \"Note\"\n            Setting this to `True` always gives a generating set smaller or of the same size (i.e., not larger) as setting it to `False`. \n            Thus, the size of the former generating set can be used as a lower bound for the size of the latter generating set.\n\n    - `solver_options : dict`, optional\n\n        Dictionary with the solver options. Default is `{}`. See [solver options documentation](solver-options-optimizations.md).\n    \"\"\"\n\n    self.numbers = list(numbers) # Make a copy of the list\n    utils.logger.debug(f\"{__name__}: Initial numbers: {self.numbers}\")\n    self.initial_numbers = numbers\n    self.total = total\n    utils.logger.debug(f\"{__name__}: Generating set sum = {self.total}\")\n    self.weight_type = weight_type\n    self.max_multiplicity = max_multiplicity\n    if self.max_multiplicity &lt; 1:\n        utils.logger.error(f\"{__name__}: `max_multiplicity` must be at least 1.\")\n        raise ValueError(\"`max_multiplicity` must be at least 1.\")\n    self.lowerbound = lowerbound\n    self.partition_constraints = partition_constraints\n    if self.partition_constraints is not None and self.max_multiplicity &gt; 1:\n        utils.logger.error(f\"{__name__}: `partition_constraints` is set, but `max_multiplicity &gt; 1`. This is not allowed.\")\n        raise ValueError(\"`partition_constraints` is not allowed when `max_multiplicity &gt; 1`.\")\n\n    self._is_solved = False\n    self._solution = None\n    self.solver = None\n    self.solve_statistics = {}\n    self.solver_options = solver_options\n\n    if self.weight_type not in [int, float]:\n        utils.logger.error(f\"{__name__}: weight_type must be either `int` or `float`.\")\n        raise ValueError(\"weight_type must be either `int` or `float`.\")\n\n    if self.partition_constraints is not None:\n        if not all(isinstance(constraint, list) for constraint in self.partition_constraints):\n            utils.logger.error(f\"{__name__}: partition_constraints must be a list of lists.\")\n            raise ValueError(\"partition_constraints must be a list of lists.\")        \n        if not all(sum(constraint) == self.total for constraint in self.partition_constraints):\n            utils.logger.error(f\"{__name__}: The sum of the numbers inside each subset constraint must equal the total value.\")\n            raise ValueError(\"The sum of the numbers inside each subset constraint must equal the total value.\")\n\n    if False and remove_sums_of_two:\n        if self.max_multiplicity &gt; 1:\n            utils.logger.error(f\"{__name__}: `remove_sums_of_two` is set to True, but `max_multiplicity &gt; 1`. This is not allowed.\")\n            raise ValueError(\"`remove_sums_of_two` is not allowed when `max_multiplicity &gt; 1`.\")\n\n        elements_to_remove = set()\n        for val1 in self.numbers:\n            for val2 in self.numbers:\n                if val1 + val2 in self.numbers:\n                    elements_to_remove.add(val1 + val2)\n\n        self.numbers = list(set(self.numbers) - elements_to_remove)\n\n    if remove_complement_values:\n        elements_to_remove = set()\n        for val in self.numbers:\n            if total - val in self.numbers and total - val &gt; val:\n                elements_to_remove.add(total - val)\n            if val == total or val == 0:\n                elements_to_remove.add(val)\n\n        self.numbers = list(set(self.numbers) - elements_to_remove)\n\n    utils.logger.debug(f\"{__name__}: Numbers after removing values: {self.numbers}\")\n</code></pre>"},{"location":"minimum-generating-set.html#flowpaths.mingenset.MinGenSet.get_solution","title":"get_solution","text":"<pre><code>get_solution()\n</code></pre> <p>Returns the solution to the minimum generating set problem, if the model was solved. </p> <p>Warning</p> <p>Call the <code>solve</code> method first.</p> Source code in <code>flowpaths/mingenset.py</code> <pre><code>def get_solution(self):\n    \"\"\"\n    Returns the solution to the minimum generating set problem, if the model was solved. \n\n    !!! warning \"Warning\"\n        Call the `solve` method first.\n    \"\"\"\n    if self._solution is not None:\n        return self._solution\n\n    self.check_is_solved()\n\n    return self._solution  \n</code></pre>"},{"location":"minimum-generating-set.html#flowpaths.mingenset.MinGenSet.is_solved","title":"is_solved","text":"<pre><code>is_solved()\n</code></pre> <p>Returns <code>True</code> if the model was solved, <code>False</code> otherwise.</p> Source code in <code>flowpaths/mingenset.py</code> <pre><code>def is_solved(self):\n    \"\"\"\n    Returns `True` if the model was solved, `False` otherwise.\n    \"\"\"\n    if self._is_solved is None:\n        utils.logger.error(f\"{__name__}: Model not yet solved. If you want to solve it, call the `solve` method first.\")\n        raise Exception(\"Model not yet solved. If you want to solve it, call the `solve` method first.\")\n\n    return self._is_solved\n</code></pre>"},{"location":"minimum-generating-set.html#flowpaths.mingenset.MinGenSet.solve","title":"solve","text":"<pre><code>solve()\n</code></pre> <p>Solves the minimum generating set problem. Returns <code>True</code> if the model was solved, <code>False</code> otherwise.</p> Source code in <code>flowpaths/mingenset.py</code> <pre><code>def solve(self):\n    \"\"\"\n    Solves the minimum generating set problem. Returns `True` if the model was solved, `False` otherwise.\n    \"\"\"\n    start_time = time.perf_counter()\n\n    # Solve for increasing numbers of elements in the generating set\n    for k in range(self.lowerbound, max(self.lowerbound+1, len(self.initial_numbers))):\n        self._create_solver(k=k)\n        self.solver.optimize()\n\n        if self.solver.get_model_status() == \"kOptimal\":\n            genset_sol = self.solver.get_values(self.genset_vars)\n            self._solution = sorted(self.weight_type(genset_sol[i]) for i in range(k))\n            self._is_solved = True\n            self.solve_statistics = {\n                \"solve_time\": time.perf_counter() - start_time,\n                \"num_elements\": k,\n                \"status\": self.solver.get_model_status(),\n            }\n            return True\n        else:\n            self.solve_statistics = {\n                \"solve_time\": time.perf_counter() - start_time,\n                \"status\": self.solver.get_model_status(),\n            }\n    return False\n</code></pre>"},{"location":"minimum-path-cover-cycles.html","title":"Minimum Path Cover","text":"<p>See also</p> <ul> <li>Minimum Path Cover in DAGs</li> </ul>"},{"location":"minimum-path-cover-cycles.html#minimum-path-cover-in-general-graphs","title":"Minimum Path Cover in General Graphs","text":""},{"location":"minimum-path-cover-cycles.html#1-definition","title":"1. Definition","text":"<p>The Minimum Path Cover problem on a directed graph, possibly with cycles, is defined as follows:</p> <ul> <li> <p>INPUT: </p> <ul> <li>A directed graph \\(G = (V,E)\\).</li> <li>Node subsets \\(S \\subseteq V\\) and \\(T \\subseteq V\\), where the walks are allowed to start and allowed to end, respectively.</li> </ul> </li> <li> <p>OUTPUT: A minimum number \\(k\\) of walks \\(W_1,\\dots,W_k\\), starting in some node in \\(S\\) and ending in some node in \\(T\\), such that every edge appears in at least one \\(W_i\\).</p> </li> </ul> <p>Note</p> <ul> <li>This class support also covers of nodes. Set the parameter <code>cover_type = \"node\"</code>. For details on how these are handled internally, see Handling graphs with flows / weights on nodes.</li> <li>The graph may have more than one source or sink nodes, in which case the solution paths are just required to start in any source node, and end in any sink node.</li> </ul>"},{"location":"minimum-path-cover-cycles.html#2-solving-the-problem","title":"2. Solving the problem","text":"<p>We create the graph as a networkx DiGraph. In real project, you will likely have a method that transforms your graph to a DiGraph.</p> <pre><code>import flowpaths as fp\nimport networkx as nx\n\ndef test():\n  graph = nx.DiGraph()\n  graph.add_edge(\"s\", \"a\")\n  graph.add_edge(\"a\", \"t\")\n  graph.add_edge(\"s\", \"b\")\n  graph.add_edge(\"b\", \"a\")\n  graph.add_edge(\"a\", \"h\")\n  graph.add_edge(\"h\", \"t\")\n  graph.add_edge(\"b\", \"c\")\n  graph.add_edge(\"c\", \"d\")\n  graph.add_edge(\"c\", \"h\")\n  graph.add_edge(\"d\", \"h\")\n  graph.add_edge(\"d\", \"e\")\n  graph.add_edge(\"e\", \"c\")\n  graph.add_edge(\"e\", \"f\")\n  graph.add_edge(\"f\", \"g\")\n  graph.add_edge(\"g\", \"e\")\n\n  mpc_model = fp.MinPathCoverCycles(G=graph)\n  mpc_model.solve()\n</code></pre> <p>The solution of <code>MinPathCoverCycles</code> is a dictionary, with a key <code>'walks'</code> containing the solution walks:</p> <pre><code>if mpc_model.is_solved():\n    solution = mpc_model.get_solution()\n    print(solution)\n    # {'walks': [\n    #   ['s', 'a', 't'], \n    #   ['s', 'b', 'a', 'h', 't'], \n    #   ['s', 'b', 'c', 'd', 'e', 'f', 'g', 'e', 'c', 'h', 't'], \n    #   ['s', 'b', 'c', 'd', 'h', 't']]}\n</code></pre> <p>We can also support subset constraints:</p> <pre><code>subset_constraints=[[(\"b\", \"a\"),(\"a\", \"t\")]]\nmpc_model_sc = fp.MinPathCover(\n    graph,\n    subset_constraints=subset_constraints,\n)\nmpc_model_sc.solve()\n</code></pre>"},{"location":"minimum-path-cover-cycles.html#flowpaths.minpathcovercycles.MinPathCoverCycles","title":"MinPathCoverCycles","text":"<pre><code>MinPathCoverCycles(\n    G: DiGraph,\n    cover_type: str = \"edge\",\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1.0,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = {},\n    solver_options: dict = {},\n)\n</code></pre> <p>               Bases: <code>AbstractWalkModelDiGraph</code></p> <p>This class finds a minimum number of walks covering the edges of a directed graph, possibly with cycles \u2013 and generalizations of this problem, see the parameters below.</p>"},{"location":"minimum-path-cover-cycles.html#flowpaths.minpathcovercycles.MinPathCoverCycles--parameters","title":"Parameters","text":"<ul> <li> <p><code>G: nx.DiGraph</code></p> <p>The input directed graph, as networkx DiGraph.</p> </li> <li> <p><code>cover_type: str</code>, optional</p> <p>The elements of the graph to cover. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: cover the edges of the graph. This is the default.</li> <li><code>\"node\"</code>: cover the nodes of the graph.</li> </ul> </li> <li> <p><code>subset_constraints: list</code>, optional</p> <p>List of subset constraints. Default is an empty list.  Each subset constraint is a list of edges that must all appear in some solution walks (in any order), according  to the <code>subset_constraints_coverage</code> parameter (see below).</p> </li> <li> <p><code>subset_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subset constraints that must be covered by some solution walks. </p> <p>Defaults to <code>1.0</code>, meaning that 100% of the edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) of  the constraint need to be covered by some solution walk).  See subset constraints documentation</p> </li> <li> <p><code>elements_to_ignore: list</code>, optional</p> <p>List of graph elements to ignore by the solution walks (i.e., these don\u2019t have to be covered, unless they are part of a subset constraint). These elements are either edges or nodes, depending on the <code>cover_type</code> parameter. Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>additional_starts: list</code>, optional</p> <p>List of additional start nodes of the walks. Default is an empty list. See additional start/end nodes documentation.</p> </li> <li> <p><code>additional_ends: list</code>, optional</p> <p>List of additional end nodes of the walks. Default is an empty list. See additional start/end nodes documentation.</p> </li> <li> <p><code>optimization_options: dict</code>, optional</p> <p>Dictionary with the optimization options. Default is <code>None</code>. See optimization options documentation.</p> </li> <li> <p><code>solver_options: dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>None</code>. See solver options documentation.</p> </li> </ul> Source code in <code>flowpaths/minpathcovercycles.py</code> <pre><code>def __init__(\n    self,\n    G: nx.DiGraph,\n    cover_type: str = \"edge\",\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1.0,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = {},\n    solver_options: dict = {},\n):\n    \"\"\"\n    This class finds a minimum number of walks covering the edges of a directed graph, possibly with cycles -- and generalizations of this problem, see the parameters below.\n\n    Parameters\n    ----------\n    - `G: nx.DiGraph`\n\n        The input directed graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html).\n\n    - `cover_type: str`, optional\n\n        The elements of the graph to cover. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: cover the edges of the graph. This is the default.\n        - `\"node\"`: cover the nodes of the graph.\n\n    - `subset_constraints: list`, optional\n\n        List of subset constraints. Default is an empty list. \n        Each subset constraint is a list of edges that must all appear in some solution walks (in any order), according \n        to the `subset_constraints_coverage` parameter (see below).\n\n    - `subset_constraints_coverage: float`, optional\n\n        Coverage fraction of the subset constraints that must be covered by some solution walks. \n\n        Defaults to `1.0`, meaning that 100% of the edges (or nodes, if `flow_attr_origin` is `\"node\"`) of \n        the constraint need to be covered by some solution walk). \n        See [subset constraints documentation](subset-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `elements_to_ignore: list`, optional\n\n        List of graph elements to ignore by the solution walks (i.e., these don't have to be covered, unless they are part of a subset constraint).\n        These elements are either edges or nodes, depending on the `cover_type` parameter.\n        Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `additional_starts: list`, optional\n\n        List of additional start nodes of the walks. Default is an empty list. See [additional start/end nodes documentation](additional-start-end-nodes.md).\n\n    - `additional_ends: list`, optional\n\n        List of additional end nodes of the walks. Default is an empty list. See [additional start/end nodes documentation](additional-start-end-nodes.md).\n\n    - `optimization_options: dict`, optional\n\n        Dictionary with the optimization options. Default is `None`. See [optimization options documentation](solver-options-optimizations.md).\n\n    - `solver_options: dict`, optional\n\n        Dictionary with the solver options. Default is `None`. See [solver options documentation](solver-options-optimizations.md).\n\n    \"\"\"\n\n    # Handling node-weighted graphs\n    self.cover_type = cover_type\n    if self.cover_type == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n        # NodeExpandedDiGraph needs to have flow_attr on edges, otherwise it will add the edges to edges_to_ignore\n        G_with_flow_attr = deepcopy(G)\n        node_flow_attr = str(id(G_with_flow_attr)) + \"_flow_attr\"\n        for node in G_with_flow_attr.nodes():\n            G_with_flow_attr.nodes[node][node_flow_attr] = 0 # any dummy value\n        self.G_internal = nedg.NodeExpandedDiGraph(G_with_flow_attr, node_flow_attr=node_flow_attr)\n        subset_constraints_internal = self.G_internal.get_expanded_subpath_constraints(subset_constraints)\n\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        if not all(isinstance(node, str) for node in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes, i.e. strings, not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes, i.e. strings, not {elements_to_ignore}\")\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n\n        additional_starts_internal = self.G_internal.get_expanded_additional_starts(additional_starts)\n        additional_ends_internal = self.G_internal.get_expanded_additional_ends(additional_ends)\n    elif self.cover_type == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n        self.G_internal = G\n        subset_constraints_internal = subset_constraints\n\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges, i.e. tuples of nodes, not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges, i.e. tuples of nodes, not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n\n        additional_starts_internal = additional_starts\n        additional_ends_internal = additional_ends\n    else:\n        utils.logger.error(f\"cover_type must be either 'node' or 'edge', not {self.cover_type}\")\n        raise ValueError(f\"cover_type must be either 'node' or 'edge', not {self.cover_type}\")\n\n    self.G = self.G_internal\n    self.subset_constraints = subset_constraints_internal\n    self.edges_to_ignore = edges_to_ignore_internal\n\n    self.subset_constraints_coverage = subset_constraints_coverage\n    self.additional_starts = additional_starts_internal\n    self.additional_ends = additional_ends_internal\n\n    self._solution = None\n    self._lowerbound_k = None\n    self._is_solved = None\n    self.model = None\n\n    self.solve_statistics = {}\n    self.optimization_options = optimization_options\n    self.solver_options = solver_options\n    self.time_limit = self.solver_options.get(\"time_limit\", sw.SolverWrapper.time_limit)\n    self.solve_time_start = None\n\n    utils.logger.info(f\"{__name__}: initialized with graph id = {utils.fpid(G)}\")\n</code></pre>"},{"location":"minimum-path-cover-cycles.html#flowpaths.minpathcovercycles.MinPathCoverCycles.get_solution","title":"get_solution","text":"<pre><code>get_solution()\n</code></pre> <p>Get the solution of the Min Path Cover model, as dict with unique key <code>\"walks\"</code>.</p> Source code in <code>flowpaths/minpathcovercycles.py</code> <pre><code>def get_solution(self):\n    \"\"\"\n    Get the solution of the Min Path Cover model, as dict with unique key `\"walks\"`.\n    \"\"\"\n    self.check_is_solved()\n    return self._solution\n</code></pre>"},{"location":"minimum-path-cover-cycles.html#flowpaths.kpathcovercycles.kPathCoverCycles","title":"kPathCoverCycles","text":"<pre><code>kPathCoverCycles(\n    G: DiGraph,\n    k: int = None,\n    cover_type: str = \"edge\",\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1.0,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = None,\n    solver_options: dict = {},\n)\n</code></pre> <p>               Bases: <code>AbstractWalkModelDiGraph</code></p> <p>This class finds, if possible, <code>k</code> walks covering the edges of a directed graph, possibly with cycles \u2013 and generalizations of this problem, see the parameters below.</p> <p>Moreover, among all such walk covers, it finds minimizing the sum of the lengths of the walks (in terms of total number of edges).</p>"},{"location":"minimum-path-cover-cycles.html#flowpaths.kpathcovercycles.kPathCoverCycles--parameters","title":"Parameters","text":"<ul> <li> <p><code>G: nx.DiGraph</code></p> <p>The input directed graph, as networkx DiGraph, which can have cycles.</p> </li> <li> <p><code>k: int</code></p> <p>The number of walks to decompose in.</p> </li> <li> <p><code>cover_type : str</code>, optional</p> <p>The elements of the graph to cover. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: cover the edges of the graph. This is the default.</li> <li><code>\"node\"</code>: cover the nodes of the graph.</li> </ul> </li> <li> <p><code>subset_constraints: list</code>, optional</p> <p>List of subset constraints. Default is an empty list.  Each subset constraint is a list of edges that must be covered by some solution walk, in any order, according  to the <code>subset_constraints_coverage</code> parameter (see below).</p> </li> <li> <p><code>subset_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subset constraints that must be covered by some solution walk.</p> <p>Defaults to <code>1.0</code>, meaning that 100% of the edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) of the constraint need to be covered by some solution walk). See subset constraints documentation</p> </li> <li> <p><code>elements_to_ignore: list</code>, optional</p> <p>List of edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) to ignore when adding constrains on flow explanation by the weighted paths.  Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>additional_starts: list</code>, optional</p> <p>List of additional start nodes of the walks. Default is an empty list.</p> </li> <li> <p><code>additional_ends: list</code>, optional</p> <p>List of additional end nodes of the walks. Default is an empty list.</p> </li> <li> <p><code>optimization_options: dict</code>, optional</p> <p>Dictionary with the optimization options. Default is <code>None</code>. See optimization options documentation.</p> </li> <li> <p><code>solver_options: dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>{}</code>. See solver options documentation.</p> </li> </ul> Source code in <code>flowpaths/kpathcovercycles.py</code> <pre><code>def __init__(\n    self,\n    G: nx.DiGraph,\n    k: int = None,\n    cover_type: str = \"edge\",\n    subset_constraints: list = [],\n    subset_constraints_coverage: float = 1.0,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = None,\n    solver_options: dict = {},\n):\n    \"\"\"\n    This class finds, if possible, `k` walks covering the edges of a directed graph, possibly with cycles -- and generalizations of this problem, see the parameters below.\n\n    Moreover, among all such walk covers, it finds minimizing the sum of the lengths of the walks (in terms of total number of edges).\n\n    Parameters\n    ----------\n    - `G: nx.DiGraph`\n\n        The input directed graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html), which can have cycles.\n\n    - `k: int`\n\n        The number of walks to decompose in.\n\n    - `cover_type : str`, optional\n\n        The elements of the graph to cover. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: cover the edges of the graph. This is the default.\n        - `\"node\"`: cover the nodes of the graph.\n\n     - `subset_constraints: list`, optional\n\n        List of subset constraints. Default is an empty list. \n        Each subset constraint is a list of edges that must be covered by some solution walk, in any order, according \n        to the `subset_constraints_coverage` parameter (see below).\n\n    - `subset_constraints_coverage: float`, optional\n\n        Coverage fraction of the subset constraints that must be covered by some solution walk.\n\n        Defaults to `1.0`, meaning that 100% of the edges (or nodes, if `flow_attr_origin` is `\"node\"`) of\n        the constraint need to be covered by some solution walk).\n        See [subset constraints documentation](subset-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `elements_to_ignore: list`, optional\n\n        List of edges (or nodes, if `flow_attr_origin` is `\"node\"`) to ignore when adding constrains on flow explanation by the weighted paths. \n        Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `additional_starts: list`, optional\n\n        List of additional start nodes of the walks. Default is an empty list.\n\n    - `additional_ends: list`, optional\n\n        List of additional end nodes of the walks. Default is an empty list.\n\n    - `optimization_options: dict`, optional\n\n        Dictionary with the optimization options. Default is `None`. See [optimization options documentation](solver-options-optimizations.md).\n\n    - `solver_options: dict`, optional\n\n        Dictionary with the solver options. Default is `{}`. See [solver options documentation](solver-options-optimizations.md).\n\n    \"\"\"\n\n    # Handling node-weighted graphs\n    self.cover_type = cover_type\n    if self.cover_type == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n        # NodeExpandedDiGraph needs to have flow_attr on edges, otherwise it will add the edges to edges_to_ignore\n        G_with_flow_attr = deepcopy(G)\n        node_flow_attr = str(id(G_with_flow_attr)) + \"_flow_attr\"\n        for node in G_with_flow_attr.nodes():\n            G_with_flow_attr.nodes[node][node_flow_attr] = 0 # any dummy value\n        self.G_internal = nedg.NodeExpandedDiGraph(G_with_flow_attr, node_flow_attr=node_flow_attr)\n        subset_constraints_internal = self.G_internal.get_expanded_subpath_constraints(subset_constraints)\n        additional_starts_internal = self.G_internal.get_expanded_additional_starts(additional_starts)\n        additional_ends_internal = self.G_internal.get_expanded_additional_ends(additional_ends)\n\n        if not all(isinstance(element_to_ignore, str) for element_to_ignore in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes (i.e strings), not {elements_to_ignore}\")\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n        edges_to_ignore_internal = list(set(edges_to_ignore_internal))\n\n    elif self.cover_type == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n        self.G_internal = G\n        subset_constraints_internal = subset_constraints\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges (i.e. tuples of nodes), not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n        additional_starts_internal = additional_starts\n        additional_ends_internal = additional_ends\n    else:\n        utils.logger.error(f\"flow_attr_origin must be either 'node' or 'edge', not {self.cover_type}\")\n        raise ValueError(f\"flow_attr_origin must be either 'node' or 'edge', not {self.cover_type}\")\n\n    self.G = stdigraph.stDiGraph(self.G_internal, additional_starts=additional_starts_internal, additional_ends=additional_ends_internal)\n    self.subset_constraints = subset_constraints_internal\n    self.edges_to_ignore = self.G.source_sink_edges.union(edges_to_ignore_internal)\n\n    self.k = k\n    self.subset_constraints_coverage = subset_constraints_coverage\n\n    self._solution = None\n    self._lowerbound_k = None\n\n    self.solve_statistics = {}\n    self.solve_time_start = time.perf_counter()\n    self.optimization_options = optimization_options.copy() if optimization_options else {}\n    self.optimization_options[\"trusted_edges_for_safety\"] = set(e for e in self.G.edges() if e not in self.edges_to_ignore)\n\n    # Call the constructor of the parent class AbstractPathModelDAG\n    super().__init__(\n        G=self.G,\n        k=self.k,\n        max_edge_repetition=self.G.number_of_edges() * self.G.number_of_nodes(),\n        subset_constraints=self.subset_constraints,\n        subset_constraints_coverage=self.subset_constraints_coverage,\n        optimization_options=self.optimization_options,\n        solver_options=solver_options,\n        solve_statistics=self.solve_statistics\n    )\n\n    # This method is called from the super class AbstractPathModelDiGraph\n    self.create_solver_and_walks()\n\n    # This method is called from the current class to encode the path cover\n    self._encode_walk_cover()\n\n    # This method is called from the current class to encode the objective function\n    self._encode_objective()\n\n    utils.logger.info(f\"{__name__}: initialized with graph id = {utils.fpid(G)}, k = {self.k}\")\n</code></pre>"},{"location":"minimum-path-cover-cycles.html#flowpaths.kpathcovercycles.kPathCoverCycles.get_solution","title":"get_solution","text":"<pre><code>get_solution()\n</code></pre> <p>Retrieves the solution for problem.</p> <p>If the solution has already been computed and cached as <code>self._solution</code>, it returns the cached solution. Otherwise, it checks if the problem has been solved, computes the solution walks and caches the solution.</p> <p>Warning</p> <p>Make sure you called <code>.solve()</code> before calling this method.</p>"},{"location":"minimum-path-cover-cycles.html#flowpaths.kpathcovercycles.kPathCoverCycles.get_solution--returns","title":"Returns","text":"<ul> <li> <p><code>solution: dict</code></p> <p>A dictionary containing the solution walks (key <code>\"walks\"</code>).</p> </li> </ul>"},{"location":"minimum-path-cover-cycles.html#flowpaths.kpathcovercycles.kPathCoverCycles.get_solution--raises","title":"Raises","text":"<ul> <li><code>exception</code> If model is not solved.</li> </ul> Source code in <code>flowpaths/kpathcovercycles.py</code> <pre><code>def get_solution(self):\n    \"\"\"\n    Retrieves the solution for problem.\n\n    If the solution has already been computed and cached as `self._solution`, it returns the cached solution.\n    Otherwise, it checks if the problem has been solved, computes the solution walks\n    and caches the solution.\n\n    !!! warning \"Warning\"\n        Make sure you called `.solve()` before calling this method.\n\n    Returns\n    -------\n    - `solution: dict`\n\n        A dictionary containing the solution walks (key `\"walks\"`).\n\n    Raises\n    -------\n    - `exception` If model is not solved.\n    \"\"\"\n\n    if self._solution is None:\n        self.check_is_solved()\n\n        if self.cover_type == \"edge\":\n            self._solution = {\n                \"walks\": self.get_solution_walks(),\n                }\n        elif self.cover_type == \"node\":\n            self._solution = {\n                \"_walks_internal\": self.get_solution_walks(),\n                \"walks\": self.G_internal.get_condensed_paths(self.get_solution_walks()),\n                }\n\n    return self._solution\n</code></pre>"},{"location":"minimum-path-cover-cycles.html#flowpaths.kpathcovercycles.kPathCoverCycles.is_valid_solution","title":"is_valid_solution","text":"<pre><code>is_valid_solution()\n</code></pre> <p>Checks if the solution is valid, meaning it covers all required edges.</p>"},{"location":"minimum-path-cover-cycles.html#flowpaths.kpathcovercycles.kPathCoverCycles.is_valid_solution--raises","title":"Raises","text":"<ul> <li>ValueError: If the solution is not available (i.e., self.solution is None).</li> </ul>"},{"location":"minimum-path-cover-cycles.html#flowpaths.kpathcovercycles.kPathCoverCycles.is_valid_solution--returns","title":"Returns","text":"<ul> <li>bool: True if the solution is valid, False otherwise.</li> </ul>"},{"location":"minimum-path-cover-cycles.html#flowpaths.kpathcovercycles.kPathCoverCycles.is_valid_solution--notes","title":"Notes","text":"<ul> <li>get_solution() must be called before this method.</li> </ul> Source code in <code>flowpaths/kpathcovercycles.py</code> <pre><code>def is_valid_solution(self):\n    \"\"\"\n    Checks if the solution is valid, meaning it covers all required edges.\n\n    Raises\n    ------\n    - ValueError: If the solution is not available (i.e., self.solution is None).\n\n    Returns\n    -------\n    - bool: True if the solution is valid, False otherwise.\n\n    Notes\n    -------\n    - get_solution() must be called before this method.\n    \"\"\"\n\n    if self._solution is None:\n        utils.logger.error(f\"{__name__}: Solution is not available. Call get_solution() first.\")\n        raise ValueError(\"Solution is not available. Call get_solution() first.\")\n\n    solution_walks = self._solution.get(\"_walks_internal\", self._solution[\"walks\"])\n    solution_walks_of_edges = [\n        [(walk[i], walk[i + 1]) for i in range(len(walk) - 1)]\n        for walk in solution_walks\n    ]\n\n    covered_by_walks = {(u, v): 0 for (u, v) in self.G.edges()}\n    for walk in solution_walks_of_edges:\n        for e in walk:\n            if e in covered_by_walks:\n                covered_by_walks[e] += 1\n\n    for u, v in self.G.edges():\n        if (u,v) not in self.edges_to_ignore:\n            if covered_by_walks[(u, v)] == 0: \n                return False\n\n    return True\n</code></pre>"},{"location":"minimum-path-cover.html","title":"Minimum Path Cover","text":"<p>See also</p> <ul> <li>Minimum Path Cover in General Graphs</li> </ul>"},{"location":"minimum-path-cover.html#minimum-path-cover","title":"Minimum Path Cover","text":""},{"location":"minimum-path-cover.html#1-definition","title":"1. Definition","text":"<p>The Minimum Path Cover problem on a directed acyclic graph (DAG) is defined as follows:</p> <ul> <li> <p>INPUT: A directed graph \\(G = (V,E)\\).</p> </li> <li> <p>OUTPUT: A minimum number \\(k\\) of source-to-sink paths, \\(P_1,\\dots,P_k\\) such that every edge \\(e \\in E\\) appears in at least one \\(P_i\\).</p> </li> </ul> <p>Note</p> <ul> <li>This class support also covers of nodes. Set the parameter <code>cover_type = \"node\"</code>. For details on how these are handled internally, see Handling graphs with flows / weights on nodes.</li> <li>The graph may have more than one source or sink nodes, in which case the solution paths are just required to start in any source node, and end in any sink node.</li> </ul>"},{"location":"minimum-path-cover.html#2-solving-the-problem","title":"2. Solving the problem","text":"<p>We create the graph as a networkx DiGraph. In real project, you will likely have a method that transforms your graph to a DiGraph.</p> <pre><code>import flowpaths as fp\nimport networkx as nx\n\ngraph = nx.DiGraph()\ngraph.add_edge(\"s\", \"a\")\ngraph.add_edge(\"s\", \"b\")\ngraph.add_edge(\"a\", \"b\")\ngraph.add_edge(\"a\", \"c\")\ngraph.add_edge(\"b\", \"c\")\ngraph.add_edge(\"c\", \"d\")\ngraph.add_edge(\"c\", \"t\")\ngraph.add_edge(\"d\", \"t\")\n\nmpc_model = fp.MinPathCover(graph)\nmpc_model.solve()\n</code></pre> <p>The solution of <code>MinPathCover</code> is a dictionary, with a key <code>'paths'</code> containing the solution paths:</p> <pre><code>if mpc_model.is_solved():\n    solution = mpc_model.get_solution()\n    print(solution)\n    # {'paths': [\n    #   ['s', 'b', 'c', 't'], \n    #   ['s', 'a', 'b', 'c', 'd', 't'], \n    #   ['s', 'a', 'c', 't']]} \n</code></pre> <p>We can also support subpath constraints:</p> <pre><code>subpath_constraints=[[(\"a\", \"c\"),(\"c\", \"t\")]]\nmpc_model_sc = fp.MinPathCover(\n    graph,\n    subpath_constraints=subpath_constraints,\n)\nmpc_model_sc.solve()\n</code></pre>"},{"location":"minimum-path-cover.html#flowpaths.minpathcover.MinPathCover","title":"MinPathCover","text":"<pre><code>MinPathCover(\n    G: DiGraph,\n    cover_type: str = \"edge\",\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1.0,\n    subpath_constraints_coverage_length: float = None,\n    length_attr: str = None,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = {},\n    solver_options: dict = {},\n)\n</code></pre> <p>               Bases: <code>AbstractPathModelDAG</code></p> <p>This class finds a minimum number of paths covering the edges of a directed acyclic graph (DAG) \u2013 and generalizations of this problem, see the parameters below.</p>"},{"location":"minimum-path-cover.html#flowpaths.minpathcover.MinPathCover--parameters","title":"Parameters","text":"<ul> <li> <p><code>G: nx.DiGraph</code></p> <p>The input directed acyclic graph, as networkx DiGraph.</p> </li> <li> <p><code>cover_type: str</code>, optional</p> <p>The elements of the graph to cover. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: cover the edges of the graph. This is the default.</li> <li><code>\"node\"</code>: cover the nodes of the graph.</li> </ul> </li> <li> <p><code>subpath_constraints: list</code>, optional</p> <p>List of subpath constraints. Default is an empty list.  Each subpath constraint is a list of edges that must be covered by some solution path, according  to the <code>subpath_constraints_coverage</code> or <code>subpath_constraints_coverage_length</code> parameters (see below).</p> </li> <li> <p><code>subpath_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subpath constraints that must be covered by some solution paths. </p> <p>Defaults to <code>1.0</code>, meaning that 100% of the edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) of  the constraint need to be covered by some solution path).  See subpath constraints documentation</p> </li> <li> <p><code>subpath_constraints_coverage_length: float</code>, optional</p> <p>Coverage length of the subpath constraints. Default is <code>None</code>. If set, this overrides <code>subpath_constraints_coverage</code>,  and the coverage constraint is expressed in terms of the subpath constraint length.  <code>subpath_constraints_coverage_length</code> is then the fraction of the total length of the constraint (specified via <code>length_attr</code>) needs to appear in some solution path. See subpath constraints documentation</p> </li> <li> <p><code>length_attr: str</code>, optional</p> <p>The attribute name from where to get the edge lengths (or node length, if <code>flow_attr_origin</code> is <code>\"node\"</code>). Defaults to <code>None</code>.</p> <ul> <li>If set, then the subpath lengths (above) are in terms of the edge/node lengths specified in the <code>length_attr</code> field of each edge/node.</li> <li>If set, and an edge/node has a missing edge length, then it gets length 1.</li> </ul> </li> <li> <p><code>elements_to_ignore: list</code>, optional</p> <p>List of graph elements to ignore when adding constrains on flow explanation by the weighted paths. These elements are either edges or nodes, depending on the <code>cover_type</code> parameter. Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>additional_starts: list</code>, optional</p> <p>List of additional start nodes of the paths. Default is an empty list. See additional start/end nodes documentation.</p> </li> <li> <p><code>additional_ends: list</code>, optional</p> <p>List of additional end nodes of the paths. Default is an empty list. See additional start/end nodes documentation.</p> </li> <li> <p><code>optimization_options: dict</code>, optional</p> <p>Dictionary with the optimization options. Default is <code>None</code>. See optimization options documentation.</p> </li> <li> <p><code>solver_options: dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>None</code>. See solver options documentation.</p> </li> </ul> Source code in <code>flowpaths/minpathcover.py</code> <pre><code>def __init__(\n    self,\n    G: nx.DiGraph,\n    cover_type: str = \"edge\",\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1.0,\n    subpath_constraints_coverage_length: float = None,\n    length_attr: str = None,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = {},\n    solver_options: dict = {},\n):\n    \"\"\"\n    This class finds a minimum number of paths covering the edges of a directed acyclic graph (DAG) -- and generalizations of this problem, see the parameters below.\n\n    Parameters\n    ----------\n    - `G: nx.DiGraph`\n\n        The input directed acyclic graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html).\n\n    - `cover_type: str`, optional\n\n        The elements of the graph to cover. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: cover the edges of the graph. This is the default.\n        - `\"node\"`: cover the nodes of the graph.\n\n    - `subpath_constraints: list`, optional\n\n        List of subpath constraints. Default is an empty list. \n        Each subpath constraint is a list of edges that must be covered by some solution path, according \n        to the `subpath_constraints_coverage` or `subpath_constraints_coverage_length` parameters (see below).\n\n    - `subpath_constraints_coverage: float`, optional\n\n        Coverage fraction of the subpath constraints that must be covered by some solution paths. \n\n        Defaults to `1.0`, meaning that 100% of the edges (or nodes, if `flow_attr_origin` is `\"node\"`) of \n        the constraint need to be covered by some solution path). \n        See [subpath constraints documentation](subpath-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `subpath_constraints_coverage_length: float`, optional\n\n        Coverage length of the subpath constraints. Default is `None`. If set, this overrides `subpath_constraints_coverage`, \n        and the coverage constraint is expressed in terms of the subpath constraint length. \n        `subpath_constraints_coverage_length` is then the fraction of the total length of the constraint (specified via `length_attr`) needs to appear in some solution path.\n        See [subpath constraints documentation](subpath-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `length_attr: str`, optional\n\n        The attribute name from where to get the edge lengths (or node length, if `flow_attr_origin` is `\"node\"`). Defaults to `None`.\n\n        - If set, then the subpath lengths (above) are in terms of the edge/node lengths specified in the `length_attr` field of each edge/node.\n        - If set, and an edge/node has a missing edge length, then it gets length 1.\n\n    - `elements_to_ignore: list`, optional\n\n        List of graph elements to ignore when adding constrains on flow explanation by the weighted paths.\n        These elements are either edges or nodes, depending on the `cover_type` parameter.\n        Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `additional_starts: list`, optional\n\n        List of additional start nodes of the paths. Default is an empty list. See [additional start/end nodes documentation](additional-start-end-nodes.md).\n\n    - `additional_ends: list`, optional\n\n        List of additional end nodes of the paths. Default is an empty list. See [additional start/end nodes documentation](additional-start-end-nodes.md).\n\n    - `optimization_options: dict`, optional\n\n        Dictionary with the optimization options. Default is `None`. See [optimization options documentation](solver-options-optimizations.md).\n\n    - `solver_options: dict`, optional\n\n        Dictionary with the solver options. Default is `None`. See [solver options documentation](solver-options-optimizations.md).\n\n    \"\"\"\n\n    # Handling node-weighted graphs\n    self.cover_type = cover_type\n    if self.cover_type == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n        # NodeExpandedDiGraph needs to have flow_attr on edges, otherwise it will add the edges to edges_to_ignore\n        G_with_flow_attr = deepcopy(G)\n        node_flow_attr = str(id(G_with_flow_attr)) + \"_flow_attr\"\n        for node in G_with_flow_attr.nodes():\n            G_with_flow_attr.nodes[node][node_flow_attr] = 0 # any dummy value\n        self.G_internal = nedg.NodeExpandedDiGraph(G_with_flow_attr, node_flow_attr=node_flow_attr)\n        subpath_constraints_internal = self.G_internal.get_expanded_subpath_constraints(subpath_constraints)\n\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        if not all(isinstance(node, str) for node in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes, i.e. strings, not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes, i.e. strings, not {elements_to_ignore}\")\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n\n        additional_starts_internal = self.G_internal.get_expanded_additional_starts(additional_starts)\n        additional_ends_internal = self.G_internal.get_expanded_additional_ends(additional_ends)\n    elif self.cover_type == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n        self.G_internal = G\n        subpath_constraints_internal = subpath_constraints\n\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges, i.e. tuples of nodes, not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges, i.e. tuples of nodes, not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n\n        additional_starts_internal = additional_starts\n        additional_ends_internal = additional_ends\n    else:\n        utils.logger.error(f\"cover_type must be either 'node' or 'edge', not {self.cover_type}\")\n        raise ValueError(f\"cover_type must be either 'node' or 'edge', not {self.cover_type}\")\n\n    self.G = stdag.stDAG(self.G_internal, additional_starts=additional_starts_internal, additional_ends=additional_ends_internal)\n    self.subpath_constraints = subpath_constraints_internal\n    self.edges_to_ignore = self.G.source_sink_edges.union(edges_to_ignore_internal)\n\n    self.subpath_constraints_coverage = subpath_constraints_coverage\n    self.subpath_constraints_coverage_length = subpath_constraints_coverage_length\n    self.length_attr = length_attr\n\n    self.additional_starts = additional_starts\n    self.additional_ends = additional_ends\n\n    self._solution = None\n    self._lowerbound_k = None\n    self._is_solved = None\n    self.model = None\n\n    self.solve_statistics = {}\n    self.optimization_options = optimization_options\n    self.solver_options = solver_options\n    self.time_limit = self.solver_options.get(\"time_limit\", sw.SolverWrapper.time_limit)\n    self.solve_time_start = None\n\n    utils.logger.info(f\"{__name__}: initialized with graph id = {utils.fpid(G)}\")\n</code></pre>"},{"location":"minimum-path-cover.html#flowpaths.minpathcover.MinPathCover.get_solution","title":"get_solution","text":"<pre><code>get_solution()\n</code></pre> <p>Get the solution of the Min Path Cover model, as dict with unique key <code>\"paths\"</code>.</p> Source code in <code>flowpaths/minpathcover.py</code> <pre><code>def get_solution(self):\n    \"\"\"\n    Get the solution of the Min Path Cover model, as dict with unique key `\"paths\"`.\n    \"\"\"\n    self.check_is_solved()\n    return self._solution\n</code></pre>"},{"location":"minimum-path-cover.html#flowpaths.kpathcover.kPathCover","title":"kPathCover","text":"<pre><code>kPathCover(\n    G: DiGraph,\n    k: int,\n    cover_type: str = \"edge\",\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1.0,\n    subpath_constraints_coverage_length: float = None,\n    length_attr: str = None,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = {},\n    solver_options: dict = {},\n)\n</code></pre> <p>               Bases: <code>AbstractPathModelDAG</code></p> <p>This class finds, if possible, <code>k</code> paths covering the edges of a directed acyclic graph (DAG) \u2013 and generalizations of this problem, see the parameters below.</p>"},{"location":"minimum-path-cover.html#flowpaths.kpathcover.kPathCover--parameters","title":"Parameters","text":"<ul> <li> <p><code>G : nx.DiGraph</code></p> <p>The input directed acyclic graph, as networkx DiGraph.</p> </li> <li> <p><code>k: int</code></p> <p>The number of paths to decompose in.</p> </li> <li> <p><code>cover_type : str</code>, optional</p> <p>The elements of the graph to cover. Default is <code>\"edge\"</code>. Options:</p> <ul> <li><code>\"edge\"</code>: cover the edges of the graph. This is the default.</li> <li><code>\"node\"</code>: cover the nodes of the graph.</li> </ul> </li> <li> <p><code>subpath_constraints: list</code>, optional</p> <p>List of subpath constraints. Default is an empty list.  Each subpath constraint is a list of edges that must be covered by some solution path, according  to the <code>subpath_constraints_coverage</code> or <code>subpath_constraints_coverage_length</code> parameters (see below).</p> </li> <li> <p><code>subpath_constraints_coverage: float</code>, optional</p> <p>Coverage fraction of the subpath constraints that must be covered by some solution paths. </p> <p>Defaults to <code>1.0</code>, meaning that 100% of the edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) of  the constraint need to be covered by some solution path).  See subpath constraints documentation</p> </li> <li> <p><code>subpath_constraints_coverage_length: float</code>, optional</p> <p>Coverage length of the subpath constraints. Default is <code>None</code>. If set, this overrides <code>subpath_constraints_coverage</code>,  and the coverage constraint is expressed in terms of the subpath constraint length.  <code>subpath_constraints_coverage_length</code> is then the fraction of the total length of the constraint (specified via <code>length_attr</code>) needs to appear in some solution path. See subpath constraints documentation</p> </li> <li> <p><code>length_attr: str</code>, optional</p> <p>The attribute name from where to get the edge lengths (or node length, if <code>flow_attr_origin</code> is <code>\"node\"</code>). Defaults to <code>None</code>.</p> <ul> <li>If set, then the subpath lengths (above) are in terms of the edge/node lengths specified in the <code>length_attr</code> field of each edge/node.</li> <li>If set, and an edge/node has a missing edge length, then it gets length 1.</li> </ul> </li> <li> <p><code>elements_to_ignore: list</code>, optional</p> <p>List of edges (or nodes, if <code>flow_attr_origin</code> is <code>\"node\"</code>) to ignore when adding constrains on flow explanation by the weighted paths.  Default is an empty list. See ignoring edges documentation</p> </li> <li> <p><code>additional_starts: list</code>, optional</p> <p>List of additional start nodes of the paths. Default is an empty list. See additional start/end nodes documentation.</p> </li> <li> <p><code>additional_ends: list</code>, optional</p> <p>List of additional end nodes of the paths. Default is an empty list. See additional start/end nodes documentation.</p> </li> <li> <p><code>optimization_options : dict</code>, optional</p> <p>Dictionary with the optimization options. Default is <code>None</code>. See optimization options documentation.</p> </li> <li> <p><code>solver_options : dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>None</code>. See solver options documentation.</p> </li> </ul> Source code in <code>flowpaths/kpathcover.py</code> <pre><code>def __init__(\n    self,\n    G: nx.DiGraph,\n    k: int,\n    cover_type: str = \"edge\",\n    subpath_constraints: list = [],\n    subpath_constraints_coverage: float = 1.0,\n    subpath_constraints_coverage_length: float = None,\n    length_attr: str = None,\n    elements_to_ignore: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    optimization_options: dict = {},\n    solver_options: dict = {},\n):\n    \"\"\"\n    This class finds, if possible, `k` paths covering the edges of a directed acyclic graph (DAG) -- and generalizations of this problem, see the parameters below.\n\n    Parameters\n    ----------\n    - `G : nx.DiGraph`\n\n        The input directed acyclic graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html).\n\n    - `k: int`\n\n        The number of paths to decompose in.\n\n    - `cover_type : str`, optional\n\n        The elements of the graph to cover. Default is `\"edge\"`. Options:\n\n        - `\"edge\"`: cover the edges of the graph. This is the default.\n        - `\"node\"`: cover the nodes of the graph.\n\n    - `subpath_constraints: list`, optional\n\n        List of subpath constraints. Default is an empty list. \n        Each subpath constraint is a list of edges that must be covered by some solution path, according \n        to the `subpath_constraints_coverage` or `subpath_constraints_coverage_length` parameters (see below).\n\n    - `subpath_constraints_coverage: float`, optional\n\n        Coverage fraction of the subpath constraints that must be covered by some solution paths. \n\n        Defaults to `1.0`, meaning that 100% of the edges (or nodes, if `flow_attr_origin` is `\"node\"`) of \n        the constraint need to be covered by some solution path). \n        See [subpath constraints documentation](subpath-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `subpath_constraints_coverage_length: float`, optional\n\n        Coverage length of the subpath constraints. Default is `None`. If set, this overrides `subpath_constraints_coverage`, \n        and the coverage constraint is expressed in terms of the subpath constraint length. \n        `subpath_constraints_coverage_length` is then the fraction of the total length of the constraint (specified via `length_attr`) needs to appear in some solution path.\n        See [subpath constraints documentation](subpath-constraints.md#3-relaxing-the-constraint-coverage)\n\n    - `length_attr: str`, optional\n\n        The attribute name from where to get the edge lengths (or node length, if `flow_attr_origin` is `\"node\"`). Defaults to `None`.\n\n        - If set, then the subpath lengths (above) are in terms of the edge/node lengths specified in the `length_attr` field of each edge/node.\n        - If set, and an edge/node has a missing edge length, then it gets length 1.\n\n    - `elements_to_ignore: list`, optional\n\n        List of edges (or nodes, if `flow_attr_origin` is `\"node\"`) to ignore when adding constrains on flow explanation by the weighted paths. \n        Default is an empty list. See [ignoring edges documentation](ignoring-edges.md)\n\n    - `additional_starts: list`, optional\n\n        List of additional start nodes of the paths. Default is an empty list. See [additional start/end nodes documentation](additional-start-end-nodes.md).\n\n    - `additional_ends: list`, optional\n\n        List of additional end nodes of the paths. Default is an empty list. See [additional start/end nodes documentation](additional-start-end-nodes.md).\n\n    - `optimization_options : dict`, optional\n\n        Dictionary with the optimization options. Default is `None`. See [optimization options documentation](solver-options-optimizations.md).\n\n    - `solver_options : dict`, optional\n\n        Dictionary with the solver options. Default is `None`. See [solver options documentation](solver-options-optimizations.md).\n\n    \"\"\"\n\n    # Handling node-weighted graphs\n    self.cover_type = cover_type\n    if self.cover_type == \"node\":\n        if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n        # NodeExpandedDiGraph needs to have flow_attr on edges, otherwise it will add the edges to edges_to_ignore\n        G_with_flow_attr = deepcopy(G)\n        node_flow_attr = id(G_with_flow_attr) + \"_flow_attr\"\n        for node in G_with_flow_attr.nodes():\n            G_with_flow_attr.nodes[node][node_flow_attr] = 0 # any dummy value\n        self.G_internal = nedg.NodeExpandedDiGraph(G_with_flow_attr, node_flow_attr=node_flow_attr)\n        subpath_constraints_internal = self.G_internal.get_expanded_subpath_constraints(subpath_constraints)\n\n        edges_to_ignore_internal = self.G_internal.edges_to_ignore\n        if not all(isinstance(node, str) for node in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of nodes, i.e. strings, not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of nodes, i.e. strings, not {elements_to_ignore}\")\n        edges_to_ignore_internal += [self.G_internal.get_expanded_edge(node) for node in elements_to_ignore]\n        edges_to_ignore_internal = list(set(edges_to_ignore_internal))\n\n        additional_starts_internal = self.G_internal.get_expanded_additional_starts(additional_starts)\n        additional_ends_internal = self.G_internal.get_expanded_additional_ends(additional_ends)\n    elif self.cover_type == \"edge\":\n        if G.number_of_edges() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no edges. Please provide a graph with at least one edge.\")\n            raise ValueError(f\"The input graph G has no edges. Please provide a graph with at least one edge.\")\n        self.G_internal = G\n        subpath_constraints_internal = subpath_constraints\n\n        if not all(isinstance(edge, tuple) and len(edge) == 2 for edge in elements_to_ignore):\n            utils.logger.error(f\"elements_to_ignore must be a list of edges, i.e. tuples of nodes, not {elements_to_ignore}\")\n            raise ValueError(f\"elements_to_ignore must be a list of edges, i.e. tuples of nodes, not {elements_to_ignore}\")\n        edges_to_ignore_internal = elements_to_ignore\n\n        additional_starts_internal = additional_starts\n        additional_ends_internal = additional_ends\n    else:\n        utils.logger.error(f\"cover_type must be either 'node' or 'edge', not {self.cover_type}\")\n        raise ValueError(f\"cover_type must be either 'node' or 'edge', not {self.cover_type}\")\n\n    self.G = stdag.stDAG(self.G_internal, additional_starts=additional_starts_internal, additional_ends=additional_ends_internal)\n    self.subpath_constraints = subpath_constraints_internal\n    self.edges_to_ignore = self.G.source_sink_edges.union(edges_to_ignore_internal)\n\n    self.k = k\n    self.subpath_constraints_coverage = subpath_constraints_coverage\n    self.subpath_constraints_coverage_length = subpath_constraints_coverage_length\n    self.length_attr = length_attr\n\n    self._solution = None\n    self._lowerbound_k = None\n\n    self.solve_statistics = {}\n    self.optimization_options = optimization_options.copy() if optimization_options else {}\n    self.optimization_options[\"trusted_edges_for_safety\"] = set(e for e in self.G.edges() if e not in self.edges_to_ignore)\n\n    # Call the constructor of the parent class AbstractPathModelDAG\n    super().__init__(\n        G=self.G, \n        k=self.k,\n        subpath_constraints=self.subpath_constraints, \n        subpath_constraints_coverage=self.subpath_constraints_coverage, \n        subpath_constraints_coverage_length=self.subpath_constraints_coverage_length,\n        length_attr=self.length_attr, \n        optimization_options=self.optimization_options,\n        solver_options=solver_options,\n        solve_statistics=self.solve_statistics,\n    )\n\n    # This method is called from the super class AbstractPathModelDAG\n    self.create_solver_and_paths()\n\n    # This method is called from the current class to encode the path cover\n    self._encode_path_cover()\n\n    utils.logger.info(f\"{__name__}: initialized with graph id = {utils.fpid(G)}, k = {self.k}\")\n</code></pre>"},{"location":"minimum-path-cover.html#flowpaths.kpathcover.kPathCover.get_solution","title":"get_solution","text":"<pre><code>get_solution()\n</code></pre> <p>Retrieves the solution for the k-path cover problem.</p>"},{"location":"minimum-path-cover.html#flowpaths.kpathcover.kPathCover.get_solution--returns","title":"Returns","text":"<ul> <li> <p><code>solution: dict</code></p> <p>A dictionary containing the solution paths, under key <code>\"paths\"</code>.</p> </li> </ul>"},{"location":"minimum-path-cover.html#flowpaths.kpathcover.kPathCover.get_solution--raises","title":"Raises","text":"<ul> <li><code>exception</code> If model is not solved.</li> </ul> Source code in <code>flowpaths/kpathcover.py</code> <pre><code>def get_solution(self):\n    \"\"\"\n    Retrieves the solution for the k-path cover problem.\n\n    Returns\n    -------\n    - `solution: dict`\n\n        A dictionary containing the solution paths, under key `\"paths\"`.\n\n    Raises\n    ------\n    - `exception` If model is not solved.\n    \"\"\"\n\n    if self._solution is None:\n        self.check_is_solved()\n\n        if self.cover_type == \"edge\":\n            self._solution = {\n                \"paths\": self.get_solution_paths(),\n            }\n        elif self.cover_type == \"node\":\n            self._solution = {\n                \"_paths_internal\": self.get_solution_paths(),\n                \"paths\": self.G_internal.get_condensed_paths(self.get_solution_paths()),\n            }\n\n    return self._solution\n</code></pre>"},{"location":"minimum-path-cover.html#flowpaths.kpathcover.kPathCover.is_valid_solution","title":"is_valid_solution","text":"<pre><code>is_valid_solution()\n</code></pre> <p>Checks if the solution is valid, meaning it covers all required edges.</p>"},{"location":"minimum-path-cover.html#flowpaths.kpathcover.kPathCover.is_valid_solution--raises","title":"Raises","text":"<ul> <li>ValueError: If the solution is not available (i.e., self.solution is None).</li> </ul>"},{"location":"minimum-path-cover.html#flowpaths.kpathcover.kPathCover.is_valid_solution--returns","title":"Returns","text":"<ul> <li>bool: True if the solution is valid, False otherwise.</li> </ul>"},{"location":"minimum-path-cover.html#flowpaths.kpathcover.kPathCover.is_valid_solution--notes","title":"Notes","text":"<ul> <li>get_solution() must be called before this method.</li> </ul> Source code in <code>flowpaths/kpathcover.py</code> <pre><code>def is_valid_solution(self):\n    \"\"\"\n    Checks if the solution is valid, meaning it covers all required edges.\n\n    Raises\n    ------\n    - ValueError: If the solution is not available (i.e., self.solution is None).\n\n    Returns\n    -------\n    - bool: True if the solution is valid, False otherwise.\n\n    Notes\n    -------\n    - get_solution() must be called before this method.\n    \"\"\"\n\n    if self._solution is None:\n        utils.logger.error(f\"{__name__}: Solution is not available. Call get_solution() first.\")\n        raise ValueError(\"Solution is not available. Call get_solution() first.\")\n\n    solution_paths = self._solution.get(\"_paths_internal\", self._solution[\"paths\"])\n    solution_paths_of_edges = [\n        [(path[i], path[i + 1]) for i in range(len(path) - 1)]\n        for path in solution_paths\n    ]\n\n    covered_by_paths = {(u, v): 0 for (u, v) in self.G.edges()}\n    for path in solution_paths_of_edges:\n        for e in path:\n            if e in covered_by_paths:\n                covered_by_paths[e] += 1\n\n    for u, v in self.G.edges():\n        if (u,v) not in self.edges_to_ignore:\n            if covered_by_paths[(u, v)] == 0: \n                return False\n\n    return True\n</code></pre>"},{"location":"minimum-set-cover.html","title":"Minimum Set Cover","text":""},{"location":"minimum-set-cover.html#flowpaths.minsetcover.MinSetCover","title":"MinSetCover","text":"<pre><code>MinSetCover(\n    universe: list,\n    subsets: list,\n    subset_weights: list = None,\n    solver_options: dict = {},\n)\n</code></pre> <p>This class solves the minimum set cover problem. Given a universe <code>universe</code> and a list of subsets <code>subsets</code>, the goal is to find the minimum-weight list of subsets <code>set_cover</code> such that: </p> <ul> <li>every element in <code>universe</code> is in at least one subset in <code>set_cover</code>.</li> <li>the sum of the weights of the subsets in <code>set_cover</code> is minimized.</li> </ul>"},{"location":"minimum-set-cover.html#flowpaths.minsetcover.MinSetCover--parameters","title":"Parameters","text":"<ul> <li> <p><code>universe: list</code></p> <p>The universe of elements that must be covered.</p> </li> <li> <p><code>subsets: list</code></p> <p>A list of subsets that can be used to cover the universe.</p> </li> <li> <p><code>subset_weights: list</code></p> <p>The weight of each subset, as a list in the same order that the subsets appear in the list <code>subsets</code>.  If not provided, each subset is assumed to have a weight of 1.</p> </li> <li> <p><code>solver_options : dict</code>, optional</p> <p>Dictionary with the solver options. Default is <code>{}</code>. See solver options documentation.</p> </li> </ul> Source code in <code>flowpaths/minsetcover.py</code> <pre><code>def __init__(\n    self,\n    universe: list,\n    subsets: list,\n    subset_weights: list = None,\n    solver_options: dict = {},\n    ):\n    \"\"\"\n    This class solves the minimum set cover problem. Given a universe `universe` and a list of subsets `subsets`,\n    the goal is to find the minimum-weight list of subsets `set_cover` such that: \n\n    - every element in `universe` is in at least one subset in `set_cover`.\n    - the sum of the weights of the subsets in `set_cover` is minimized.\n\n    Parameters\n    ----------\n\n    - `universe: list`\n\n        The universe of elements that must be covered.\n\n    - `subsets: list`\n\n        A list of subsets that can be used to cover the universe.\n\n    - `subset_weights: list`\n\n        The weight of each subset, as a list in the same order that the subsets appear in the list `subsets`. \n        If not provided, each subset is assumed to have a weight of 1.\n\n    - `solver_options : dict`, optional\n\n        Dictionary with the solver options. Default is `{}`. See [solver options documentation](solver-options-optimizations.md).\n    \"\"\"\n\n    self.universe = universe\n    self.subsets = subsets\n    self.subset_weights = subset_weights\n    self.set_cover = []\n    self.set_cover_indices = []\n    self.set_cover_weights = []\n    self.solver_options = solver_options\n\n    self._is_solved = None\n    self._solution = None\n\n    self._encode_set_cover()\n</code></pre>"},{"location":"minimum-set-cover.html#flowpaths.minsetcover.MinSetCover.get_solution","title":"get_solution","text":"<pre><code>get_solution(\n    as_subsets: bool = False,\n)\n</code></pre> <p>Returns the solution to the minimum generating set problem, if the model was solved. </p>"},{"location":"minimum-set-cover.html#flowpaths.minsetcover.MinSetCover.get_solution--parameters","title":"Parameters","text":"<ul> <li> <p><code>as_subsets: bool</code></p> <p>If <code>True</code>, returns the subsets themselves. If <code>False</code>, returns the indices of the subsets in the list <code>subsets</code>.</p> </li> </ul> <p>Warning</p> <p>Call the <code>solve</code> method first.</p> Source code in <code>flowpaths/minsetcover.py</code> <pre><code>def get_solution(self, as_subsets: bool = False):\n    \"\"\"\n    Returns the solution to the minimum generating set problem, if the model was solved. \n\n    Parameters\n    ----------\n    - `as_subsets: bool`\n\n        If `True`, returns the subsets themselves. If `False`, returns the indices of the subsets in the list `subsets`.\n\n    !!! warning \"Warning\"\n        Call the `solve` method first.\n    \"\"\"\n    if self._solution is not None:\n        if not as_subsets:\n            return self._solution\n        else:\n            return [self.subsets[i] for i in self._solution]\n\n    self.check_is_solved() \n</code></pre>"},{"location":"minimum-set-cover.html#flowpaths.minsetcover.MinSetCover.is_solved","title":"is_solved","text":"<pre><code>is_solved()\n</code></pre> <p>Returns <code>True</code> if the model was solved, <code>False</code> otherwise.</p> Source code in <code>flowpaths/minsetcover.py</code> <pre><code>def is_solved(self):\n    \"\"\"\n    Returns `True` if the model was solved, `False` otherwise.\n    \"\"\"\n    if self._is_solved is None:\n        self.solver.logger.error(f\"{__name__}: Model not yet solved. If you want to solve it, call the `solve` method first.\")\n        raise Exception(\"Model not yet solved. If you want to solve it, call the `solve` method first.\")\n\n    return self._is_solved\n</code></pre>"},{"location":"minimum-set-cover.html#flowpaths.minsetcover.MinSetCover.solve","title":"solve","text":"<pre><code>solve() -&gt; bool\n</code></pre> <p>Solves the minimum set cover problem. </p>"},{"location":"minimum-set-cover.html#flowpaths.minsetcover.MinSetCover.solve--returns","title":"Returns","text":"<ul> <li> <p>bool</p> <p><code>True</code> if the model was solved, <code>False</code> otherwise.</p> </li> </ul> Source code in <code>flowpaths/minsetcover.py</code> <pre><code>def solve(self) -&gt; bool:\n    \"\"\"\n    Solves the minimum set cover problem. \n\n    Returns\n    -------\n    - bool\n\n        `True` if the model was solved, `False` otherwise.\n    \"\"\"\n    start_time = time.perf_counter()\n\n    self.solver.optimize()\n    if self.solver.get_model_status() == \"kOptimal\":\n        subset_cover_sol = self.solver.get_values(self.subset_vars)\n        self._solution = [i for i in range(len(self.subsets)) if subset_cover_sol[i] == 1]\n        self._is_solved = True\n        self.solve_statistics = {\n            \"solve_time\": time.perf_counter() - start_time,\n            \"num_elements\": len(self._solution),\n            \"status\": self.solver.get_model_status(),\n        }\n        return True\n    else:\n        self.solve_statistics = {\n            \"solve_time\": time.perf_counter() - start_time,\n            \"status\": self.solver.get_model_status(),\n        }\n        return False\n</code></pre>"},{"location":"node-expanded-digraph.html","title":"Handling graphs with flows / weights on nodes","text":"<p>If your graph has flow values or weights associated with the nodes, instead of the edges, the models implemented support such graphs by passing an appropriate parameter, usually <code>flow_attr_origin = \"node\"</code>.</p> <p>Internally, these are handled via the class <code>NodeExpandedDiGraph</code>. See this example on how to support node-weighted graphs without using the internal mechanism, support subpath constraints, and then apply Minimum Flow Decomposition on them. This is useful when implementing new decomposition models, or when using a decomposition model which does not yet support node-weighted graphs.</p>"},{"location":"node-expanded-digraph.html#flowpaths.nodeexpandeddigraph.NodeExpandedDiGraph","title":"NodeExpandedDiGraph","text":"<pre><code>NodeExpandedDiGraph(\n    G: DiGraph,\n    node_flow_attr: str,\n    try_filling_in_missing_flow_attr: bool = False,\n    node_length_attr: str = None,\n    additional_starts: list = [],\n    additional_ends: list = [],\n)\n</code></pre> <p>               Bases: <code>DiGraph</code></p> <p>This class is a subclass of the networkx DiGraph class. It is used to represent a directed graph where all nodes <code>v</code> have been \u201cexpanded\u201d or \u201csubdivided\u201d into an edge <code>(v.0, v.1)</code>. This is useful for representing graphs where the flow values, or weights, are associated with the nodes, rather than the edges.  These expanded edges are then added to the <code>edges_to_ignore</code> list, available as a property of this class.</p> <p>Using this class</p> <ul> <li>Create a <code>NodeExpandedDiGraph</code> object by passing a directed graph <code>G</code> and the attribute name <code>node_flow_attr</code> from where to get the flow values / weights on the nodes.</li> <li>Pass the edges from the <code>edges_to_ignore</code> attribute of this class to the decomposition models, in order to ignore all original edges of the graph,   and thus consider in the constraints only the new edges added in the expanded graph (which have flow values).</li> <li>Solve the decomposition model on the expanded graph.</li> <li>Use the <code>get_condensed_paths</code> method to condense the solution paths (which are in the expanded graph) to paths in the original graph.</li> </ul>"},{"location":"node-expanded-digraph.html#flowpaths.nodeexpandeddigraph.NodeExpandedDiGraph--parameters","title":"Parameters","text":"<ul> <li> <p><code>G : nx.DiGraph</code></p> <p>The input directed graph, as networkx DiGraph.</p> </li> <li> <p><code>node_flow_attr : str</code></p> <p>The attribute name from where to get the flow values / weights on the nodes.  This attribute for each <code>v</code> is then set to the edge <code>(v.0, v.1)</code> connecting the new expanded nodes. This attribute can be missing from some nodes of the graph, in which case  the edge <code>(v.0, v.1)</code> is added to <code>edges_to_ignore</code>.</p> </li> <li> <p><code>try_filling_in_missing_flow_attr : bool</code>, optional</p> <p>If <code>True</code>, try filling in missing flow values in the expanded graph (i.e., if some original edge does not have the attribute specified by <code>node_flow_attr</code>),  by setting them to the flow values of a flow between the sources and the sinks of the original graph, such that for every edge where <code>node_flow_attr</code> is present, the demand and capacity are equal to the value specified by <code>node_flow_attr</code>. Default is <code>False</code>.</p> </li> <li> <p><code>node_length_attr : str</code>, optional</p> <p>The attribute name from where to get the length values on the nodes. Default is <code>None</code>.  If you specify this attribute, it may be missing from some nodes of the graph.</p> </li> </ul> <p>Example</p> <pre><code>import flowpaths as fp\nimport networkx as nx\n\ngraph = nx.DiGraph()\ngraph.add_node(\"s\", flow=13)\ngraph.add_node(\"a\", flow=6)\ngraph.add_node(\"b\", flow=9)\ngraph.add_node(\"c\", flow=13)\ngraph.add_node(\"d\", flow=6)\ngraph.add_node(\"t\", flow=13)\n\n# Adding edges\ngraph.add_edges_from([(\"s\", \"a\"), (\"s\", \"b\"), (\"a\", \"b\"), (\"a\", \"c\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"c\", \"t\"), (\"d\", \"t\")])\n\n# Expand the graph\nne_graph = fp.NodeExpandedDiGraph(graph, node_flow_attr=\"flow\")\n\n# Solve the problem on the expanded graph\nmfd_model = fp.MinFlowDecomp(\n    ne_graph, \n    flow_attr=\"flow\",\n    edges_to_ignore=ne_graph.edges_to_ignore,\n    )\nmfd_model.solve()\n\nif mfd_model.is_solved():\n    # Getting the solution in the expanded graph\n    solution = mfd_model.get_solution()\n    # Condensing the paths in the expanded graph to paths in the the original graph\n    original_paths = ne_graph.get_condensed_paths(solution[\"paths\"])\n    print(\"Original paths:\", original_paths)\n    print(\"Weights:\", solution[\"weights\"])\n</code></pre> Source code in <code>flowpaths/nodeexpandeddigraph.py</code> <pre><code>def __init__(\n        self,\n        G: nx.DiGraph,\n        node_flow_attr: str,\n        try_filling_in_missing_flow_attr: bool = False,\n        node_length_attr: str = None,\n        additional_starts: list = [],\n        additional_ends: list = [],\n        ):\n    \"\"\"\n    This class is a subclass of the networkx DiGraph class. It is used to represent a directed graph\n    where all nodes `v` have been \"expanded\" or \"subdivided\" into an edge `(v.0, v.1)`. This is useful for representing\n    graphs where the flow values, or weights, are associated with the nodes, rather than the edges. \n    These expanded edges are then added to the `edges_to_ignore` list, available as a property of this class.\n\n    !!! info \"Using this class\"\n\n        - Create a `NodeExpandedDiGraph` object by passing a directed graph `G` and the attribute name `node_flow_attr` from where to get the flow values / weights on the nodes.\n        - Pass the edges from the `edges_to_ignore` attribute of this class to the decomposition models, in order to ignore all original edges of the graph,\n          and thus consider in the constraints only the new edges added in the expanded graph (which have flow values).\n        - Solve the decomposition model on the expanded graph.\n        - Use the `get_condensed_paths` method to condense the solution paths (which are in the expanded graph) to paths in the original graph.\n\n    Parameters\n    ----------\n    - `G : nx.DiGraph`\n\n        The input directed graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html).\n\n    - `node_flow_attr : str`\n\n        The attribute name from where to get the flow values / weights on the nodes. \n        This attribute for each `v` is then set to the edge `(v.0, v.1)` connecting the new expanded nodes.\n        This attribute can be missing from some nodes of the graph, in which case \n        the edge `(v.0, v.1)` is added to `edges_to_ignore`.\n\n    - `try_filling_in_missing_flow_attr : bool`, optional\n\n        If `True`, try filling in missing flow values in the expanded graph (i.e., if some original edge does not have the attribute specified by `node_flow_attr`), \n        by setting them to the flow values of a flow between the sources and the sinks of the original graph, such that for every edge where `node_flow_attr` is present,\n        the demand and capacity are equal to the value specified by `node_flow_attr`.\n        Default is `False`.\n\n    - `node_length_attr : str`, optional\n\n        The attribute name from where to get the length values on the nodes. Default is `None`. \n        If you specify this attribute, it may be missing from some nodes of the graph.\n\n    !!! example \"Example\"\n\n        ```python\n        import flowpaths as fp\n        import networkx as nx\n\n        graph = nx.DiGraph()\n        graph.add_node(\"s\", flow=13)\n        graph.add_node(\"a\", flow=6)\n        graph.add_node(\"b\", flow=9)\n        graph.add_node(\"c\", flow=13)\n        graph.add_node(\"d\", flow=6)\n        graph.add_node(\"t\", flow=13)\n\n        # Adding edges\n        graph.add_edges_from([(\"s\", \"a\"), (\"s\", \"b\"), (\"a\", \"b\"), (\"a\", \"c\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"c\", \"t\"), (\"d\", \"t\")])\n\n        # Expand the graph\n        ne_graph = fp.NodeExpandedDiGraph(graph, node_flow_attr=\"flow\")\n\n        # Solve the problem on the expanded graph\n        mfd_model = fp.MinFlowDecomp(\n            ne_graph, \n            flow_attr=\"flow\",\n            edges_to_ignore=ne_graph.edges_to_ignore,\n            )\n        mfd_model.solve()\n\n        if mfd_model.is_solved():\n            # Getting the solution in the expanded graph\n            solution = mfd_model.get_solution()\n            # Condensing the paths in the expanded graph to paths in the the original graph\n            original_paths = ne_graph.get_condensed_paths(solution[\"paths\"])\n            print(\"Original paths:\", original_paths)\n            print(\"Weights:\", solution[\"weights\"])\n        ```\n    \"\"\"\n    super().__init__()\n\n    if G.number_of_nodes() == 0:\n            utils.logger.error(f\"{__name__}: The input graph G has no nodes. Please provide a graph with at least one node.\")\n            raise ValueError(f\"The input graph G has no nodes. Please provide a graph with at least one node.\")\n    if not all(isinstance(node, str) for node in G.nodes()):\n        utils.logger.error(f\"{__name__}: Graph id {utils.fpid(G)}: every node of the graph must be a string.\")\n        raise ValueError(\"Every node of the graph must be a string.\")\n\n    self.original_G = deepcopy(G)\n\n    if \"id\" in G.graph:\n        self.graph[\"id\"] = G.graph[\"id\"]\n\n    self.node_flow_attr = node_flow_attr\n    self.node_length_attr = node_length_attr\n\n    self.global_source_id = 'source' + str(id(self))\n    self.global_sink_id = 'sink' + str(id(self))\n\n    self._edges_to_ignore = []\n\n    for node in G.nodes:\n        node0 = node + '.0'\n        node1 = node + '.1'\n        self.add_node(node0, **G.nodes[node])\n        self.add_node(node1, **G.nodes[node])\n        self.add_edge(node0, node1, **G.nodes[node])\n        if self.node_flow_attr in G.nodes[node]:\n            self[node0][node1][self.node_flow_attr] = G.nodes[node][self.node_flow_attr]\n        else:\n            self._edges_to_ignore.append((node0, node1))\n        if self.node_length_attr is not None:\n            if self.node_length_attr in G.nodes[node]:\n                self[node0][node1][self.node_length_attr] = G.nodes[node][self.node_length_attr]\n\n        # Adding in-coming edges\n        for pred in G.predecessors(node):\n            pred1 = pred + '.1'\n            self.add_edge(pred1, node0, **G.edges[pred, node])\n            self._edges_to_ignore.append((pred1, node0))\n\n            # If the edge (pred,node) does not have the length attribute, set it to 0\n            if self.node_length_attr is not None:\n                if self.node_length_attr not in G.edges[pred, node]:\n                    self[pred1][node0][self.node_length_attr] = 0\n\n        # Adding out-going edges\n        for succ in G.successors(node):\n            succ0 = succ + '.0'\n            self.add_edge(node1, succ0, **G.edges[node, succ])\n            # This is not necessary, as the edge (node1, succ0) has already been added above, for succ\n            # self._edges_to_ignore.append((node1, succ0))\n\n    if (len(additional_starts) + len(additional_ends) &gt; 0) and not try_filling_in_missing_flow_attr:\n        utils.logger.error(f\"{__name__}: If `additional_starts` or `additional_ends` are specified, `try_filling_in_missing_flow_attr` must be set to True.\")\n        raise ValueError(\"If `additional_starts` or `additional_ends` are specified, `try_filling_in_missing_flow_attr` must be set to True.\")\n\n    if additional_starts != []:\n        self.add_node(self.global_source_id + '.0')\n        self.add_node(self.global_source_id + '.1')\n        new_edge = (self.global_source_id + '.0', self.global_source_id + '.1')\n        self.add_edges_from([new_edge])\n        self._edges_to_ignore.append(new_edge)\n\n        for node in additional_starts:\n            if node not in G.nodes:\n                utils.logger.error(f\"{__name__}: Node {node} not in the original graph.\")\n                raise ValueError(f\"Node {node} not in the original graph.\")\n            new_edge = (self.global_source_id + '.1', node + '.0', )\n            self.add_edges_from([new_edge])\n            self._edges_to_ignore.append(new_edge)\n\n    if additional_ends != []:\n        self.add_node(self.global_sink_id + '.0')\n        self.add_node(self.global_sink_id + '.1')\n        new_edge = (self.global_sink_id + '.0', self.global_sink_id + '.1')\n        self.add_edges_from([new_edge])\n        self._edges_to_ignore.append(new_edge)\n        for node in additional_ends or []:\n            if node not in G.nodes:\n                utils.logger.error(f\"{__name__}: Node {node} not in the original graph.\")\n                raise ValueError(f\"Node {node} not in the original graph.\")\n            new_edge = (node + '.1', self.global_sink_id + '.0')\n            self.add_edges_from([new_edge])\n            self._edges_to_ignore.append(new_edge)\n\n    if try_filling_in_missing_flow_attr:\n        self._try_filling_in_missing_flow_values()\n\n    nx.freeze(self)    \n</code></pre>"},{"location":"node-expanded-digraph.html#flowpaths.nodeexpandeddigraph.NodeExpandedDiGraph.edges_to_ignore","title":"edges_to_ignore  <code>property</code>","text":"<pre><code>edges_to_ignore\n</code></pre> <p>List of edges to ignore when solving the decomposition model on the expanded graph. </p> <p>These are the edges of the original graph, since only the new edges that have been introduced  for every node must considered in the decomposition model, with flow value from the node attribute <code>node_flow_attr</code>.</p>"},{"location":"node-expanded-digraph.html#flowpaths.nodeexpandeddigraph.NodeExpandedDiGraph.get_condensed_graph","title":"get_condensed_graph","text":"<pre><code>get_condensed_graph()\n</code></pre> <p>Return a condensed version of the expanded graph, by mapping the node attributes <code>self.node_flow_attr</code> and <code>self.node_length_attr</code>  from expanded edges back to the corresponding nodes of the original graph.</p> <p>This is useful when creating an expanded graph by some means, or correcting the flow values of an expanded graph, and then condensing this graph.</p> Source code in <code>flowpaths/nodeexpandeddigraph.py</code> <pre><code>def get_condensed_graph(self):\n    \"\"\"\n    Return a condensed version of the expanded graph, by mapping the node attributes `self.node_flow_attr` and `self.node_length_attr` \n    from expanded edges back to the corresponding nodes of the original graph.\n\n    This is useful when creating an expanded graph by some means, or correcting the flow values of an expanded graph, and then condensing this graph.\n    \"\"\"\n\n    condensed_graph = deepcopy(self.original_G)\n    for node in condensed_graph.nodes:\n        expanded_edge = self.get_expanded_edge(node)\n        if self.node_flow_attr in self.edges[expanded_edge]:\n            condensed_graph.nodes[node][self.node_flow_attr] = self.edges[expanded_edge][self.node_flow_attr]\n        if self.node_length_attr is not None:\n            if self.node_length_attr in self.edges[expanded_edge]:\n                condensed_graph.nodes[node][self.node_length_attr] = self.edges[expanded_edge][self.node_length_attr]\n\n    return condensed_graph\n</code></pre>"},{"location":"node-expanded-digraph.html#flowpaths.nodeexpandeddigraph.NodeExpandedDiGraph.get_condensed_paths","title":"get_condensed_paths","text":"<pre><code>get_condensed_paths(paths)\n</code></pre> <p>Condense a list of paths from the expanded graph to the original graph. </p> <p>This assumes that:</p> <ul> <li>The nodes in the expanded graph are named as \u2018node.0\u2019 and \u2018node.1\u2019, where \u2018node\u2019 is the name of the node in the original graph. </li> <li>The paths are lists of nodes in the expanded graph, where the nodes are ordered as \u2018nodeA.0\u2019, \u2018nodeA.1\u2019, \u2018nodeB.0\u2019, \u2018nodeB.1\u2019, etc. Meaning that we always have two nodes from the same original node in sequence.</li> </ul>"},{"location":"node-expanded-digraph.html#flowpaths.nodeexpandeddigraph.NodeExpandedDiGraph.get_condensed_paths--parameters","title":"Parameters","text":"<ul> <li> <p><code>paths : list</code></p> <p>List of paths in the expanded graph.</p> </li> </ul>"},{"location":"node-expanded-digraph.html#flowpaths.nodeexpandeddigraph.NodeExpandedDiGraph.get_condensed_paths--returns","title":"Returns","text":"<ul> <li> <p><code>condensed_paths: list</code></p> <p>List of paths in the original graph.</p> </li> </ul>"},{"location":"node-expanded-digraph.html#flowpaths.nodeexpandeddigraph.NodeExpandedDiGraph.get_condensed_paths--raises","title":"Raises","text":"<ul> <li> <p><code>ValueError</code></p> <ul> <li>If the node names in the expanded_path on even positions (starting from 0) do not end with <code>.0</code>.</li> <li>If these node names (with the suffix <code>.0</code> removed) are not in the original graph.</li> </ul> </li> </ul> Source code in <code>flowpaths/nodeexpandeddigraph.py</code> <pre><code>def get_condensed_paths(self, paths):\n    \"\"\"\n    Condense a list of paths from the expanded graph to the original graph. \n\n    This assumes that:\n\n    - The nodes in the expanded graph are named as 'node.0' and 'node.1', where 'node' is the name of the node in the\n    original graph. \n    - The paths are lists of nodes in the expanded graph, where the nodes are ordered as 'nodeA.0', 'nodeA.1', 'nodeB.0', 'nodeB.1', etc.\n    Meaning that we always have two nodes from the same original node in sequence.\n\n    Parameters\n    ----------\n    - `paths : list`\n\n        List of paths in the expanded graph.\n\n    Returns\n    -------\n    - `condensed_paths: list`\n\n        List of paths in the original graph.\n\n    Raises\n    ------\n    - `ValueError`\n\n        - If the node names in the expanded_path on even positions (starting from 0) do not end with `.0`.\n        - If these node names (with the suffix `.0` removed) are not in the original graph.\n    \"\"\"\n\n    condensed_paths = []\n    for path in paths:\n        condensed_path = []\n        for i in range(0, len(path) - 1, 2):\n            # Raise an error if the last two symbols of path[i] are not '.0'\n            if path[i][-2:] != '.0':\n                utils.logger.error(f\"{__name__}: Invalid node name in path: {path[i]}\")\n                raise ValueError(f\"Invalid node name in path: {path[i]}\")\n\n            node = path[i][:-2]\n            # Raise an error if the node is not in the original graph and is not the global source or sink\n            if node not in self.original_G.nodes and node not in [self.global_source_id, self.global_sink_id]:\n                utils.logger.error(f\"{__name__}: Node {node} not in the original graph.\")\n                raise ValueError(f\"Node {node} not in the original graph.\")\n\n            # Append the node to the condensed path only if it is not the global source or sink\n            if node not in [self.global_source_id, self.global_sink_id]:\n                condensed_path.append(node)\n        condensed_paths.append(condensed_path)\n    return condensed_paths\n</code></pre>"},{"location":"node-expanded-digraph.html#flowpaths.nodeexpandeddigraph.NodeExpandedDiGraph.get_expanded_edge","title":"get_expanded_edge","text":"<pre><code>get_expanded_edge(\n    graph_element,\n)\n</code></pre> <p>Given a node or an edge in the original graph, return the corresponding expanded edge in the expanded graph.</p> <ul> <li>If <code>graph_element</code> is some <code>node</code>, it returns the edge <code>('node.0', 'node.1')</code>.</li> <li>If <code>graph_element</code> is some <code>edge</code>, it returns the edge <code>('edge[0].1', 'edge[1].0')</code>.</li> </ul> <p>This is useful for converting nodes and edges in the original graph to the corresponding edges in the expanded graph.</p> Source code in <code>flowpaths/nodeexpandeddigraph.py</code> <pre><code>def get_expanded_edge(self, graph_element):\n    \"\"\"\n    Given a node or an edge in the original graph, return the corresponding expanded edge in the expanded graph.\n\n    - If `graph_element` is some `node`, it returns the edge `('node.0', 'node.1')`.\n    - If `graph_element` is some `edge`, it returns the edge `('edge[0].1', 'edge[1].0')`.\n\n    This is useful for converting nodes and edges in the original graph to the corresponding edges in the expanded graph.\n    \"\"\"\n\n    if isinstance(graph_element, str):   \n        node = graph_element         \n        if node not in self.original_G.nodes:\n            utils.logger.error(f\"{__name__}: Node {node} not in the original graph.\")\n            raise ValueError(f\"Node {node} not in the original graph.\")\n        return (node + '.0', node + '.1')\n\n    elif isinstance(graph_element, tuple):\n        edge = graph_element\n        if edge not in self.original_G.edges:\n            utils.logger.error(f\"{__name__}: Edge {edge} not in the original graph.\")\n            raise ValueError(f\"Edge {edge} not in the original graph.\")\n        return (edge[0] + '.1', edge[1] + '.0')\n    else:\n        utils.logger.error(f\"{__name__}: Graph element must be a node or an edge, not {graph_element}.\")\n        raise ValueError(f\"Graph element must be a node or an edge, not {graph_element}.\")\n</code></pre>"},{"location":"node-expanded-digraph.html#flowpaths.nodeexpandeddigraph.NodeExpandedDiGraph.get_expanded_subpath_constraints","title":"get_expanded_subpath_constraints","text":"<pre><code>get_expanded_subpath_constraints(\n    subpath_constraints,\n)\n</code></pre> <p>Expand a list of subpath constraints from the original graph (where every constraint is a list nodes or edges in the original graph) to a list of subpath constraints in the expanded graph (where every constraint  is a list of edges in the expanded graph). </p> <ul> <li>If the constraints are lists of nodes, then the corresponding edges are of type <code>('node.0', 'node.1')</code> </li> <li>If the constraints are lists of edges of the form <code>(u,v)</code>, then the corresponding edges are of type <code>('u.1', 'v.0')</code></li> </ul>"},{"location":"node-expanded-digraph.html#flowpaths.nodeexpandeddigraph.NodeExpandedDiGraph.get_expanded_subpath_constraints--parameters","title":"Parameters","text":"<ul> <li> <p><code>subpath_constraints : list</code></p> <p>List of subpath constraints in the original graph.</p> </li> </ul>"},{"location":"node-expanded-digraph.html#flowpaths.nodeexpandeddigraph.NodeExpandedDiGraph.get_expanded_subpath_constraints--returns","title":"Returns","text":"<ul> <li> <p><code>expanded_constraints : list</code></p> <p>List of subpath constraints in the expanded graph.</p> </li> </ul> Source code in <code>flowpaths/nodeexpandeddigraph.py</code> <pre><code>def get_expanded_subpath_constraints(self, subpath_constraints):\n    \"\"\"\n    Expand a list of subpath constraints from the original graph (where every constraint is a list **nodes** or **edges**\n    in the original graph) to a list of subpath constraints in the expanded graph (where every constraint \n    is a list of edges in the expanded graph). \n\n    - If the constraints are lists of nodes, then the corresponding edges are of type `('node.0', 'node.1')` \n    - If the constraints are lists of edges of the form `(u,v)`, then the corresponding edges are of type `('u.1', 'v.0')`\n\n    Parameters\n    ----------\n    - `subpath_constraints : list`\n\n        List of subpath constraints in the original graph.\n\n    Returns\n    -------\n    - `expanded_constraints : list`\n\n        List of subpath constraints in the expanded graph.\n    \"\"\"\n\n    # Check if the subpath constraints are lists of node or lists of edges,\n    # and expand them accordingly, using the two functions already implemented.\n\n    if not isinstance(subpath_constraints, list):\n        utils.logger.error(f\"{__name__}: Subpath constraints must be a list.\")\n        raise ValueError(\"Subpath constraints must be a list.\")\n    if not all(isinstance(constraint, list) for constraint in subpath_constraints):\n        utils.logger.error(f\"{__name__}: Subpath constraints must be a list of lists.\")\n        raise ValueError(\"Subpath constraints must be a list of lists.\")\n\n    if len(subpath_constraints) == 0:\n        return []\n\n    if isinstance(subpath_constraints[0][0], str):\n        return self._get_expanded_subpath_constraints_nodes(subpath_constraints)\n    elif isinstance(subpath_constraints[0][0], tuple):\n        return self._get_expanded_subpath_constraints_edges(subpath_constraints)\n    else:\n        utils.logger.error(f\"{__name__}: Subpath constraints must be a list of lists of nodes or edges.\")\n        raise ValueError(\"Subpath constraints must be a list of lists of nodes or edges.\")\n</code></pre>"},{"location":"numpathsoptimization.html","title":"An Optimization Routine for the Number of Paths","text":"<p>Models implemented with the class <code>AbstractPathModelDAG</code> assume a fixed number \\(k\\) of paths. This class provides an automatic method of iterating in an increasing manner over values of \\(k\\) to find the best one (i.e., when a stopping criterion has been met).</p> <p>For example, our custom class for the Minimum Flow Decomposition problem could be emulated like in the code below. However, <code>MinFlowDecomp</code> implements also many other optimizations that make it much faster than this generic routine.</p> <pre><code>mfd_model = fp.NumPathsOptimization(\n        model_type = fp.kFlowDecomp,\n        stop_on_first_feasible=True,\n        G=graph, \n        flow_attr=\"flow\",\n        )\n</code></pre> <p>If you want to pass additional parameters to the model, you can just add append them, for example:</p> <pre><code>mfd_model = fp.NumPathsOptimization(\n        model_type = fp.kFlowDecomp,\n        stop_on_first_feasible=True,\n        G=graph, \n        flow_attr=\"flow\",\n        subpath_constraints=[[(\"a\", \"c\"),(\"c\", \"t\")]], \n        subpath_constraints_coverage=0.5, \n        optimization_options={\"optimize_with_greedy\": False}\n        )\n</code></pre>"},{"location":"numpathsoptimization.html#flowpaths.numpathsoptimization.NumPathsOptimization","title":"NumPathsOptimization","text":"<pre><code>NumPathsOptimization(\n    model_type: AbstractPathModelDAG,\n    stop_on_first_feasible: bool = None,\n    stop_on_delta_abs: float = None,\n    stop_on_delta_rel: float = None,\n    min_num_paths: int = 1,\n    max_num_paths: int = 2\n    ** 64,\n    time_limit: float = float(\n        \"inf\"\n    ),\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>AbstractPathModelDAG</code></p> <p>This is a generic class to find the \u201cbest\u201d number of paths optimization problems implemented using <code>AbstractPathModelDAG</code>, and which are parameterized by the number of paths to be considered. The class iterates over a range of path numbers <code>k</code>, creating and solving a model for each path number until one of the stopping conditions is met.</p>"},{"location":"numpathsoptimization.html#flowpaths.numpathsoptimization.NumPathsOptimization--parameters","title":"Parameters","text":"<ul> <li> <p><code>model_type : AbstractPathModelDAG</code></p> <p>The type of the model used for optimization.</p> </li> <li> <p><code>stop_on_first_feasible : bool</code>, optional</p> <p>If True, the optimization process stops as soon as a feasible solution is found. Default is None.</p> </li> <li> <p><code>stop_on_delta_abs</code> : float, optional</p> <p>The threshold for change (in absolute value) in objective value between iterations to determine stopping the optimization. Default is <code>None</code>.</p> </li> <li> <p><code>stop_on_delta_rel</code> : float, optional</p> <p>The relative threshold for change (in absolute value) in objective value between iterations to determine stopping the optimization.  This is computed as the difference in objective value between iterations divided by the objective value of the previous iteration. Default is <code>None</code>.</p> <p>Pass at least one stopping criterion</p> <p>At least one of the stopping criterion must be set: <code>stop_on_first_feasible</code>, <code>stop_on_delta_abs</code>, <code>stop_on_delta_rel</code>.</p> </li> <li> <p><code>min_num_paths : int</code>, optional</p> <p>Minimum number of paths to be considered in the optimization. Default is 1. The class will also call <code>get_lowerbound_k()</code> on the <code>model_type</code> and the provided arguments to get a better lower bound for the number of paths.</p> </li> <li> <p><code>max_num_paths : int</code>, optional</p> <p>Maximum number of paths to be computed. Default is <code>2**64</code>.</p> </li> <li> <p><code>time_limit : float</code>, optional</p> <p>Time limit (in seconds) for the optimization process. Default is <code>float(\"inf\")</code>.</p> </li> <li> <p><code>**kwargs</code></p> <p>The keyword arguments to be passed to the model. </p> <p>Note</p> <p>Do not pass the parameter <code>k</code> here, as it will be handled by the internal optimization process.</p> </li> </ul>"},{"location":"numpathsoptimization.html#flowpaths.numpathsoptimization.NumPathsOptimization--raises","title":"Raises","text":"<ul> <li> <p><code>ValueError</code></p> <p>If none of the stopping criteria (<code>stop_on_first_feasible</code>, <code>stop_on_delta_abs</code>, or <code>stop_on_delta_rel</code>) is provided (i.e., all are <code>None</code>).</p> </li> </ul> Source code in <code>flowpaths/numpathsoptimization.py</code> <pre><code>def __init__(\n    self,\n    model_type: pathmodel.AbstractPathModelDAG,\n    stop_on_first_feasible: bool = None,\n    stop_on_delta_abs: float = None,\n    stop_on_delta_rel: float = None,\n    min_num_paths: int = 1,\n    max_num_paths: int = 2**64,\n    time_limit: float = float(\"inf\"),\n    **kwargs,\n):\n    \"\"\"\n    This is a generic class to find the \"best\" number of paths optimization problems implemented using `AbstractPathModelDAG`,\n    and which are parameterized by the number of paths to be considered.\n    The class iterates over a range of path numbers `k`, creating and  \n    solving a model for each path number until one of the stopping conditions is met.\n\n    Parameters\n    ----------\n\n    - `model_type : AbstractPathModelDAG`\n\n        The type of the model used for optimization.\n\n    - `stop_on_first_feasible : bool`, optional\n\n        If True, the optimization process stops as soon as a feasible solution is found.\n        Default is None.\n\n    - `stop_on_delta_abs` : float, optional\n\n        The threshold for change (in absolute value) in objective value between iterations to determine stopping the optimization.\n        Default is `None`.\n\n    - `stop_on_delta_rel` : float, optional\n\n        The relative threshold for change (in absolute value) in objective value between iterations to determine stopping the optimization. \n        This is computed as the difference in objective value between iterations divided by the objective value of the previous iteration.\n        Default is `None`.\n\n        !!! warning \"Pass at least one stopping criterion\"\n            At least one of the stopping criterion must be set: `stop_on_first_feasible`, `stop_on_delta_abs`, `stop_on_delta_rel`.\n\n    - `min_num_paths : int`, optional\n\n        Minimum number of paths to be considered in the optimization.\n        Default is 1. The class will also call `get_lowerbound_k()` on the `model_type` and the provided arguments to get a better lower bound for the number of paths.\n\n    - `max_num_paths : int`, optional\n\n        Maximum number of paths to be computed.\n        Default is `2**64`.\n\n    - `time_limit : float`, optional\n\n        Time limit (in seconds) for the optimization process.\n        Default is `float(\"inf\")`.\n\n    - `**kwargs`\n\n        The keyword arguments to be passed to the model. \n\n        !!! warning \"Note\"\n\n            Do not pass the parameter `k` here, as it will be handled by the internal optimization process.\n\n    Raises\n    ------\n\n    - `ValueError`\n\n        If none of the stopping criteria (`stop_on_first_feasible`, `stop_on_delta_abs`, or\n        `stop_on_delta_rel`) is provided (i.e., all are `None`).\n    \"\"\"\n\n    self.model_type = model_type\n    self.stop_on_first_feasible = stop_on_first_feasible\n    self.stop_on_delta_abs = stop_on_delta_abs\n    self.stop_on_delta_rel = stop_on_delta_rel\n    self.min_num_paths = min_num_paths\n    self.max_num_paths = max_num_paths\n    self.time_limit = time_limit\n    self.solve_time_start = None\n    self.kwargs = kwargs\n\n    # We allow only one of the stopping criteria to be set\n    if (stop_on_first_feasible is None) and (stop_on_delta_abs is None) and (stop_on_delta_rel is None):\n        raise ValueError(\n            \"At least one of the stopping criteria must be set: stop_on_first_feasible, stop_on_delta_abs, stop_on_delta_rel\"\n        )\n\n    if 'k' in self.kwargs:\n        raise ValueError(\"Do not pass the parameter `k` in the keyword arguments of NumPathsOptimization. This will be iterated over internally to find the best number of paths according to the stopping criteria.\")\n\n    self.lowerbound_k = None\n    self._solution = None\n    self.solve_statistics = None\n\n    utils.logger.info(f\"{__name__}: created NumPathsOptimization with model_type = {model_type}\")\n</code></pre>"},{"location":"numpathsoptimization.html#flowpaths.numpathsoptimization.NumPathsOptimization.solve_time_elapsed","title":"solve_time_elapsed  <code>property</code>","text":"<pre><code>solve_time_elapsed\n</code></pre> <p>Returns the elapsed time since the start of the solve process.</p>"},{"location":"numpathsoptimization.html#flowpaths.numpathsoptimization.NumPathsOptimization.solve_time_elapsed--returns","title":"Returns","text":"<ul> <li> <p><code>float</code></p> <p>The elapsed time in seconds.</p> </li> </ul>"},{"location":"numpathsoptimization.html#flowpaths.numpathsoptimization.NumPathsOptimization.get_objective_value","title":"get_objective_value","text":"<pre><code>get_objective_value()\n</code></pre> <p>Returns the objective value of the model, if it is solved. Otherwise, raises an exception.</p> Source code in <code>flowpaths/numpathsoptimization.py</code> <pre><code>def get_objective_value(self):\n    \"\"\"\n    Returns the objective value of the model, if it is solved. Otherwise, raises an exception.\n    \"\"\"\n\n    self.check_is_solved()\n\n    return self.model.get_objective_value()\n</code></pre>"},{"location":"numpathsoptimization.html#flowpaths.numpathsoptimization.NumPathsOptimization.get_solution","title":"get_solution","text":"<pre><code>get_solution()\n</code></pre> <p>Retrieves the solution for the flow decomposition problem.</p>"},{"location":"numpathsoptimization.html#flowpaths.numpathsoptimization.NumPathsOptimization.get_solution--returns","title":"Returns","text":"<ul> <li> <p><code>solution: dict</code></p> <p>The solution obtained from the model</p> </li> </ul>"},{"location":"numpathsoptimization.html#flowpaths.numpathsoptimization.NumPathsOptimization.get_solution--raises","title":"Raises","text":"<ul> <li><code>exception</code> If model is not solved.</li> </ul> Source code in <code>flowpaths/numpathsoptimization.py</code> <pre><code>def get_solution(self):\n    \"\"\"\n    Retrieves the solution for the flow decomposition problem.\n\n    Returns\n    -------\n\n    - `solution: dict`\n\n        The solution obtained from the model\n\n    Raises\n    -------\n\n    - `exception` If model is not solved.\n    \"\"\"\n\n    self.check_is_solved()\n    return self._solution\n</code></pre>"},{"location":"numpathsoptimization.html#flowpaths.numpathsoptimization.NumPathsOptimization.is_valid_solution","title":"is_valid_solution","text":"<pre><code>is_valid_solution() -&gt; bool\n</code></pre> <p>Checks if the solution is valid, by calling the <code>is_valid_solution()</code> method of the model.</p> Source code in <code>flowpaths/numpathsoptimization.py</code> <pre><code>def is_valid_solution(self) -&gt; bool:\n    \"\"\"\n    Checks if the solution is valid, by calling the `is_valid_solution()` method of the model.\n    \"\"\"\n    return self.model.is_valid_solution()\n</code></pre>"},{"location":"numpathsoptimization.html#flowpaths.numpathsoptimization.NumPathsOptimization.solve","title":"solve","text":"<pre><code>solve() -&gt; bool\n</code></pre> <p>Attempts to solve the optimization problem by iterating over a range of path counts, creating and solving a model for each count until one of the stopping conditions is met. The method iterates from the maximum between the minimum allowed paths and a lower bound (via <code>get_lowerbound_k()</code> of the model) to the maximum allowed paths. For each iteration:</p> <ul> <li>Creates a model instance with the current number of paths (<code>k</code>).</li> <li>Solves the model, and checks if it has been successfully solved.</li> <li> <p>Applies various stopping criteria including:</p> <ul> <li><code>stop_on_first_feasible</code>: stops at the first feasible solution.</li> <li><code>stop_on_delta_abs</code>: stops if the absolute change in the objective value between iterations is     less than or equal to the <code>stop_on_delta_abs</code> value.</li> <li><code>stop_on_delta_rel</code>: stops if the relative change in the objective value between iterations is     less than or equal to the <code>stop_on_delta_rel</code> value.</li> </ul> </li> <li> <p>Stops if the elapsed time exceeds the designated time limit.</p> </li> </ul> <p>Upon termination, the method sets the overall solve status:</p> <ul> <li>If no feasible solution was found, the status is marked as infeasible.</li> <li>If the process did not exceed the time limit but no other stopping condition was met, the status     is marked as unbounded.</li> <li>If any of the stopping criteria (feasible or delta conditions) were satisfied, the status is set as solved.</li> </ul> <p>If a valid solution is found, it stores the solution, updates solve statistics and the model, marks the problem as solved, and returns <code>True</code>. Otherwise, it returns <code>False</code>.</p>"},{"location":"numpathsoptimization.html#flowpaths.numpathsoptimization.NumPathsOptimization.solve--returns","title":"Returns","text":"<ul> <li> <p><code>bool</code></p> <p><code>True</code> if an optimal solution is found and the problem is marked as solved, <code>False</code> otherwise.</p> </li> </ul> Source code in <code>flowpaths/numpathsoptimization.py</code> <pre><code>def solve(self) -&gt; bool:\n    \"\"\"\n    Attempts to solve the optimization problem by iterating over a range of path counts, creating and\n    solving a model for each count until one of the stopping conditions is met.\n    The method iterates from the maximum between the minimum allowed paths and a lower bound (via\n    `get_lowerbound_k()` of the model) to the maximum allowed paths. For each iteration:\n\n    - Creates a model instance with the current number of paths (`k`).\n    - Solves the model, and checks if it has been successfully solved.\n    - Applies various stopping criteria including:\n\n        - `stop_on_first_feasible`: stops at the first feasible solution.\n        - `stop_on_delta_abs`: stops if the absolute change in the objective value between iterations is\n            less than or equal to the `stop_on_delta_abs` value.\n        - `stop_on_delta_rel`: stops if the relative change in the objective value between iterations is\n            less than or equal to the `stop_on_delta_rel` value.\n\n    - Stops if the elapsed time exceeds the designated time limit.\n\n    Upon termination, the method sets the overall solve status:\n\n    - If no feasible solution was found, the status is marked as infeasible.\n    - If the process did not exceed the time limit but no other stopping condition was met, the status\n        is marked as unbounded.\n    - If any of the stopping criteria (feasible or delta conditions) were satisfied, the status is set as solved.\n\n    If a valid solution is found, it stores the solution, updates solve statistics and the model,\n    marks the problem as solved, and returns `True`. Otherwise, it returns `False`.\n\n    Returns\n    -------\n\n    - `bool`\n\n        `True` if an optimal solution is found and the problem is marked as solved, `False` otherwise.\n\n    \"\"\"\n\n    self.solve_time_start = time.perf_counter()\n    previous_solution_objective_value = None\n    solve_status = None\n    found_feasible = False\n\n    for k in range(max(self.min_num_paths,self.get_lowerbound_k()), self.max_num_paths+1):\n        # Create the model\n        utils.logger.info(f\"{__name__}: model id = {id(self)}, iteration with k = {k}\")\n        model = self.model_type(**self.kwargs, k=k)\n        model.solve()\n        if model.is_solved():\n            found_feasible = True\n            current_solution_objective_value = model.get_objective_value()\n            utils.logger.info(f\"{__name__}: model id = {id(self)}, iteration with k = {k}, current_solution_objective_value = {current_solution_objective_value}\")\n            if self.stop_on_first_feasible:\n                solve_status = NumPathsOptimization.solved_status_name\n                break\n            if self.stop_on_delta_abs:\n                if previous_solution_objective_value is None:\n                    previous_solution_objective_value = current_solution_objective_value\n                else:\n                    if abs(previous_solution_objective_value - current_solution_objective_value) &lt;= self.stop_on_delta_abs:\n                        solve_status = NumPathsOptimization.solved_status_name\n                        break\n            if self.stop_on_delta_rel:\n                if previous_solution_objective_value is None:\n                    previous_solution_objective_value = current_solution_objective_value\n                else:\n                    if abs(previous_solution_objective_value - current_solution_objective_value) / previous_solution_objective_value &lt;= self.stop_on_delta_rel:\n                        solve_status = NumPathsOptimization.solved_status_name\n                        break\n        else:\n            utils.logger.info(f\"{__name__}: model id = {id(self)}, iteration with k = {k}, model is not solved\")\n        if self.solve_time_elapsed &gt; self.time_limit:\n            solve_status = NumPathsOptimization.timeout_status_name\n            utils.logger.info(f\"{__name__}: model id = {id(self)}, iteration with k = {k}, time out\")\n            break\n\n    if solve_status != NumPathsOptimization.timeout_status_name:\n        if not found_feasible:\n            solve_status = NumPathsOptimization.infeasible_status_name\n        elif solve_status is None:\n            solve_status = NumPathsOptimization.unbounded_status_name\n\n    self.solve_statistics = {\n            \"solve_status\": solve_status,\n            \"solve_time\": self.solve_time_elapsed,\n        }\n\n    if solve_status == NumPathsOptimization.solved_status_name:\n        self._solution = model.get_solution()\n        self.set_solved()\n        self.solve_statistics.update(model.solve_statistics)\n        self.model = model\n        return True\n\n    return False\n</code></pre>"},{"location":"references.html","title":"References","text":"<p>The (M)ILPs for flow decomposition-like problems at the core of this package appeared in: </p> <ol> <li> <p>Fernando H. C. Dias, Lucia Williams, Brendan Mumey, Alexandru I. Tomescu,  Fast, Flexible, and Exact Minimum Flow Decompositions via ILP, RECOMB 2022 - 26th Annual International Conference on Research in Computational Molecular Biology, Lecture Notes in Computer Science 13278, 230\u2013245, 2022 (preprint)</p> </li> <li> <p>Fernando H.C. Dias, Lucia Williams, Brendan Mumey, Alexandru I. Tomescu, Efficient Minimum Flow Decomposition via Integer Linear Programming, Journal of Computational Biology 29(11), 1\u201316, 2022</p> </li> <li> <p>Fernando H. C. Dias, Lucia Williams, Brendan Mumey, Alexandru I. Tomescu Minimum Flow Decomposition in Graphs with Cycles using Integer Linear Programming, Journal of Global Optimization, 2025</p> </li> <li> <p>Fernando H. C. Dias, Alexandru I. Tomescu Accurate Flow Decomposition via Robust Integer Linear Programming IEEE/ACM Transactions on Computational Biology and Bioinformatics 21(6), 1955-1964, 2024 (preprint)</p> </li> </ol> <p>The flow decomposition with subpath constraints problem was formalized in:</p> <ol> <li>Lucia Williams, Alexandru I. Tomescu, Brendan Mumey Flow Decomposition with Subpath Constraints, IEEE/ACM Transactions on Computational Biology and Bioinformatics 20(1), 360\u2013370, 2023</li> </ol> <p>The safety optimizations applied to all the path-/walk-finding models appeared in:</p> <ol> <li> <p>Andreas Grigorjew, Fernando H. C. Dias, Andrea Cracco, Romeo Rizzi, Alexandru I. Tomescu Accelerating ILP solvers for Minimum Flow Decompositions through search space and dimensionality reductions SEA 2024 - 22nd International Symposium on Experimental Algorithms, Leibniz International Proceedings in Informatics (LIPIcs) 301, 14:1\u201314:19, 2024</p> </li> <li> <p>Francisco Sena, Alexandru I. Tomescu Francisco Sena, Romeo Rizzi, Alexandru I. Tomescu Safe Sequences via Dominators in DAGs for Path-Covering Problems, ESA 2025 - 33rd Annual European Symposium on Algorithms (Track B), 55:1\u201355:17, 2025</p> </li> <li> <p>Francisco Sena, Alexandru I. Tomescu Fast and Flexible Flow Decompositions in General Graphs via Dominators, arXiv, 2025</p> </li> </ol> <p>See the page of each decomposition model for some references to papers introducing them.</p>"},{"location":"solver-options-optimizations.html","title":"Solver options and optimizations","text":"<p>The AbstractPathModelDAG class can receive several options for the Mixed Integer Linear Programming solvers that is uses to solve the problems. </p>"},{"location":"solver-options-optimizations.html#1-milp-solver-options","title":"1. MILP solver options","text":"<p>Set this options by passing a dictionary <code>solver_options</code>, with the following possible keys, and values:</p> <ul> <li><code>\"threads\"</code> (int): Number of threads to use. Defaults to 4.</li> <li><code>\"time_limit\"</code> (int): Time limit for solving in seconds. Defaults to Infinity.</li> <li><code>\"presolve\"</code> (str): Presolve option. Defaults to <code>\"choose\"</code>.</li> <li><code>\"log_to_console\"</code> (str): Log to console option. Defaults to <code>\"false\"</code>.</li> <li><code>\"external_solver\"</code> (str): External solver to use. Defaults to <code>\"highs\"</code>.</li> </ul> <p>Time limit</p> <p>Large or complex graphs may take more than the default 300 seconds to run. In this case, <code>your_model.is_solved()</code> will be <code>False</code>. You can also check the model status with <code>your_model.get_model_status()</code>. If it equals <code>\"kTimeLimit\"</code>, then you should pass a larger <code>\"time_limit\"</code>.</p> <p>Example:</p> <pre><code>solver_options = {\n    \"threads\": 8,\n    \"time_limit\": 3600,\n}\n\nyour_model = fp.kMinPathError(\n    G=graph,\n    k=5,\n    flow_attr=\"flow\",\n    solver_options=solver_options,\n)\n</code></pre>"},{"location":"solver-options-optimizations.html#2-optimizations","title":"2. Optimizations","text":"<p>Flowpaths implements several optimizations that reduce the search space for the solution paths, based on the structure of the graph, while guaranteeing exact solutions. A typical user does not need to worry about these. However, they can be changed by passing a dictionary <code>optimization_options</code>, with the following possible keys, and values:</p> <ul> <li><code>\"optimize_with_safe_paths\"</code> (bool): Whether to optimize with safe paths. Defaults to <code>True</code>.</li> <li><code>\"optimize_with_flow_safe_paths\"</code> (bool): Whether to optimize with flow-safe paths. This applied only to the Minimum Flow Decomposition problem and defaults to <code>True</code>. This overrides <code>\"optimize_with_safe_paths\"</code>.</li> <li><code>\"optimize_with_safe_sequences\"</code> (bool): Whether to optimize with safe sequences. Defaults to <code>False</code>. At the moment, you cannot set both <code>\"optimize_with_safe_paths\"</code> and <code>\"optimize_with_safe_sequences\"</code>.</li> <li><code>\"optimize_with_safe_zero_edges\"</code> (bool): Whether to optimize with safe zero edges. Defaults to <code>False</code>. You cannot set this without setting one of the above.</li> </ul> <p>Example:</p> <pre><code>optimization_options = {\n    \"optimize_with_safe_paths\": False,\n    \"optimize_with_safe_sequences\": True\n}\n\nyour_model = fp.kMinPathError(\n    G=graph,\n    k=5,\n    flow_attr=\"flow\",\n    optimization_options=optimization_options,\n)\n</code></pre>"},{"location":"solver-wrapper.html","title":"Solver Wrapper","text":""},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.HighsCustom","title":"HighsCustom","text":"<pre><code>HighsCustom()\n</code></pre> <p>               Bases: <code>Highs</code></p> <p>Thin subclass of <code>highspy.Highs</code> exposing a no-solve objective setter.</p> <p>The stock <code>Highs</code> object couples <code>minimize</code> / <code>maximize</code> with an immediate solve. For modelling convenience we sometimes want to build a model incrementally and set/replace an objective multiple times before the first solve. <code>set_objective_without_solving</code> mirrors the internal logic of <code>Highs.minimize</code> / <code>Highs.maximize</code> sans the final call to <code>solve</code>.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def __init__(self):\n    super().__init__()\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.HighsCustom.set_objective_without_solving","title":"set_objective_without_solving","text":"<pre><code>set_objective_without_solving(\n    obj,\n    sense: str = \"minimize\",\n) -&gt; None\n</code></pre> <p>Set objective coefficients and sense without triggering <code>solve</code>.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.HighsCustom.set_objective_without_solving--parameters","title":"Parameters","text":"<p>obj : linear expression     Must be a linear expression (a single variable should be wrapped     by the caller). Inequality expressions are rejected. sense : {\u201cminimize\u201d, \u201cmin\u201d, \u201cmaximize\u201d, \u201cmax\u201d}, default \u201cminimize\u201d     Optimization direction.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.HighsCustom.set_objective_without_solving--raises","title":"Raises","text":"<p>Exception     If the provided expression encodes an inequality. ValueError     If <code>sense</code> is invalid.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def set_objective_without_solving(self, obj, sense: str = \"minimize\") -&gt; None:\n    \"\"\"Set objective coefficients and sense without triggering ``solve``.\n\n    Parameters\n    ----------\n    obj : linear expression\n        Must be a linear expression (a single variable should be wrapped\n        by the caller). Inequality expressions are rejected.\n    sense : {\"minimize\", \"min\", \"maximize\", \"max\"}, default \"minimize\"\n        Optimization direction.\n\n    Raises\n    ------\n    Exception\n        If the provided expression encodes an inequality.\n    ValueError\n        If ``sense`` is invalid.\n    \"\"\"\n\n    if obj is not None:\n        # if we have a single variable, wrap it in a linear expression\n        # expr = highspy.highs_linear_expression(obj) if isinstance(obj, highspy.highs_var) else obj\n        expr = obj\n\n        if expr.bounds is not None:\n            raise Exception(\"Objective cannot be an inequality\")\n\n        # reset objective\n        super().changeColsCost(\n            self.numVariables,\n            np.arange(self.numVariables, dtype=np.int32),\n            np.full(self.numVariables, 0, dtype=np.float64),\n        )\n\n        # if we have duplicate variables, add the vals\n        idxs, vals = expr.unique_elements()\n        super().changeColsCost(len(idxs), idxs, vals)\n        super().changeObjectiveOffset(expr.constant or 0.0)\n\n    if sense in [\"minimize\", \"min\"]:\n        super().changeObjectiveSense(highspy.ObjSense.kMinimize)\n    elif sense in [\"maximize\", \"max\"]:\n        super().changeObjectiveSense(highspy.ObjSense.kMaximize)\n    else:\n        raise ValueError(f\"Invalid objective sense: {sense}. Use 'minimize' or 'maximize'.\")\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper","title":"SolverWrapper","text":"<pre><code>SolverWrapper(**kwargs)\n</code></pre> <p>Unified MILP/LP modelling convenience layer for HiGHS and Gurobi.</p> <p>This class provides one API that delegates to either the HiGHS (<code>highspy</code>) or Gurobi (<code>gurobipy</code>) back-end. Only a very small, stable subset of features needed by flowpaths is wrapped - it is not a general purpose replacement for the native APIs.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper--key-capabilities","title":"Key capabilities","text":"<ul> <li>Create variables (continuous / integer) in bulk with name prefixing</li> <li>Add linear constraints</li> <li>Add specialized modelling shortcuts:         - binary * continuous (McCormick) product constraints         - integer * continuous product constraints (bit expansion + binaries)         - piecewise constant constraints (one-hot selection)</li> <li>Build linear objectives without triggering a solve (HiGHS) or with native     semantics (Gurobi)</li> <li>Optimize with optional custom wall clock timeout (in addition to the     solver internal time limit)</li> <li>Retrieve objective, variable names, variable values (optionally enforcing     integrality for binaries), status (mapped to HiGHS style codes)</li> <li>Persist model to disk (<code>.lp</code> / <code>.mps</code> depending on backend support)</li> </ul>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper--design-notes","title":"Design notes","text":"<ul> <li>A minimal set of solver parameters is exposed via keyword arguments in     <code>__init__</code> to keep call sites clean.</li> <li>Status codes for Gurobi are mapped onto HiGHS style names where a clear     1-to-1 mapping exists (see <code>gurobi_status_to_highs</code>).</li> <li>A secondary timeout based on POSIX signals can be enabled to guard     against situations where the native solver time limit is not obeyed     precisely. When this fires <code>did_timeout</code> is set and the reported status     becomes <code>kTimeLimit</code>.</li> </ul>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper--parameters","title":"Parameters","text":"<p>kwargs :     Flexible configuration. Recognised keys (all optional):     - <code>external_solver</code> (str): <code>\"highs\"</code> (default) or <code>\"gurobi\"</code>.     - <code>threads</code> (int): Thread limit for solver (default: <code>4</code>).     - <code>time_limit</code> (float): Internal solver time limit in seconds         (default: <code>inf</code> = no limit).     - <code>use_also_custom_timeout</code> (bool): If <code>True</code> activate an extra         signal based timeout equal to <code>time_limit</code> (default <code>False</code>).     - <code>presolve</code> (str): HiGHS presolve strategy (default <code>\"choose\"</code>).     - <code>log_to_console</code> (str): <code>\"true\"</code> / <code>\"false\"</code> (default         <code>\"false\"</code>) - normalized to solver specific flags.     - <code>tolerance</code> (float): MIP gap, feasibility, integrality tolerance         applied uniformly (default <code>1e-9</code>; must be &gt;= 1e-9).     - <code>optimization_sense</code> (str): <code>\"minimize\"</code> or <code>\"maximize</code>         (default <code>\"minimize\"</code>).</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper--attributes","title":"Attributes","text":"<p>external_solver : str         Active backend (<code>\"highs\"</code> or <code>\"gurobi\"</code>). solver : object         Underlying solver object (<code>highspy.Highs</code> or <code>gurobipy.Model</code>). time_limit : float         Configured internal solver time limit (seconds). use_also_custom_timeout : bool         Whether the secondary POSIX signal timeout is enabled. tolerance : float         Unified tolerance applied to various solver parameters. optimization_sense : str         <code>\"minimize\"</code> or <code>\"maximize\"</code> as last set on the objective. did_timeout : bool     Flag set to <code>True</code> only when the custom timeout fired.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper--raises","title":"Raises","text":"<p>ValueError     If unsupported solver name, invalid optimization sense or an invalid     tolerance (&lt; 1e-9) is supplied.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def __init__(\n    self,\n    **kwargs\n    ):\n\n    self.external_solver = kwargs.get(\"external_solver\", SolverWrapper.external_solver)  # Default solver\n    self.time_limit = kwargs.get(\"time_limit\", SolverWrapper.time_limit)\n    self.use_also_custom_timeout = kwargs.get(\"use_also_custom_timeout\", SolverWrapper.use_also_custom_timeout)\n    self.tolerance = kwargs.get(\"tolerance\", SolverWrapper.tolerance)  # Default tolerance value\n    if self.tolerance &lt; 1e-9:\n        utils.logger.error(f\"{__name__}: The tolerance value must be &gt;=1e-9.\")\n        raise ValueError(\"The tolerance value must be &gt;=1e-9.\")\n\n    self.optimization_sense = kwargs.get(\"optimization_sense\", SolverWrapper.optimization_sense)  # Default optimization sense\n    if self.optimization_sense not in [\"minimize\", \"maximize\"]:\n        utils.logger.error(f\"{__name__}: The optimization sense must be either `minimize` or `maximize`.\")\n        raise ValueError(f\"Optimization sense {self.optimization_sense} is not supported. Only [\\\"minimize\\\", \\\"maximize\\\"] are supported.\")\n\n    self.did_timeout = False\n\n    if self.external_solver == \"highs\":\n        self.solver = HighsCustom()\n        self.solver.setOptionValue(\"solver\", \"choose\")\n        self.solver.setOptionValue(\"threads\", kwargs.get(\"threads\", SolverWrapper.threads))\n        self.solver.setOptionValue(\"time_limit\", kwargs.get(\"time_limit\", SolverWrapper.time_limit))\n        self.solver.setOptionValue(\"presolve\", kwargs.get(\"presolve\", SolverWrapper.presolve))\n        self.solver.setOptionValue(\"log_to_console\", kwargs.get(\"log_to_console\", SolverWrapper.log_to_console))\n        self.solver.setOptionValue(\"mip_rel_gap\", self.tolerance)\n        self.solver.setOptionValue(\"mip_feasibility_tolerance\", self.tolerance)\n        self.solver.setOptionValue(\"mip_abs_gap\", self.tolerance)\n        self.solver.setOptionValue(\"mip_rel_gap\", self.tolerance)\n        self.solver.setOptionValue(\"primal_feasibility_tolerance\", self.tolerance)\n    elif self.external_solver == \"gurobi\":\n        import gurobipy\n\n        self.env = gurobipy.Env(empty=True)\n        self.env.setParam(\"OutputFlag\", 0)\n        self.env.setParam(\"LogToConsole\", 1 if kwargs.get(\"log_to_console\", SolverWrapper.log_to_console) == \"true\" else 0)\n        self.env.setParam(\"OutputFlag\", 1 if kwargs.get(\"log_to_console\", SolverWrapper.log_to_console) == \"true\" else 0)\n        self.env.setParam(\"TimeLimit\", kwargs.get(\"time_limit\", SolverWrapper.time_limit))\n        self.env.setParam(\"Threads\", kwargs.get(\"threads\", SolverWrapper.threads))\n        self.env.setParam(\"MIPGap\", self.tolerance)\n        self.env.setParam(\"IntFeasTol\", self.tolerance)\n        self.env.setParam(\"FeasibilityTol\", self.tolerance)\n\n        self.env.start()\n        self.solver = gurobipy.Model(env=self.env)\n\n    else:\n        utils.logger.error(f\"{__name__}: Unsupported solver type `{self.external_solver}`. Supported solvers are `highs` and `gurobi`.\")\n        raise ValueError(\n            f\"Unsupported solver type `{self.external_solver}`, supported solvers are `highs` and `gurobi`.\"\n        )\n\n    utils.logger.debug(f\"{__name__}: solver_options (kwargs) = {kwargs}\")\n\n    # Pending bound updates to apply in batch before solving\n    # Stores backend variables directly\n    self._pending_fix_vars = []      # list[var]\n    self._pending_fix_vals = []      # list[float]\n    self._pending_lb_vars = []       # list[var]\n    self._pending_lb_vals = []       # list[float]\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_binary_continuous_product_constraint","title":"add_binary_continuous_product_constraint","text":"<pre><code>add_binary_continuous_product_constraint(\n    binary_var,\n    continuous_var,\n    product_var,\n    lb,\n    ub,\n    name: str,\n)\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_binary_continuous_product_constraint--description","title":"Description","text":"<p>This function adds constraints to model the equality: <code>binary_var</code> * <code>continuous_var</code> = <code>product_var</code>.</p> Assumptions <ul> <li><code>binary_var</code> \\(\\in [0,1]\\)</li> <li>lb \u2264 <code>continuous_var</code> \u2264 ub</li> </ul> Note <p>This works correctly also if <code>continuous_var</code> is an integer variable.</p> <p>Parameters:</p> Name Type Description Default <code>binary_var</code> <code>variable</code> <p>The binary variable.</p> required <code>continuous_var</code> <code>variable</code> <p>The continuous variable (can also be integer).</p> required <code>product_var</code> <code>variable</code> <p>The variable that should be equal to the product of the binary and continuous variables.</p> required <code>lb</code> <code>float</code> <p>The lower bound of the continuous variable.</p> required <code>ub</code> <code>float</code> <p>The upper bound of the continuous variable.</p> required <code>name</code> <code>str</code> <p>The name of the constraint.</p> required Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def add_binary_continuous_product_constraint(self, binary_var, continuous_var, product_var, lb, ub, name: str):\n    \"\"\"\n    Description\n    -----------\n    This function adds constraints to model the equality: `binary_var` * `continuous_var` = `product_var`.\n\n    Assumptions:\n        - `binary_var` $\\in [0,1]$\n        - lb \u2264 `continuous_var` \u2264 ub\n\n    Note:\n        This works correctly also if `continuous_var` is an integer variable.\n\n    Args:\n        binary_var (variable): The binary variable.\n        continuous_var (variable): The continuous variable (can also be integer).\n        product_var (variable): The variable that should be equal to the product of the binary and continuous variables.\n        lb (float): The lower bound of the continuous variable.\n        ub (float): The upper bound of the continuous variable.\n        name (str): The name of the constraint.\n    \"\"\"\n    self.add_constraint(product_var &lt;= ub * binary_var, name=name + \"_a\")\n    self.add_constraint(product_var &gt;= lb * binary_var, name=name + \"_b\")\n    self.add_constraint(product_var &lt;= continuous_var - lb * (1 - binary_var), name=name + \"_c\")\n    self.add_constraint(product_var &gt;= continuous_var - ub * (1 - binary_var), name=name + \"_d\")\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_constraint","title":"add_constraint","text":"<pre><code>add_constraint(expr, name='')\n</code></pre> <p>Add a linear (in)equation to the model.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_constraint--parameters","title":"Parameters","text":"<p>expr : linear expression / bool     The solver specific constraint expression. name : str, optional     Optional identifier for the constraint.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def add_constraint(self, expr, name=\"\"):\n    \"\"\"Add a linear (in)equation to the model.\n\n    Parameters\n    ----------\n    expr : linear expression / bool\n        The solver specific constraint expression.\n    name : str, optional\n        Optional identifier for the constraint.\n    \"\"\"\n    if self.external_solver == \"highs\":\n        self.solver.addConstr(expr, name=name)\n    elif self.external_solver == \"gurobi\":\n        self.solver.addConstr(expr, name=name)\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_integer_continuous_product_constraint","title":"add_integer_continuous_product_constraint","text":"<pre><code>add_integer_continuous_product_constraint(\n    integer_var,\n    continuous_var,\n    product_var,\n    lb,\n    ub,\n    name: str,\n)\n</code></pre> This function adds constraints to model the equality <p>integer_var * continuous_var = product_var</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_integer_continuous_product_constraint--assumptions","title":"Assumptions","text":"<p>lb &lt;= product_var &lt;= ub</p> <p>Note</p> <p>This works correctly also if <code>continuous_var</code> is an integer variable.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_integer_continuous_product_constraint--parameters","title":"Parameters","text":"<p>binary_var : Variable     The binary variable. continuous_var : Variable     The continuous variable (can also be integer). product_var : Variable     The variable that should be equal to the product of the binary and continuous variables. lb, ub : float     The lower and upper bounds of the continuous variable. name : str     The name of the constraint</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def add_integer_continuous_product_constraint(self, integer_var, continuous_var, product_var, lb, ub, name: str):\n    \"\"\"\n    This function adds constraints to model the equality:\n        integer_var * continuous_var = product_var\n\n    Assumptions\n    -----------\n    lb &lt;= product_var &lt;= ub\n\n    !!!tip \"Note\"\n        This works correctly also if `continuous_var` is an integer variable.\n\n    Parameters\n    ----------\n    binary_var : Variable\n        The binary variable.\n    continuous_var : Variable\n        The continuous variable (can also be integer).\n    product_var : Variable\n        The variable that should be equal to the product of the binary and continuous variables.\n    lb, ub : float\n        The lower and upper bounds of the continuous variable.\n    name : str\n        The name of the constraint\n    \"\"\"\n\n    num_bits = ceil(log2(ub + 1))\n    bits = list(range(num_bits))\n\n    binary_vars = self.add_variables(\n        indexes=bits,\n        name_prefix=f\"binary_{name}\",\n        lb=0,\n        ub=1,\n        var_type=\"integer\"\n    )\n\n    # We encode integer_var == sum(binary_vars[i] * 2^i)\n    self.add_constraint(\n        self.quicksum(binary_vars[i] * 2**i for i in bits) \n        == integer_var, \n        name=f\"{name}_int_eq\"\n    )\n\n    comp_vars = self.add_variables(\n        indexes=bits,\n        name_prefix=f\"comp_{name}\",\n        lb=lb,\n        ub=ub,\n        var_type=\"continuous\"\n    )\n\n    # We encode comp_vars[i] == binary_vars[i] * continuous_var\n    for i in bits:\n        self.add_binary_continuous_product_constraint(\n            binary_var=binary_vars[i],\n            continuous_var=continuous_var,\n            product_var=comp_vars[i],\n            lb=lb,\n            ub=ub,\n            name=f\"product_{i}_{name}\"\n        )\n\n    # We encode product_var == sum_{i in bits} comp_vars[i] * 2^i\n    self.add_constraint(\n        self.quicksum(comp_vars[i] * 2**i for i in bits) \n        == product_var, \n        name=f\"{name}_prod_eq\"\n    )\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_piecewise_constant_constraint","title":"add_piecewise_constant_constraint","text":"<pre><code>add_piecewise_constant_constraint(\n    x,\n    y,\n    ranges: list,\n    constants: list,\n    name_prefix: str,\n)\n</code></pre> <p>Enforces that variable <code>y</code> equals a constant from <code>constants</code> depending on the range that <code>x</code> falls into.</p> For each piece i <p><code>if x in [ranges[i][0], ranges[i][1]] then y = constants[i].</code></p> Assumptions <ul> <li>The ranges must be non-overlapping. Otherwise, if x belongs to more ranges, the solver will choose one arbitrarily.</li> <li>The value of x must be within the union of the ranges. Otherwise the solver will not find a feasible solution.</li> </ul> <p>This is modeled by: - introducing binary variables z[i] with sum(z) = 1, - for each piece i:         <code>x &gt;= L_i - M*(1 - z[i])</code> <code>x &lt;= U_i + M*(1 - z[i])</code> <code>y &lt;= constant[i] + M*(1 - z[i])</code> <code>y &gt;= constant[i] - M*(1 - z[i])</code></p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_piecewise_constant_constraint--parameters","title":"Parameters","text":"<p>x: The continuous variable (created earlier) whose value determines the segment. y: The continuous variable whose value equals the corresponding constant. ranges: List of tuples [(L0, U0), (L1, U1), \u2026] constants: List of constants [c0, c1, \u2026] for each segment. name_prefix: A prefix for naming the added variables and constraints.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_piecewise_constant_constraint--returns","title":"Returns","text":"<p>y: The created piecewise output variable.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def add_piecewise_constant_constraint(\n    self, x, y, ranges: list, constants: list, name_prefix: str\n):\n    \"\"\"\n    Enforces that variable `y` equals a constant from `constants` depending on the range that `x` falls into.\n\n    For each piece i:\n        `if x in [ranges[i][0], ranges[i][1]] then y = constants[i].`\n\n    Assumptions:\n        - The ranges must be non-overlapping. Otherwise, if x belongs to more ranges, the solver will choose one arbitrarily.\n        - The value of x must be within the union of the ranges. Otherwise the solver will not find a feasible solution.\n\n    This is modeled by:\n    - introducing binary variables z[i] with sum(z) = 1,\n    - for each piece i:\n            `x &gt;= L_i - M*(1 - z[i])`\n            `x &lt;= U_i + M*(1 - z[i])`\n            `y &lt;= constant[i] + M*(1 - z[i])`\n            `y &gt;= constant[i] - M*(1 - z[i])`\n\n    Parameters\n    ----------\n    x: The continuous variable (created earlier) whose value determines the segment.\n    y: The continuous variable whose value equals the corresponding constant.\n    ranges: List of tuples [(L0, U0), (L1, U1), ...]\n    constants: List of constants [c0, c1, ...] for each segment.\n    name_prefix: A prefix for naming the added variables and constraints.\n\n    Returns\n    -------\n    y: The created piecewise output variable.\n    \"\"\"\n    if len(ranges) != len(constants):\n        utils.logger.error(f\"{__name__}: The length of `ranges` and `constants` must be the same.\")\n        raise ValueError(\"`ranges` and `constants` must have the same length.\")\n\n    pieces = len(ranges)\n    Ls = [r[0] for r in ranges]\n    Us = [r[1] for r in ranges]\n    M = (max(Us) - min(Ls)) * 2\n\n    # Create binary variables z[i] for each piece.\n    z = self.add_variables(\n        [(i) for i in range(pieces)],\n        name_prefix=f\"z_{name_prefix}\",\n        lb=0,\n        ub=1,\n        var_type=\"integer\"\n    )\n\n    # Enforce that exactly one piece is active: sum_i z[i] == 1.\n    self.add_constraint(self.quicksum(z[i] for i in range(pieces)) == 1, name=f\"sum_z_{name_prefix}\")\n\n    # For each piece i, add the constraints:\n    for i in range(pieces):\n        L = Ls[i]\n        U = Us[i]\n        c = constants[i]\n        # Link x with the range [L, U] if piece i is active.\n        self.add_constraint(x &gt;= L - M * (1 - z[i]), name=f\"{name_prefix}_L_{i}\")\n        self.add_constraint(x &lt;= U + M * (1 - z[i]), name=f\"{name_prefix}_U_{i}\")\n        self.add_constraint(y &lt;= c + M * (1 - z[i]), name=f\"{name_prefix}_yU_{i}\")\n        self.add_constraint(y &gt;= c - M * (1 - z[i]), name=f\"{name_prefix}_yL_{i}\")\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_variables","title":"add_variables","text":"<pre><code>add_variables(\n    indexes,\n    name_prefix: str,\n    lb=0,\n    ub=1,\n    var_type=\"integer\",\n)\n</code></pre> <p>Create a set of variables sharing a common name prefix.</p> <p>Important: Avoid collisions!</p> <p>This function does not track or enforce unique/non-overlapping prefixes. The caller is responsible for choosing prefixes that do not create ambiguous names when mixed with other variables.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_variables--parameters","title":"Parameters","text":"<p>indexes : iterable     Iterable of index labels (numbers or hashables) used only to     suffix the variable names for uniqueness. name_prefix : str     Prefix for each created variable (e.g. <code>x_</code>). Must be unique with     respect to existing prefixes (no prefix / super-prefix relations). lb, ub : float | dict | sequence, default (0, 1)     Lower and upper bounds for created variables. Can be:     - scalars (applied to all indexes), or     - dicts mapping each index -&gt; bound, or     - sequences aligned with <code>indexes</code> order (same length). var_type : {\u201cinteger\u201d, \u201ccontinuous\u201d}, default \u201cinteger\u201d     Variable domain type.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.add_variables--returns","title":"Returns","text":"<p>dict | list     Mapping from provided index to underlying solver variable objects     (HiGHS returns an internal structure; Gurobi returns a dict).</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def add_variables(self, indexes, name_prefix: str, lb=0, ub=1, var_type=\"integer\"):\n    \"\"\"Create a set of variables sharing a common name prefix.\n\n    !!! warning \"Important: Avoid collisions!\"\n\n        This function does not track or enforce unique/non-overlapping\n        prefixes. The caller is responsible for choosing prefixes that do not\n        create ambiguous names when mixed with other variables.\n\n    Parameters\n    ----------\n    indexes : iterable\n        Iterable of index labels (numbers or hashables) used *only* to\n        suffix the variable names for uniqueness.\n    name_prefix : str\n        Prefix for each created variable (e.g. ``x_``). Must be unique with\n        respect to existing prefixes (no prefix / super-prefix relations).\n    lb, ub : float | dict | sequence, default (0, 1)\n        Lower and upper bounds for created variables. Can be:\n        - scalars (applied to all indexes), or\n        - dicts mapping each index -&gt; bound, or\n        - sequences aligned with ``indexes`` order (same length).\n    var_type : {\"integer\", \"continuous\"}, default \"integer\"\n        Variable domain type.\n\n    Returns\n    -------\n    dict | list\n        Mapping from provided index to underlying solver variable objects\n        (HiGHS returns an internal structure; Gurobi returns a dict).\n\n    \"\"\"\n\n# No internal tracking of prefixes; caller must avoid collisions.\n\n    # Normalize bounds to per-index arrays when necessary\n    def _materialize_bounds(param, default_value, param_name):\n        # scalar\n        if isinstance(param, (int, float)):\n            return [float(param)] * len(indexes)\n        # dict mapping index -&gt; value\n        if isinstance(param, dict):\n            vals = []\n            missing = []\n            for idx in indexes:\n                if idx in param:\n                    vals.append(float(param[idx]))\n                else:\n                    missing.append(idx)\n            if missing:\n                utils.logger.error(f\"{__name__}: Missing {param_name} for indexes: {missing[:3]}{'...' if len(missing)&gt;3 else ''}\")\n                raise ValueError(f\"Missing {param_name} for some indexes\")\n            return vals\n        # sequence aligned with indexes\n        try:\n            seq = list(param)\n            if len(seq) != len(indexes):\n                utils.logger.error(f\"{__name__}: Length of {param_name} ({len(seq)}) does not match number of indexes ({len(indexes)}).\")\n                raise ValueError(f\"Length of {param_name} does not match number of indexes.\")\n            return [float(x) for x in seq]\n        except TypeError:\n            # Not iterable; fall back to default scalar for all\n            return [float(default_value)] * len(indexes)\n\n    lbs = _materialize_bounds(lb, 0.0, \"lb\")\n    ubs = _materialize_bounds(ub, 1.0, \"ub\")\n\n    if self.external_solver == \"highs\":\n\n        var_type_map = {\n            \"integer\": highspy.HighsVarType.kInteger,\n            \"continuous\": highspy.HighsVarType.kContinuous,\n        }\n        return self.solver.addVariables(\n            indexes, \n            lb=lbs, \n            ub=ubs, \n            type=var_type_map[var_type], \n            name_prefix=name_prefix)\n    elif self.external_solver == \"gurobi\":\n        import gurobipy\n\n        var_type_map = {\n            \"integer\": gurobipy.GRB.INTEGER,\n            \"continuous\": gurobipy.GRB.CONTINUOUS,\n        }\n        # Single batched call using keys with per-index bounds\n        keys = list(indexes)\n        lb_map = {idx: float(lbs[pos]) for pos, idx in enumerate(keys)}\n        ub_map = {idx: float(ubs[pos]) for pos, idx in enumerate(keys)}\n\n        vars_td = self.solver.addVars(\n            keys,\n            lb=lb_map,\n            ub=ub_map,\n            vtype=var_type_map[var_type],\n            name=name_prefix,\n        )\n        # Keep model in a consistent state\n        self.solver.update()\n        return vars_td\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.fix_variable","title":"fix_variable","text":"<pre><code>fix_variable(\n    var, value: int | float\n)\n</code></pre> <p>Fix an existing variable to a constant value by tightening its bounds.</p> <p>This avoids adding an explicit equality constraint (var == value) which can slow down solving compared to changing bounds directly.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.fix_variable--parameters","title":"Parameters","text":"<p>var : backend variable object     The variable returned previously by <code>add_variables</code>. value : int | float     The value to which the variable should be fixed.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def fix_variable(self, var, value: Union[int, float]):\n    \"\"\"Fix an existing variable to a constant value by tightening its bounds.\n\n    This avoids adding an explicit equality constraint (var == value) which can\n    slow down solving compared to changing bounds directly.\n\n    Parameters\n    ----------\n    var : backend variable object\n        The variable returned previously by ``add_variables``.\n    value : int | float\n        The value to which the variable should be fixed.\n    \"\"\"\n\n    # Normalize to float for solvers expecting floating bounds\n    value = float(value)\n    if self.external_solver == \"gurobi\":\n        # Gurobi exposes direct LB / UB attributes\n        try:\n            var.LB = value\n            var.UB = value\n        except Exception as e:\n            utils.logger.error(f\"{__name__}: Could not fix gurobi variable: {e}\")\n            raise\n    elif self.external_solver == \"highs\":\n        # HiGHS: change column bounds using internal index of variable\n        try:\n            self.solver.changeColsBounds(\n                1,\n                np.array([var.index], dtype=np.int32),\n                np.array([value], dtype=np.float64 if isinstance(value, float) else np.int64),\n                np.array([value], dtype=np.float64 if isinstance(value, float) else np.int64),\n            )\n        except Exception as e:\n            utils.logger.error(f\"{__name__}: Could not fix highs variable: {e}\")\n            raise\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.get_all_variable_names","title":"get_all_variable_names","text":"<pre><code>get_all_variable_names()\n</code></pre> <p>Return names for all variables in solver insertion order.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def get_all_variable_names(self):\n    \"\"\"Return names for all variables in solver insertion order.\"\"\"\n    if self.external_solver == \"highs\":\n        return self.solver.allVariableNames()\n    elif self.external_solver == \"gurobi\":\n        return [var.VarName for var in self.solver.getVars()]\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.get_all_variable_values","title":"get_all_variable_values","text":"<pre><code>get_all_variable_values()\n</code></pre> <p>Return values for all variables in solver insertion order.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def get_all_variable_values(self):\n    \"\"\"Return values for all variables in solver insertion order.\"\"\"\n    if self.external_solver == \"highs\":\n        return self.solver.allVariableValues()\n    elif self.external_solver == \"gurobi\":\n        return [var.X for var in self.solver.getVars()]\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.get_model_status","title":"get_model_status","text":"<pre><code>get_model_status(raw=False)\n</code></pre> <p>Return HiGHS style model status string (or raw Gurobi code).</p> <p>If the custom timeout was triggered the synthetic status <code>kTimeLimit</code> is returned irrespective of the underlying solver state.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.get_model_status--parameters","title":"Parameters","text":"<p>raw : bool, default False     When using Gurobi: if <code>True</code> return the untouched integer status     code; otherwise attempt to map to a HiGHS style enum name.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.get_model_status--returns","title":"Returns","text":"<p>str | int     Status name (always a string for HiGHS). Integer code for Gurobi     only when <code>raw=True</code>.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def get_model_status(self, raw = False):\n    \"\"\"Return HiGHS style model status string (or raw Gurobi code).\n\n    If the *custom* timeout was triggered the synthetic status ``kTimeLimit``\n    is returned irrespective of the underlying solver state.\n\n    Parameters\n    ----------\n    raw : bool, default False\n        When using Gurobi: if ``True`` return the untouched integer status\n        code; otherwise attempt to map to a HiGHS style enum name.\n\n    Returns\n    -------\n    str | int\n        Status name (always a string for HiGHS). Integer code for Gurobi\n        only when ``raw=True``.\n    \"\"\"\n\n    # If the solver has timed out with our custom time limit, we return the timeout status\n    # This is set in the __run_with_timeout function\n    if self.did_timeout:\n        return \"kTimeLimit\"\n\n    # If the solver has not timed out, we return the model status\n    if self.external_solver == \"highs\":\n        return self.solver.getModelStatus().name\n    elif self.external_solver == \"gurobi\":\n        return SolverWrapper.gurobi_status_to_highs.get(self.solver.status, self.solver.status) if not raw else self.solver.status\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.get_objective_value","title":"get_objective_value","text":"<pre><code>get_objective_value()\n</code></pre> <p>Return objective value of last solve.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.get_objective_value--returns","title":"Returns","text":"<p>float     Objective value according to the configured optimization sense.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def get_objective_value(self):\n    \"\"\"Return objective value of last solve.\n\n    Returns\n    -------\n    float\n        Objective value according to the configured optimization sense.\n    \"\"\"\n    if self.external_solver == \"highs\":\n        return self.solver.getObjectiveValue()\n    elif self.external_solver == \"gurobi\":\n        return self.solver.objVal\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.get_values","title":"get_values","text":"<pre><code>get_values(\n    variables,\n    binary_values: bool = False,\n) -&gt; dict\n</code></pre> <p>Return solution values for variables without name parsing.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.get_values--parameters","title":"Parameters","text":"<p>variables : iterable | mapping     Either an iterable of (index, variable) pairs, or a mapping where     keys are indices and values are variable objects (e.g., a dict or     a Gurobi tupledict). binary_values : bool, default False     If True, round values to 0/1 and validate against tolerance.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.get_values--returns","title":"Returns","text":"<p>dict     Dictionary mapping each provided index to its solution value.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.get_values--notes","title":"Notes","text":"<ul> <li>For HiGHS, values are retrieved using the internal column index of each   variable via a single call to <code>allVariableValues</code>.</li> <li>For Gurobi, values are read from <code>Var.X</code>.</li> <li>Indices are taken from the first element of each tuple in <code>variables</code>   (when an iterable of pairs is supplied). If a mapping is supplied,   its items() are used.</li> </ul> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def get_values(self, variables, binary_values: bool = False) -&gt; dict:\n    \"\"\"Return solution values for variables without name parsing.\n\n    Parameters\n    ----------\n    variables : iterable | mapping\n        Either an iterable of (index, variable) pairs, or a mapping where\n        keys are indices and values are variable objects (e.g., a dict or\n        a Gurobi tupledict).\n    binary_values : bool, default False\n        If True, round values to 0/1 and validate against tolerance.\n\n    Returns\n    -------\n    dict\n        Dictionary mapping each provided index to its solution value.\n\n    Notes\n    -----\n    - For HiGHS, values are retrieved using the internal column index of each\n      variable via a single call to ``allVariableValues``.\n    - For Gurobi, values are read from ``Var.X``.\n    - Indices are taken from the first element of each tuple in ``variables``\n      (when an iterable of pairs is supplied). If a mapping is supplied,\n      its items() are used.\n    \"\"\"\n    # Prepare a value accessor per backend\n    if self.external_solver == \"highs\":\n        all_vals = self.get_all_variable_values()\n\n        def _val_of(v):\n            idx = getattr(v, \"index\", None)\n            if idx is None:\n                raise Exception(\"HiGHS variable object missing 'index' attribute.\")\n            return all_vals[idx]\n    elif self.external_solver == \"gurobi\":\n        def _val_of(v):\n            return v.X\n    else:\n        raise ValueError(f\"Unsupported solver type '{self.external_solver}'.\")\n\n    def _maybe_round_binary(val):\n        if not binary_values:\n            return val\n        tol = max(1e-9, getattr(self, \"tolerance\", 1e-9))\n        rv = int(round(val))\n        if rv not in (0, 1) or abs(val - rv) &gt; tol:\n            raise Exception(f\"Variable has non-binary value {val}\")\n        return rv\n\n    # Build an iterator of (index, variable) pairs\n    try:\n        pair_iter = variables.items()\n    except AttributeError:\n        # variables may already be an iterable of pairs or a mapping that\n        # doesn't expose items(); handle both\n        def _pair_gen():\n            for elem in variables:\n                if isinstance(elem, tuple) and len(elem) == 2:\n                    yield elem  # (index, var)\n                else:\n                    # Assume elem is a key into a mapping supporting __getitem__\n                    yield (elem, variables[elem])\n        pair_iter = _pair_gen()\n\n    result = {}\n    for key, var in pair_iter:\n        value = _val_of(var)\n        result[key] = _maybe_round_binary(value)\n    return result\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.get_variable_values","title":"get_variable_values","text":"<pre><code>get_variable_values(\n    name_prefix,\n    index_types: list,\n    binary_values: bool = False,\n) -&gt; dict\n</code></pre> <p>Deprecated</p> <p>Use <code>get_values(...)</code> instead.</p> <p>Retrieve the values of variables belonging to a given prefix.</p> <p>This method matches variables using one of these forms for the given <code>name_prefix</code>: - Structured names: <code>&lt;prefix&gt;(i, j, ...)</code> or <code>&lt;prefix&gt;[i, j, ...]</code> - Legacy single numeric suffix: <code>&lt;prefix&gt;k</code> or <code>&lt;prefix&gt;_k</code> - Exact scalar variable name: <code>&lt;prefix&gt;</code> (when <code>index_types</code> is empty)</p> <p>Under these rules, overlapping prefixes (e.g., <code>x</code> and <code>x_long</code>) won\u2019t interfere with each other. Callers must still avoid custom ad-hoc naming that mimics these patterns for different variables.</p> <p>Parameters:</p> Name Type Description Default <code>name_prefix</code> <code>str</code> <p>The prefix of the variable names to filter.</p> required <code>index_types</code> <code>list</code> <p>A list of types corresponding to the indices of the variables.                 Each type in the list is used to cast the string indices to                  the appropriate type.                 If empty, then it is assumed that the variable has no index, and does exact matching with the variable name.</p> required <code>binary_values</code> <code>bool</code> <p>If True, ensures that the variable values (rounded) are                              binary (0 or 1). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>values</code> <code>dict</code> <p>A dictionary where the keys are the indices of the variables (as tuples or  single values) and the values are the corresponding variable values. If index_types is empty, then the unique key is 0 and the value is the variable value.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the length of <code>index_types</code> does not match the number of indices      in a variable name.</p> <code>Exception</code> <p>If <code>binary_values</code> is True and a variable value (rounded) is not binary.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def get_variable_values(\n    self, name_prefix, index_types: list, binary_values: bool = False \n) -&gt; dict:\n    \"\"\"\n    !!! warning \"Deprecated\"\n\n        Use `get_values(...)` instead.\n\n    Retrieve the values of variables belonging to a given prefix.\n\n    This method matches variables using one of these forms for the given\n    ``name_prefix``:\n    - Structured names: ``&lt;prefix&gt;(i, j, ...)`` or ``&lt;prefix&gt;[i, j, ...]``\n    - Legacy single numeric suffix: ``&lt;prefix&gt;k`` or ``&lt;prefix&gt;_k``\n    - Exact scalar variable name: ``&lt;prefix&gt;`` (when ``index_types`` is empty)\n\n    Under these rules, overlapping prefixes (e.g., ``x`` and ``x_long``)\n    won't interfere with each other. Callers must still avoid custom ad-hoc\n    naming that mimics these patterns for different variables.\n\n    Args:\n        name_prefix (str): The prefix of the variable names to filter.\n        index_types (list): A list of types corresponding to the indices of the variables.\n                            Each type in the list is used to cast the string indices to \n                            the appropriate type.\n                            If empty, then it is assumed that the variable has no index, and does exact matching with the variable name.\n        binary_values (bool, optional): If True, ensures that the variable values (rounded) are \n                                        binary (0 or 1). Defaults to False.\n\n    Returns:\n        values: A dictionary where the keys are the indices of the variables (as tuples or \n            single values) and the values are the corresponding variable values.\n            If index_types is empty, then the unique key is 0 and the value is the variable value.\n\n    Raises:\n        Exception: If the length of `index_types` does not match the number of indices \n                in a variable name.\n        Exception: If `binary_values` is True and a variable value (rounded) is not binary.\n    \"\"\"\n    # Emit a deprecation warning (hidden by default unless enabled by filters)\n    warnings.warn(\n        \"SolverWrapper.get_variable_values is deprecated and will be removed in a future release. \"\n        \"Use SolverWrapper.get_values(...) instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    varNames = self.get_all_variable_names()\n    varValues = self.get_all_variable_values()\n\n    values: dict = {}\n\n    def _cast_components(comps, types):\n        casted = []\n        for c, t in zip(comps, types):\n            if t is int:\n                casted.append(int(c))\n            elif t is float:\n                casted.append(float(c))\n            elif t is str:\n                casted.append(str(c))\n            else:\n                casted.append(t(c))\n        if len(casted) == 0:\n            return ()\n        if len(casted) == 1:\n            return casted[0]\n        return tuple(casted)\n\n    simple_numeric = re.compile(r\"^-?\\d+$\")\n\n    for i, var in enumerate(varNames):\n        val = varValues[i]\n\n        # Scalar exact name\n        if not index_types:\n            if var == name_prefix:\n                values[0] = val\n                if binary_values:\n                    rv = int(round(values[0]))\n                    if rv not in (0, 1):\n                        raise Exception(f\"Variable {var} has value {values[0]}, which is not binary.\")\n                    values[0] = rv\n                # exact scalar match is unique\n                continue\n            else:\n                continue\n\n        # Structured prefix(name) or prefix[name]\n        comps = self.parse_var_name(var, name_prefix)\n        if comps is not None:\n            if len(comps) != len(index_types):\n                # Ignore mismatched arity\n                continue\n            try:\n                key = _cast_components(comps, index_types)\n            except Exception:\n                # Skip if casting fails\n                continue\n            values[key] = val\n            continue\n\n        # Legacy numeric suffix: prefix&lt;idx&gt; or prefix_&lt;idx&gt;\n        if len(index_types) == 1 and var.startswith(name_prefix):\n            suffix = var[len(name_prefix):]\n            if suffix.startswith(\"_\"):\n                suffix_try = suffix[1:]\n            else:\n                suffix_try = suffix\n            if simple_numeric.match(suffix_try):\n                try:\n                    key = _cast_components([suffix_try], index_types)\n                    values[key] = val\n                except Exception:\n                    pass\n\n    if binary_values:\n        tol = max(1e-9, getattr(self, \"tolerance\", 1e-9))\n        for k, v in list(values.items()):\n            rv = int(round(v))\n            if rv not in (0, 1) or abs(v - rv) &gt; tol:\n                raise Exception(f\"Variable {name_prefix}{k if k!=0 else ''} has non-binary value {v}\")\n            values[k] = rv\n\n    return values\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.optimize","title":"optimize","text":"<pre><code>optimize()\n</code></pre> <p>Run the solver.</p> <p>Behaviour: - If <code>time_limit</code> is infinity OR <code>use_also_custom_timeout</code> is     <code>False</code> we rely solely on the backend\u2019s time limit handling. - Otherwise we also arm a POSIX signal based timeout (coarse, whole     seconds) which, when firing, sets <code>did_timeout</code>. The underlying     solver is not forcibly terminated beyond the signal alarm; we rely on     cooperative interruption.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def optimize(self):\n    \"\"\"Run the solver.\n\n    Behaviour:\n    - If ``time_limit`` is infinity OR ``use_also_custom_timeout`` is\n        ``False`` we rely solely on the backend's time limit handling.\n    - Otherwise we also arm a POSIX signal based timeout (coarse, whole\n        seconds) which, when firing, sets ``did_timeout``. The underlying\n        solver is not forcibly terminated beyond the signal alarm; we rely on\n        cooperative interruption.\n    \"\"\"\n    # Resetting the timeout flag\n    self.did_timeout = False\n\n    # For both solvers, we have the same function to call\n    # If the time limit is infinite, we call the optimize function directly\n    # Otherwise, we call the function with a timeout\n    # Apply any queued bound updates right before solving\n    self._apply_pending_bound_updates()\n\n    if self.time_limit == float('inf') or (not self.use_also_custom_timeout):\n        self.solver.optimize()\n    else:\n        utils.logger.debug(f\"{__name__}: Running also with use_also_custom_timeout ({self.time_limit} sec)\")\n        self._run_with_timeout(self.time_limit, self.solver.optimize)\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.parse_var_name","title":"parse_var_name","text":"<pre><code>parse_var_name(\n    string, name_prefix\n)\n</code></pre> <p>Parse a variable name and extract indices inside parentheses or brackets.</p> <pre><code>Supported forms:\n- ``&lt;prefix&gt;(i,j,...)`` (HiGHS style / tuple repr)\n- ``&lt;prefix&gt;[i,j,...]`` (Gurobi addVars style)\n- Single-suffix names ``&lt;prefix&gt;&lt;i&gt;`` are handled elsewhere.\n</code></pre> <p>Returns a list of raw index components as strings (quotes stripped). Commas inside nested parentheses/brackets are treated as part of the component, e.g. <code>var((a,b))</code> -&gt; [\u201c(a,b)\u201d].</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def parse_var_name(self, string, name_prefix):\n    \"\"\"Parse a variable name and extract indices inside parentheses or brackets.\n\n    Supported forms:\n    - ``&lt;prefix&gt;(i,j,...)`` (HiGHS style / tuple repr)\n    - ``&lt;prefix&gt;[i,j,...]`` (Gurobi addVars style)\n    - Single-suffix names ``&lt;prefix&gt;&lt;i&gt;`` are handled elsewhere.\n\nReturns a list of raw index components as strings (quotes stripped).\nCommas inside nested parentheses/brackets are treated as part of the\ncomponent, e.g. ``var((a,b))`` -&gt; [\"(a,b)\"].\n    \"\"\"\n    # Try parentheses first\n    match = re.match(rf\"{re.escape(name_prefix)}\\(\\s*(.*?)\\s*\\)$\", string)\n    if match:\n        components_str = match.group(1)\n    else:\n        # Try square brackets (Gurobi addVars style)\n        match = re.match(rf\"{re.escape(name_prefix)}\\[\\s*(.*?)\\s*\\]$\", string)\n        if match:\n            components_str = match.group(1)\n        else:\n            # Not a structured name for this prefix\n            return None\n\n    # Split at top-level commas only; keep commas inside nested () or []\n    if components_str.strip() == \"\":\n        return []\n\n    components = []\n    buf = []\n    in_quote = False\n    depth_paren = 0\n    depth_brack = 0\n\n    for ch in components_str:\n        if in_quote:\n            buf.append(ch)\n            if ch == \"'\":\n                in_quote = False\n            continue\n\n        if ch == \"'\":\n            in_quote = True\n            buf.append(ch)\n            continue\n\n        if ch == '(':\n            depth_paren += 1\n            buf.append(ch)\n            continue\n        if ch == ')' and depth_paren &gt; 0:\n            depth_paren -= 1\n            buf.append(ch)\n            continue\n        if ch == '[':\n            depth_brack += 1\n            buf.append(ch)\n            continue\n        if ch == ']' and depth_brack &gt; 0:\n            depth_brack -= 1\n            buf.append(ch)\n            continue\n\n        if ch == ',' and depth_paren == 0 and depth_brack == 0:\n            token = ''.join(buf).strip()\n            if len(token) &gt;= 2 and token[0] == \"'\" and token[-1] == \"'\":\n                token = token[1:-1]\n            components.append(token)\n            buf = []\n        else:\n            buf.append(ch)\n\n    # Flush last token\n    token = ''.join(buf).strip()\n    if len(token) &gt;= 2 and token[0] == \"'\" and token[-1] == \"'\":\n        token = token[1:-1]\n    if token != \"\" or components_str.strip() != \"\":\n        components.append(token)\n\n    return components\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.print_variable_names_values","title":"print_variable_names_values","text":"<pre><code>print_variable_names_values()\n</code></pre> <p>Print <code>name = value</code> lines for every variable (debug helper).</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def print_variable_names_values(self):\n    \"\"\"Print ``name = value`` lines for every variable (debug helper).\"\"\"\n    varNames = self.get_all_variable_names()\n    varValues = self.get_all_variable_values()\n\n    for index, var in enumerate(varNames):\n        print(f\"{var} = {varValues[index]}\")\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.queue_fix_variable","title":"queue_fix_variable","text":"<pre><code>queue_fix_variable(\n    var, value: int | float\n)\n</code></pre> <p>Queue a variable to be fixed (LB=UB=value) in a later batch update.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def queue_fix_variable(self, var, value: Union[int, float]):\n    \"\"\"Queue a variable to be fixed (LB=UB=value) in a later batch update.\"\"\"\n    self._pending_fix_vars.append(var)\n    self._pending_fix_vals.append(float(value))\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.queue_set_var_lower_bound","title":"queue_set_var_lower_bound","text":"<pre><code>queue_set_var_lower_bound(\n    var, lb: int | float\n)\n</code></pre> <p>Queue a variable to have its lower bound raised to <code>lb</code> in batch.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def queue_set_var_lower_bound(self, var, lb: Union[int, float]):\n    \"\"\"Queue a variable to have its lower bound raised to ``lb`` in batch.\"\"\"\n    self._pending_lb_vars.append(var)\n    self._pending_lb_vals.append(float(lb))\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.quicksum","title":"quicksum","text":"<pre><code>quicksum(expr)\n</code></pre> <p>Backend agnostic fast summation of linear terms.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.quicksum--parameters","title":"Parameters","text":"<p>expr : iterable     Iterable of linear terms.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.quicksum--returns","title":"Returns","text":"<p>linear expression     A solver specific linear expression representing the sum.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def quicksum(self, expr):\n    \"\"\"Backend agnostic fast summation of linear terms.\n\n    Parameters\n    ----------\n    expr : iterable\n        Iterable of linear terms.\n\n    Returns\n    -------\n    linear expression\n        A solver specific linear expression representing the sum.\n    \"\"\"\n    if self.external_solver == \"highs\":\n        return self.solver.qsum(expr)\n    elif self.external_solver == \"gurobi\":\n        import gurobipy\n\n        return gurobipy.quicksum(expr)\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.set_objective","title":"set_objective","text":"<pre><code>set_objective(\n    expr, sense=\"minimize\"\n)\n</code></pre> <p>Set (and replace) the linear objective.</p> <p>For HiGHS this delegates to <code>HighsCustom.set_objective_without_solving</code> (i.e. does not trigger a solve). For Gurobi it uses the native <code>setObjective</code> method.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.set_objective--parameters","title":"Parameters","text":"<p>expr : linear expression     Objective linear expression. sense : {\u201cminimize\u201d, \u201cmin\u201d, \u201cmaximize\u201d, \u201cmax\u201d}, default \u201cminimize\u201d     Optimization direction.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.set_objective--raises","title":"Raises","text":"<p>ValueError     If <code>sense</code> is invalid.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def set_objective(self, expr, sense=\"minimize\"):\n    \"\"\"Set (and replace) the linear objective.\n\n    For HiGHS this delegates to ``HighsCustom.set_objective_without_solving``\n    (i.e. does not trigger a solve). For Gurobi it uses the native\n    ``setObjective`` method.\n\n    Parameters\n    ----------\n    expr : linear expression\n        Objective linear expression.\n    sense : {\"minimize\", \"min\", \"maximize\", \"max\"}, default \"minimize\"\n        Optimization direction.\n\n    Raises\n    ------\n    ValueError\n        If ``sense`` is invalid.\n    \"\"\"\n\n    if sense not in [\"minimize\", \"min\", \"maximize\", \"max\"]:\n        utils.logger.error(f\"{__name__}: The objective sense must be either `minimize` or `maximize`.\")\n        raise ValueError(f\"Objective sense {sense} is not supported. Only [\\\"minimize\\\", \\\"min\\\", \\\"maximize\\\", \\\"max\\\"] are supported.\")\n    self.optimization_sense = sense\n\n    if self.external_solver == \"highs\":\n        self.solver.set_objective_without_solving(expr, sense=sense)\n    elif self.external_solver == \"gurobi\":\n        import gurobipy\n\n        self.solver.setObjective(\n            expr,\n            gurobipy.GRB.MINIMIZE if sense in [\"minimize\", \"min\"] else gurobipy.GRB.MAXIMIZE,\n        )\n</code></pre>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.write_model","title":"write_model","text":"<pre><code>write_model(filename)\n</code></pre> <p>Persist model to a file supported by the backend.</p>"},{"location":"solver-wrapper.html#flowpaths.utils.solverwrapper.SolverWrapper.write_model--parameters","title":"Parameters","text":"<p>filename : str | os.PathLike     Target path. HiGHS chooses format based on extension; Gurobi uses     native <code>write</code> method behaviour.</p> Source code in <code>flowpaths/utils/solverwrapper.py</code> <pre><code>def write_model(self, filename):\n    \"\"\"Persist model to a file supported by the backend.\n\n    Parameters\n    ----------\n    filename : str | os.PathLike\n        Target path. HiGHS chooses format based on extension; Gurobi uses\n        native ``write`` method behaviour.\n    \"\"\"\n    if self.external_solver == \"highs\":\n        self.solver.writeModel(filename)\n    elif self.external_solver == \"gurobi\":\n        self.solver.write(filename)\n</code></pre>"},{"location":"stdag.html","title":"Directed acyclic graphs with global source and global sink","text":"<p>This class is used in AbstractPathModelDAG as a wrapper (with unique global source and unique global sink) to pass the DAG to the ILP models.</p>"},{"location":"stdag.html#flowpaths.stdag.stDAG","title":"stDAG","text":"<pre><code>stDAG(\n    base_graph: DiGraph,\n    additional_starts: (\n        list | None\n    ) = None,\n    additional_ends: (\n        list | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>AbstractSourceSinkGraph</code></p> <p>Augmented DAG with global source/sink.</p> <p>This class derives from <code>AbstractSourceSinkGraph</code>, which centralises the creation of a unique global source and sink and the shared flow utility helpers. Only DAG specific validation (acyclicity) and derived DAG-only structures (topological orders and reachability caches) remain here.</p> Source code in <code>flowpaths/stdag.py</code> <pre><code>def __init__(\n    self,\n    base_graph: nx.DiGraph,\n    additional_starts: Optional[list] = None,\n    additional_ends: Optional[list] = None,\n):\n    super().__init__(\n        base_graph=base_graph,\n        additional_starts=additional_starts,\n        additional_ends=additional_ends,\n    )\n</code></pre>"},{"location":"stdag.html#flowpaths.stdag.stDAG.compute_max_edge_antichain","title":"compute_max_edge_antichain","text":"<pre><code>compute_max_edge_antichain(\n    get_antichain=False,\n    weight_function=None,\n)\n</code></pre> <p>Computes the maximum edge antichain in a directed graph.</p>"},{"location":"stdag.html#flowpaths.stdag.stDAG.compute_max_edge_antichain--parameters","title":"Parameters","text":"<ul> <li>get_antichain (bool): If True, the function also returns the antichain along with its cost. Default is False.</li> <li>weight_function (dict): A dictionary where keys are edges (tuples) and values are weights.         If None, weights 1 are used for original graph edges, and weights 0 are used for global source / global sink edges.         If given, the antichain weight is computed as the sum of the weights of the edges in the antichain,         where edges that have some missing weight again get weight 0.         Default is None.</li> </ul>"},{"location":"stdag.html#flowpaths.stdag.stDAG.compute_max_edge_antichain--returns","title":"Returns","text":"<ul> <li>If get_antichain is False, returns the size of maximum edge antichain.</li> <li>If get_antichain is True, returns a tuple containing the         size of maximum edge antichain and the antichain.</li> </ul> Source code in <code>flowpaths/stdag.py</code> <pre><code>def compute_max_edge_antichain(self, get_antichain=False, weight_function=None):\n    \"\"\"\n    Computes the maximum edge antichain in a directed graph.\n\n    Parameters\n    ----------\n    - get_antichain (bool): If True, the function also returns the antichain along with its cost. Default is False.\n    - weight_function (dict): A dictionary where keys are edges (tuples) and values are weights.\n            If None, weights 1 are used for original graph edges, and weights 0 are used for global source / global sink edges.\n            If given, the antichain weight is computed as the sum of the weights of the edges in the antichain,\n            where edges that have some missing weight again get weight 0.\n            Default is None.\n\n    Returns\n    ----------\n    - If get_antichain is False, returns the size of maximum edge antichain.\n    - If get_antichain is True, returns a tuple containing the\n            size of maximum edge antichain and the antichain.\n    \"\"\"\n\n    G_nx = nx.DiGraph()\n    demand = dict()\n\n    G_nx.add_nodes_from(self.nodes())\n\n    for u, v in self.edges():\n        # the cost of each path is 1\n        cost = 1 if u == self.source else 0\n\n        edge_demand = int(u != self.source and v != self.sink)\n        if weight_function:\n            edge_demand = weight_function.get((u, v), 0)\n\n        demand[(u, v)] = edge_demand\n        # adding the edge\n        G_nx.add_edge(u, v, l=demand[(u, v)], u=graphutils.bigNumber, c=cost)\n\n    minFlowCost, minFlow = graphutils.min_cost_flow(G_nx, self.source, self.sink)\n\n    # def DFS_find_reachable_from_source(u, visited):\n    #     if visited[u] != 0:\n    #         return\n    #     assert u != self.sink\n    #     visited[u] = 1\n    #     for v in self.successors(u):\n    #         if minFlow[u][v] &gt; demand[(u, v)]:\n    #             if visited[v] == 0:\n    #                 DFS_find_reachable_from_source(v, visited)\n    #     for v in self.predecessors(u):\n    #         if visited[v] == 0:\n    #             DFS_find_reachable_from_source(v, visited)\n\n    # The following code was created by Claude 3.7 Sonnet to avoid recursion and uses a stack instead.\n    def DFS_find_reachable_from_source(start_node, visited):\n        stack = [start_node]\n\n        while stack:\n            u = stack.pop()\n            if visited[u] != 0:\n                continue\n\n            assert u != self.sink\n            visited[u] = 1\n\n            for v in self.successors(u):\n                if minFlow[u][v] &gt; demand[(u, v)] and visited[v] == 0:\n                    stack.append(v)\n\n            for v in self.predecessors(u):\n                if visited[v] == 0:\n                    stack.append(v)\n\n    # def DFS_find_saturating(u, visited):\n    #     if visited[u] != 1:\n    #         return\n    #     visited[u] = 2\n    #     for v in self.successors(u):\n    #         if minFlow[u][v] &gt; demand[(u, v)]:\n    #             DFS_find_saturating(v, visited)\n    #         elif (\n    #             minFlow[u][v] == demand[(u, v)]\n    #             and demand[(u, v)] &gt;= 1\n    #             and visited[v] == 0\n    #         ):\n    #             antichain.append((u, v))\n    #     for v in self.predecessors(u):\n    #         DFS_find_saturating(v, visited)\n\n    # The following code was created by Claude 3.7 Sonnet to avoid recursion and uses a stack instead.\n    def DFS_find_saturating(start_node, visited):\n        stack = [start_node]\n\n        while stack:\n            u = stack.pop()\n\n            if visited[u] != 1:\n                continue\n\n            visited[u] = 2\n\n            # Process successors\n            for v in self.successors(u):\n                if minFlow[u][v] &gt; demand[(u, v)]:\n                    if visited[v] == 1:  # Only visit nodes marked as reachable (1)\n                        stack.append(v)\n                elif (minFlow[u][v] == demand[(u, v)] \n                    and demand[(u, v)] &gt;= 1 \n                    and visited[v] == 0):\n                    antichain.append((u, v))\n\n            # Process predecessors\n            for v in self.predecessors(u):\n                if visited[v] == 1:  # Only visit nodes marked as reachable (1)\n                    stack.append(v)\n\n    if get_antichain:\n        antichain = []\n        visited = {node: 0 for node in self.nodes()}\n        DFS_find_reachable_from_source(self.source, visited)\n        DFS_find_saturating(self.source, visited)\n        if weight_function:\n            assert minFlowCost == sum(\n                map(lambda edge: weight_function[edge], antichain)\n            )\n        else:\n            assert minFlowCost == len(antichain)\n        return minFlowCost, antichain\n\n    return minFlowCost\n</code></pre>"},{"location":"stdag.html#flowpaths.stdag.stDAG.decompose_using_max_bottleneck","title":"decompose_using_max_bottleneck","text":"<pre><code>decompose_using_max_bottleneck(\n    flow_attr: str,\n)\n</code></pre> <p>Decomposes the flow greedily into paths using the maximum bottleneck algorithm. This method iteratively finds the path with the maximum bottleneck capacity in the graph and decomposes the flow along that path. The process continues until no more paths can be found.</p> <p>Note</p> <p>The decomposition path do not contain the global source nor sink.</p>"},{"location":"stdag.html#flowpaths.stdag.stDAG.decompose_using_max_bottleneck--returns","title":"Returns","text":"<ul> <li>tuple: A tuple containing two lists:<ul> <li>paths (list of lists): A list of paths, where each path is represented     as a list of nodes.</li> <li>weights (list): A list of weights (bottleneck capacities) corresponding to each path.</li> </ul> </li> </ul> Source code in <code>flowpaths/stdag.py</code> <pre><code>def decompose_using_max_bottleneck(self, flow_attr: str):\n    \"\"\"\n    Decomposes the flow greedily into paths using the maximum bottleneck algorithm.\n    This method iteratively finds the path with the maximum bottleneck capacity\n    in the graph and decomposes the flow along that path. The process continues\n    until no more paths can be found.\n\n    !!! note \"Note\"\n        The decomposition path do not contain the global source nor sink.\n\n    Returns\n    ----------\n    - tuple: A tuple containing two lists:\n        - paths (list of lists): A list of paths, where each path is represented\n            as a list of nodes.\n        - weights (list): A list of weights (bottleneck capacities) corresponding to each path.\n    \"\"\"\n\n    paths = list()\n    weights = list()\n\n    temp_G = nx.DiGraph()\n    temp_G.add_nodes_from(self.nodes())\n    temp_G.add_edges_from(self.edges(data=True))\n    temp_G.remove_nodes_from([self.source, self.sink])\n\n    while True:\n        bottleneck, path = graphutils.max_bottleneck_path(temp_G, flow_attr)\n        if path is None:\n            break\n\n        for i in range(len(path) - 1):\n            temp_G[path[i]][path[i + 1]][flow_attr] -= bottleneck\n\n        paths.append(path)\n        weights.append(bottleneck)\n\n    return (paths, weights)\n</code></pre>"},{"location":"stdag.html#flowpaths.stdag.stDAG.get_flow_width","title":"get_flow_width","text":"<pre><code>get_flow_width(\n    flow_attr: str,\n    edges_to_ignore: list = None,\n) -&gt; int\n</code></pre> <p>Calculate, store, and return the flow-width of the graph. The flow width is computed as the minimum number to cover all the edges, with the constraint  that an edge cannot be covered more time than the flow value given as <code>flow_attr</code> in the edge data.</p> <p>If the flow-width has already been computed, the stored value is returned.</p>"},{"location":"stdag.html#flowpaths.stdag.stDAG.get_flow_width--returns","title":"Returns","text":"<ul> <li>int: The flow-width of the graph.</li> </ul> Source code in <code>flowpaths/stdag.py</code> <pre><code>def get_flow_width(self, flow_attr: str, edges_to_ignore: list = None) -&gt; int:\n    \"\"\"\n    Calculate, store, and return the [flow-width](https://arxiv.org/abs/2409.20278) of the graph.\n    The flow width is computed as the minimum number to cover all the edges, with the constraint \n    that an edge cannot be covered more time than the flow value given as `flow_attr` in the edge data.\n\n    If the flow-width has already been computed, the stored value is returned.\n\n    Returns\n    ----------\n    - int: The flow-width of the graph.\n    \"\"\"\n\n    if self.flow_width != None:\n        return self.flow_width\n\n    G_nx = nx.DiGraph()\n\n    edges_to_ignore_set = set(edges_to_ignore or [])\n\n    G_nx.add_nodes_from(self.nodes())\n\n    for u, v in self.edges():\n        # the cost of each path is 1\n        cost = 1 if u == self.source else 0\n\n        edge_demand = int(u != self.source and v != self.sink)\n        if (u, v) in edges_to_ignore_set:\n            edge_demand = 0\n        edge_capacity = self[u][v].get(flow_attr, float('inf'))\n\n        # adding the edge\n        G_nx.add_edge(u, v, l=edge_demand, u=edge_capacity, c=cost)\n\n    minFlowCost, _ = graphutils.min_cost_flow(G_nx, self.source, self.sink)\n\n    self.flow_width = minFlowCost\n\n    return self.flow_width\n</code></pre>"},{"location":"stdag.html#flowpaths.stdag.stDAG.get_width","title":"get_width","text":"<pre><code>get_width(\n    edges_to_ignore: list = None,\n) -&gt; int\n</code></pre> <p>Calculate and return the width of the graph. The width is computed as the minimum number of paths needed to cover all the edges of the graph,  except those in the <code>edges_to_ignore</code> list. </p> <p>If the width has already been computed and <code>edges_to_ignore</code> is empty, the stored value is returned.</p>"},{"location":"stdag.html#flowpaths.stdag.stDAG.get_width--returns","title":"Returns","text":"<ul> <li>int: The width of the graph.</li> </ul> Source code in <code>flowpaths/stdag.py</code> <pre><code>def get_width(self, edges_to_ignore: list = None) -&gt; int:\n    \"\"\"\n    Calculate and return the width of the graph.\n    The width is computed as the minimum number of paths needed to cover all the edges of the graph, \n    except those in the `edges_to_ignore` list. \n\n    If the width has already been computed and `edges_to_ignore` is empty,\n    the stored value is returned.\n\n    Returns\n    ----------\n    - int: The width of the graph.\n    \"\"\"\n\n    if self.width is not None and (edges_to_ignore is None or len(edges_to_ignore) == 0):\n        return self.width\n\n    edges_to_ignore_set = set(edges_to_ignore or [])\n\n    weight_function = {e: 1 for e in self.edges() if e not in edges_to_ignore_set}\n\n    width = self.compute_max_edge_antichain(get_antichain=False, weight_function=weight_function)\n    if (edges_to_ignore is None or len(edges_to_ignore) == 0):\n        self.width = width\n\n    return width\n</code></pre>"},{"location":"stdigraph.html","title":"Directed graphs with global source and global sink","text":"<p>This class is used in AbstractWalkModelDiGraph as a wrapper (with unique global source and unique global sink) to pass the directed graph to the ILP models.</p>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph","title":"stDiGraph","text":"<pre><code>stDiGraph(\n    base_graph: DiGraph,\n    additional_starts: (\n        list | None\n    ) = None,\n    additional_ends: (\n        list | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>AbstractSourceSinkGraph</code></p> <p>General directed graph with global source/sink and SCC condensation helpers.</p> <p>This class now subclasses <code>AbstractSourceSinkGraph</code>, which performs the common augmentation (adding global source/sink and validating additional boundary nodes). The remaining logic here focuses on strongly connected component (SCC) handling and the condensation expansion used for width and incompatible sequence computations.</p> <p>This class inherits from networkx.DiGraph. The graph equals <code>base_graph</code> plus:</p> <ul> <li>a global source connected to all sources of <code>base_graph</code> and to all nodes in <code>additional_starts</code>;</li> <li>a global sink connected from all sinks of <code>base_graph</code> and from all nodes in <code>additional_ends</code>.</li> </ul> <p>Warning</p> <p>The graph <code>base_graph</code> must satisfy the following properties:</p> <ul> <li>the nodes must be strings; </li> <li><code>base_graph</code> must have at least one source (i.e. node without incoming edges), or at least one node in <code>additional_starts</code>;</li> <li><code>base_graph</code> must have at least one sink (i.e. node without outgoing edges), or at least one node in <code>additional_ends</code>.</li> </ul>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph--raises","title":"Raises:","text":"<ul> <li><code>ValueError</code>: If any of the above three conditions are not satisfied.</li> <li><code>ValueError</code>: If any node in <code>additional_starts</code> is not in the base graph.</li> <li><code>ValueError</code>: If any node in <code>additional_ends</code> is not in the base graph.</li> </ul> Source code in <code>flowpaths/stdigraph.py</code> <pre><code>def __init__(\n    self,\n    base_graph: nx.DiGraph,\n    additional_starts: Optional[list] = None,\n    additional_ends: Optional[list] = None,\n):\n    \"\"\"\n    This class inherits from networkx.DiGraph. The graph equals `base_graph` plus:\n\n    - a global source connected to all sources of `base_graph` and to all nodes in `additional_starts`;\n    - a global sink connected from all sinks of `base_graph` and from all nodes in `additional_ends`.\n\n    !!! warning Warning\n\n        The graph `base_graph` must satisfy the following properties:\n\n        - the nodes must be strings; \n        - `base_graph` must have at least one source (i.e. node without incoming edges), or at least one node in `additional_starts`;\n        - `base_graph` must have at least one sink (i.e. node without outgoing edges), or at least one node in `additional_ends`.\n\n    Raises:\n    -------\n    - `ValueError`: If any of the above three conditions are not satisfied.\n    - `ValueError`: If any node in `additional_starts` is not in the base graph.\n    - `ValueError`: If any node in `additional_ends` is not in the base graph.\n\n    \"\"\"\n    self._condensation_expanded = None\n    super().__init__(\n        base_graph=base_graph,\n        additional_starts=additional_starts,\n        additional_ends=additional_ends,\n    )\n</code></pre>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.compute_edge_max_reachable_value","title":"compute_edge_max_reachable_value","text":"<pre><code>compute_edge_max_reachable_value(\n    flow_attr: str,\n) -&gt; Dict[\n    Tuple[str, str], float\n]\n</code></pre> <p>For each base edge (u,v), compute the maximum <code>flow_attr</code> over: - the edge (u,v) itself, - any edge reachable forward from v, - any edge whose head can reach u (i.e., backward reachability to u).</p> <p>Efficiently uses the precomputed SCC condensation and runs dynamic programming on the condensation DAG.</p> <p>Returns a dict mapping each original edge (u,v) to the computed float. </p> <p>If an edge has a missing ``flow_attr\u2019\u2019 (the source and sink edges) we treat its flow value as 0.</p>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.compute_edge_max_reachable_value--examples","title":"Examples","text":"<p>import networkx as nx from flowpaths.stdigraph import stDiGraph G = nx.DiGraph() G.add_edge(\u201ca\u201d, \u201cb\u201d, flow=1) G.add_edge(\u201cb\u201d, \u201cc\u201d, flow=5) G.add_edge(\u201cc\u201d, \u201ca\u201d, flow=3)  # cycle among a,b,c G.add_edge(\u201cc\u201d, \u201cd\u201d, flow=2) H = stDiGraph(G) res = H.compute_edge_max_reachable_value(\u201cflow\u201d)</p> Source code in <code>flowpaths/stdigraph.py</code> <pre><code>def compute_edge_max_reachable_value(self, flow_attr: str) -&gt; Dict[Tuple[str, str], float]:\n    \"\"\"For each base edge (u,v), compute the maximum ``flow_attr`` over:\n    - the edge (u,v) itself,\n    - any edge reachable forward from v,\n    - any edge whose head can reach u (i.e., backward reachability to u).\n\n    Efficiently uses the precomputed SCC condensation and runs dynamic programming on\n    the condensation DAG.\n\n    Returns a dict mapping each original edge (u,v) to the computed float. \n\n    If an edge has a missing ``flow_attr'' (the source and sink edges) we treat its flow value as 0.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import networkx as nx\n    &gt;&gt;&gt; from flowpaths.stdigraph import stDiGraph\n    &gt;&gt;&gt; G = nx.DiGraph()\n    &gt;&gt;&gt; G.add_edge(\"a\", \"b\", flow=1)\n    &gt;&gt;&gt; G.add_edge(\"b\", \"c\", flow=5)\n    &gt;&gt;&gt; G.add_edge(\"c\", \"a\", flow=3)  # cycle among a,b,c\n    &gt;&gt;&gt; G.add_edge(\"c\", \"d\", flow=2)\n    &gt;&gt;&gt; H = stDiGraph(G)\n    &gt;&gt;&gt; res = H.compute_edge_max_reachable_value(\"flow\")\n    &gt;&gt;&gt; # Every edge can reach an edge of weight 5 within the SCC or forward\n    &gt;&gt;&gt; res[(\"a\", \"b\")] == 5 and res[(\"b\", \"c\")] == 5 and res[(\"c\", \"a\")] == 5 and res[(\"c\", \"d\")] == 5\n    True\n    \"\"\"\n    C: nx.DiGraph = self._condensation\n    mapping = C.graph[\"mapping\"]  # original node -&gt; condensation node (int)\n\n    # 2) Precompute per-SCC local maxima and per-edge weights.\n    #\n    #    - local_out[c]: the max weight of any edge whose TAIL is inside SCC `c`.\n    #      This represents the best edge you can reach by going forward from any\n    #      node in this SCC (including edges that stay inside the SCC or that exit it).\n    #\n    #    - local_in[c]: the max weight of any edge whose HEAD is inside SCC `c`.\n    #      This captures the best edge that can reach this SCC (used for backward reachability).\n    #\n    #    We also record each edge's own weight so the final answer includes (u,v) itself.\n    local_out = {c: 0.0 for c in C.nodes()}\n    local_in = {c: 0.0 for c in C.nodes()}\n\n    edge_weight: Dict[Tuple[str, str], float] = {}\n    for u, v, data in self.edges(data=True):\n        w = float(data.get(flow_attr, 0.0))\n        edge_weight[(u, v)] = w\n        cu = mapping[u]\n        cv = mapping[v]\n        if w &gt; local_out[cu]:\n            local_out[cu] = w\n        if w &gt; local_in[cv]:\n            local_in[cv] = w\n\n    topological_sort = list(nx.topological_sort(C))\n\n    # 3) Forward DP over the condensation DAG to compute, for each SCC `c`, the\n    #    maximum edge weight reachable from `c` by moving forward along DAG edges.\n    #    Because SCCs are contracted, this also correctly accounts for reachability\n    #    within cycles (inside a single SCC).\n    max_desc = {c: local_out[c] for c in C.nodes()}\n    for c in reversed(topological_sort):\n        for s in C.successors(c):\n            if max_desc[s] &gt; max_desc[c]:\n                max_desc[c] = max_desc[s]\n\n    # 4) Backward DP (propagated forward along edges) to compute, for each SCC `c`, the\n    #    maximum edge weight among edges whose HEAD can reach `c` (i.e. along the\n    #    reversed condensation DAG). We propagate `local_in` from ancestors to successors\n    #    in topological order.\n    max_anc = {c: local_in[c] for c in C.nodes()}\n    for c in topological_sort:\n        for s in C.successors(c):\n            if max_anc[c] &gt; max_anc[s]:\n                max_anc[s] = max_anc[c]\n\n    # 5) For each original edge (u,v), combine:\n    #    - the edge's own weight,\n    #    - the best reachable-from-SCC(v) weight (forward), and\n    #    - the best reaching-SCC(u) weight (backward).\n    #\n    #    If no reachable candidate exists, the value is 0.0 by construction of locals.\n    result: Dict[Tuple[str, str], float] = {}\n    for u, v in self.edges():\n        cu = mapping[u]\n        cv = mapping[v]\n        result[(u, v)] = max(edge_weight[(u, v)], max_desc[cv], max_anc[cu])\n\n    return result\n</code></pre>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.compute_edge_max_reachable_value--every-edge-can-reach-an-edge-of-weight-5-within-the-scc-or-forward","title":"Every edge can reach an edge of weight 5 within the SCC or forward","text":"<p>res[(\u201ca\u201d, \u201cb\u201d)] == 5 and res[(\u201cb\u201d, \u201cc\u201d)] == 5 and res[(\u201cc\u201d, \u201ca\u201d)] == 5 and res[(\u201cc\u201d, \u201cd\u201d)] == 5 True</p>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.get_avg_size_of_non_trivial_SCC","title":"get_avg_size_of_non_trivial_SCC","text":"<pre><code>get_avg_size_of_non_trivial_SCC() -&gt; (\n    int\n)\n</code></pre> <p>Returns the average size (in terms of number of edges) of non-trivial SCCs (i.e. SCCs with at least one edge).</p> Source code in <code>flowpaths/stdigraph.py</code> <pre><code>def get_avg_size_of_non_trivial_SCC(self) -&gt; int:\n    \"\"\"\n    Returns the average size (in terms of number of edges) of non-trivial SCCs (i.e. SCCs with at least one edge).\n    \"\"\"\n    sizes = [len(self._condensation.graph['member_edges'][str(v)]) for v in self._condensation.nodes() if len(self._condensation.graph['member_edges'][str(v)]) &gt; 0]\n    return sum(sizes) // len(sizes) if sizes else 0\n</code></pre>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.get_number_of_nontrivial_SCCs","title":"get_number_of_nontrivial_SCCs","text":"<pre><code>get_number_of_nontrivial_SCCs() -&gt; (\n    int\n)\n</code></pre> <p>Returns the number of non-trivial SCCs (i.e. SCCs with at least one edge).</p> Source code in <code>flowpaths/stdigraph.py</code> <pre><code>def get_number_of_nontrivial_SCCs(self) -&gt; int:\n    \"\"\"\n    Returns the number of non-trivial SCCs (i.e. SCCs with at least one edge).\n    \"\"\"\n\n    return sum(1 for v in self._condensation.nodes() if len(self._condensation.graph['member_edges'][str(v)]) &gt; 0)\n</code></pre>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.get_size_of_largest_SCC","title":"get_size_of_largest_SCC","text":"<pre><code>get_size_of_largest_SCC() -&gt; (\n    int\n)\n</code></pre> <p>Returns the size of the largest SCC (in terms of number of edges).</p> Source code in <code>flowpaths/stdigraph.py</code> <pre><code>def get_size_of_largest_SCC(self) -&gt; int:\n    \"\"\"\n    Returns the size of the largest SCC (in terms of number of edges).\n    \"\"\"\n    return max((len(self._condensation.graph['member_edges'][str(v)]) for v in self._condensation.nodes()), default=0)\n</code></pre>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.get_width","title":"get_width","text":"<pre><code>get_width(\n    edges_to_ignore: list = None,\n) -&gt; int\n</code></pre> <p>Returns the width of the graph, which we define as the minimum number of \\(s\\)-\\(t\\) walks needed to cover all edges.</p> <p>This is computed as the width of the condensation DAGs (minimum number of \\(s\\)-\\(t\\) paths to cover all edges), with the following modification. Nodes <code>v</code> in the condensation corresponding to non-trivial SCCs (i.e. SCCs with more than one node, equivalent to having at least one edge)  are subdivided into a edge <code>(v, v_expanded)</code>, all condensation in-neighbors of <code>v</code> are connected to <code>v</code>, and all condensation out-neighbors of <code>v</code> are connected from <code>v_expanded</code>.</p>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.get_width--parameters","title":"Parameters:","text":"<ul> <li> <p><code>edges_to_ignore</code>: A list of edges in the original graph to ignore when computing the width.</p> <p>The width is then computed as as above, with the exception that:</p> <ul> <li> <p>If an edge <code>(u,v)</code> in <code>edges_to_ignore</code> is between different SCCs,      then the corresponding edge to ignore is between the two SCCs in the condensation graph,      and we can ignore it when computing the normal width of the condensation.</p> </li> <li> <p>If an edge <code>(u,v)</code> in <code>edges_to_ignore</code> is inside the same SCC,      then we remove the edge <code>(u,v)</code> from (a copy of) the member edges of the SCC in the condensation.      If an SCC <code>v</code> has no more member edges left, we can also add the condensation edge <code>(v, v_expanded)</code> to     the list of edges to ignore when computing the width of the condensation.</p> </li> </ul> </li> </ul> Source code in <code>flowpaths/stdigraph.py</code> <pre><code>def get_width(self, edges_to_ignore: list = None) -&gt; int:\n    \"\"\"\n    Returns the width of the graph, which we define as the minimum number of $s$-$t$ walks needed to cover all edges.\n\n    This is computed as the width of the condensation DAGs (minimum number of $s$-$t$ paths to cover all edges), with the following modification.\n    Nodes `v` in the condensation corresponding to non-trivial SCCs (i.e. SCCs with more than one node, equivalent to having at least one edge) \n    are subdivided into a edge `(v, v_expanded)`, all condensation in-neighbors of `v` are connected to `v`,\n    and all condensation out-neighbors of `v` are connected from `v_expanded`.\n\n    Parameters:\n    -----------\n    - `edges_to_ignore`: A list of edges in the original graph to ignore when computing the width.\n\n        The width is then computed as as above, with the exception that:\n\n        - If an edge `(u,v)` in `edges_to_ignore` is between different SCCs, \n            then the corresponding edge to ignore is between the two SCCs in the condensation graph, \n            and we can ignore it when computing the normal width of the condensation.\n\n        - If an edge `(u,v)` in `edges_to_ignore` is inside the same SCC, \n            then we remove the edge `(u,v)` from (a copy of) the member edges of the SCC in the condensation. \n            If an SCC `v` has no more member edges left, we can also add the condensation edge `(v, v_expanded)` to\n            the list of edges to ignore when computing the width of the condensation.\n    \"\"\"\n\n    if self.condensation_width is not None and (edges_to_ignore is None or len(edges_to_ignore) == 0):\n        return self.condensation_width\n\n    # We transform each edge in edges_to_ignore (which are edges of self)\n    # into an edge in the expanded graph\n    edges_to_ignore_expanded = []\n    member_edges = copy.deepcopy(self._condensation.graph['member_edges'])\n    edge_multiplicity = copy.deepcopy(self._condensation.graph[\"edge_multiplicity\"])\n    utils.logger.debug(f\"{__name__}: edge_multiplicity for edges in the condensation: {edge_multiplicity}\")\n\n    for u, v in (edges_to_ignore or []):\n        # If (u,v) is an edge between different SCCs\n        # Then the corresponding edge to ignore is between the two SCCs\n        if not self.is_scc_edge(u, v):\n            edge_multiplicity[self._edge_to_condensation_edge(u, v)] -= 1\n        else:\n            # (u,v) is an edge within the same SCC\n            # and thus we remove the edge (u,v) from the member edges\n            member_edges[self._edge_to_condensation_node(u, v)].discard((u, v))\n\n    weight_function_condensation_expanded = {e: 0 for e in self._condensation_expanded.edges()}\n\n    for u,v in self._condensation.edges:\n        weight_function_condensation_expanded[self._condensation_edge_to_condensation_expanded_edge(u,v)] = edge_multiplicity[(u,v)]\n\n    # We also add to edges_to_ignore_expanded the expanded edges arising from non-trivial SCCs\n    # (i.e. SCCs with more than one node, which are expanded into an edge, \n    # i.e. len(self._condensation['member_edges'][node]) &gt; 0)\n    # and for which there are no longer member edges (because all were in edges_to_ignore)\n    for node in self._condensation.nodes():\n        if len(member_edges[str(node)]) == 0 and len(self._condensation.graph['member_edges'][str(node)]) &gt; 0:\n            weight_function_condensation_expanded[(str(node), self._expanded(node))] = 0\n        else:\n            weight_function_condensation_expanded[(str(node), self._expanded(node))] = 1\n\n    utils.logger.debug(f\"{__name__}: Edges to ignore in the expanded graph: {edges_to_ignore_expanded}\")\n\n    utils.logger.debug(f\"{__name__}: Condensation expanded graph: {self._condensation_expanded.edges()}\")\n    # width = self._condensation_expanded.get_width(edges_to_ignore=edges_to_ignore_expanded)\n\n    width = self._condensation_expanded.compute_max_edge_antichain(get_antichain=False, weight_function=weight_function_condensation_expanded)\n\n    utils.logger.debug(f\"{__name__}: Width of the condensation expanded graph: {width}\")\n\n    if (edges_to_ignore is None or len(edges_to_ignore) == 0):\n        self.condensation_width = width\n\n    # DEBUG code\n    # utils.draw(\n    #         G=self._condensation_expanded,\n    #         filename=\"condensation_expanded.pdf\",\n    #         flow_attr=\"flow\",\n    #         draw_options={\n    #         \"show_graph_edges\": True,\n    #         \"show_edge_weights\": False,\n    #         \"show_path_weights\": False,\n    #         \"show_path_weight_on_first_edge\": True,\n    #         \"pathwidth\": 2,\n    #     })\n\n    return width\n</code></pre>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.is_scc_edge","title":"is_scc_edge","text":"<pre><code>is_scc_edge(u, v) -&gt; bool\n</code></pre> <p>Returns True if (u,v) is an edge inside an SCC of self, False otherwise.</p> Source code in <code>flowpaths/stdigraph.py</code> <pre><code>def is_scc_edge(self, u, v) -&gt; bool:\n    \"\"\"\n    Returns True if (u,v) is an edge inside an SCC of self, False otherwise.\n    \"\"\"\n\n    # Check if (u,v) is an edge of the graph\n    if (u,v) not in self.edges():\n        utils.logger.error(f\"{__name__}: Edge ({u},{v}) is not in the graph.\")\n        raise ValueError(f\"Edge ({u},{v}) is not in the graph.\")\n\n    return self._condensation.graph['mapping'][u] == self._condensation.graph['mapping'][v]\n</code></pre>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.nodes_reachable","title":"nodes_reachable","text":"<pre><code>nodes_reachable(\n    node: str,\n) -&gt; Set[str]\n</code></pre> <p>Return the set of nodes reachable from <code>node</code> (including itself).</p> <p>The result is cached per query node. Reachability is computed on the SCC condensation DAG: for the SCC containing <code>node</code>, take all SCCs reachable in the condensation (including itself) and return the union of original nodes lying in any of those SCCs.</p>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.nodes_reachable--parameters","title":"Parameters","text":"<p>node: str     The node <code>v</code> in this graph from which to evaluate forward reachability.</p>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.nodes_reachable--returns","title":"Returns","text":"<p>Set[str]     All nodes <code>a</code> such that there exists a path from <code>node</code> to <code>a</code>.</p> Source code in <code>flowpaths/stdigraph.py</code> <pre><code>def nodes_reachable(self, node: str) -&gt; Set[str]:\n    \"\"\"Return the set of nodes reachable from ``node`` (including itself).\n\n    The result is cached per query node. Reachability is computed on the SCC\n    condensation DAG: for the SCC containing ``node``, take all SCCs reachable\n    in the condensation (including itself) and return the union of original\n    nodes lying in any of those SCCs.\n\n    Parameters\n    ----------\n    node: str\n        The node ``v`` in this graph from which to evaluate forward reachability.\n\n    Returns\n    -------\n    Set[str]\n        All nodes ``a`` such that there exists a path from ``node`` to ``a``.\n    \"\"\"\n    if node not in self.nodes():\n        utils.logger.error(f\"{__name__}: Node {node} is not in the graph.\")\n        raise ValueError(f\"Node {node} is not in the graph.\")\n    if node in self._nodes_reachable_from_node_cache:\n        return self._nodes_reachable_from_node_cache[node]\n\n    C: nx.DiGraph = self._condensation\n    mapping = C.graph[\"mapping\"]\n    cv = mapping[node]\n\n    # All SCCs reachable from cv (descendants) plus itself\n    reachable_sccs = set(nx.descendants(C, cv)) | {cv}\n\n    result: Set[str] = set()\n    for c in reachable_sccs:\n        result |= self._nodes_by_scc.get(c, set())\n\n    self._nodes_reachable_from_node_cache[node] = result\n    return result\n</code></pre>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.nodes_reaching","title":"nodes_reaching","text":"<pre><code>nodes_reaching(\n    node: str,\n) -&gt; Set[str]\n</code></pre> <p>Return the set of nodes that can reach <code>node</code> (including itself).</p> <p>The result is cached per query node. Reachability is computed on the SCC condensation DAG: for the SCC containing <code>node</code>, take all SCCs that can reach it (ancestors, including itself) and return the union of original nodes lying in any of those SCCs.</p>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.nodes_reaching--parameters","title":"Parameters","text":"<p>node: str     The node <code>u</code> in this graph to evaluate backward reachability to <code>u</code>.</p>"},{"location":"stdigraph.html#flowpaths.stdigraph.stDiGraph.nodes_reaching--returns","title":"Returns","text":"<p>Set[str]     All nodes <code>a</code> such that there exists a path from <code>a</code> to <code>node</code>.</p> Source code in <code>flowpaths/stdigraph.py</code> <pre><code>def nodes_reaching(self, node: str) -&gt; Set[str]:\n    \"\"\"Return the set of nodes that can reach ``node`` (including itself).\n\n    The result is cached per query node. Reachability is computed on the SCC\n    condensation DAG: for the SCC containing ``node``, take all SCCs that can\n    reach it (ancestors, including itself) and return the union of original\n    nodes lying in any of those SCCs.\n\n    Parameters\n    ----------\n    node: str\n        The node ``u`` in this graph to evaluate backward reachability to ``u``.\n\n    Returns\n    -------\n    Set[str]\n        All nodes ``a`` such that there exists a path from ``a`` to ``node``.\n    \"\"\"\n    if node not in self.nodes():\n        utils.logger.error(f\"{__name__}: Node {node} is not in the graph.\")\n        raise ValueError(f\"Node {node} is not in the graph.\")\n    if node in self._nodes_reaching_node_cache:\n        return self._nodes_reaching_node_cache[node]\n\n    C: nx.DiGraph = self._condensation\n    mapping = C.graph[\"mapping\"]\n    cu = mapping[node]\n\n    # All SCCs that can reach cu (ancestors) plus itself\n    ancestor_sccs = set(nx.ancestors(C, cu)) | {cu}\n\n    result: Set[str] = set()\n    for c in ancestor_sccs:\n        result |= self._nodes_by_scc.get(c, set())\n\n    self._nodes_reaching_node_cache[node] = result\n    return result\n</code></pre>"},{"location":"subpath-constraints.html","title":"Subpath constraints in DAGs","text":"<p>See also</p> <ul> <li>Subset constraints in general graphs</li> </ul>"},{"location":"subpath-constraints.html#1-definition","title":"1. Definition","text":"<p>To any of the models on directed acyclic graphs that are based on (or inherit from) the AbstractPathModelDAG class you can add subpath constraints. This means the following. Say that you have prior knowledge of some (shorter) paths that must appear in at least one solution path of you model. These constrain the space of possible solution paths.</p> <p>Let\u2019s consider the Minimum Flow Decomposition problem, and let\u2019s take the example graph from there. Let\u2019s assume that you want the subpath <code>[a,c,t]</code> (which we draw in brown) to appear in at last one solution path. </p> <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|6| a\n    a --&gt;|2| b\n    s --&gt;|7| b\n    a --&gt;|4| c\n    b --&gt;|9| c\n    c --&gt;|6| d\n    d --&gt;|6| t\n    c --&gt;|7| t\n    linkStyle 3,7 stroke:brown,stroke-width:3;</code></pre> <p>For example, the following flow decomposition doesn\u2019t contain <code>[a,c,t]</code>, in the sense that neither red, orange, or blue paths contain it.</p> <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    s --&gt;|4| a\n    a --&gt;|4| c\n    c --&gt;|4| d\n    d --&gt;|4| t\n    linkStyle 0,1,2,3 stroke:red,stroke-width:3;\n    s --&gt;|2| a\n    a --&gt;|2| b\n    b --&gt;|2| c\n    c --&gt;|2| d\n    d --&gt;|2| t\n    linkStyle 4,5,6,7,8 stroke:orange,stroke-width:3;\n    s --&gt;|7| b\n    b --&gt;|7| c\n    c --&gt;|7| t\n    linkStyle 9,10,11 stroke:blue,stroke-width:3;</code></pre> <p>A valid decomposition that contains it, and has the minimum number of paths is the following. Note that <code>[a,c,t]</code> now appears in the orange path.</p> <pre><code>flowchart LR\n    s((s))\n    a((a))\n    b((b))\n    c((c))\n    d((d))\n    t((t))\n    c --&gt;|6| d\n    d --&gt;|6| t\n    s --&gt;|2| a\n    a --&gt;|2| b\n    b --&gt;|2| c\n    c --&gt;|2| t\n    linkStyle 2,3,4,5 stroke:red,stroke-width:3;\n    s --&gt;|4| a\n    a --&gt;|4| c\n    c --&gt;|4| t\n    linkStyle 6,7,8 stroke:orange,stroke-width:3;\n    s --&gt;|1| b\n    b --&gt;|1| c\n    c --&gt;|1| t\n    linkStyle 9,10,11 stroke:blue,stroke-width:3;\n    s --&gt;|6| b\n    b --&gt;|6| c\n    linkStyle 0,1,12,13 stroke:green,stroke-width:3;</code></pre>"},{"location":"subpath-constraints.html#2-example-adding-subpath-constraints-to-minimum-flow-decomposition","title":"2. Example: Adding subpath constraints to Minimum Flow Decomposition","text":"<p>Note 1</p> <p>Any existing decomposition model based on AbstractPathModelDAG supports subpath constraints.</p> <p>Note 2</p> <p>The models support adding non-contiguous subpath constraints. In mathematical terms, they can be sequences of edges that don\u2019t necessarily share endpoints. Then, at least one solution path is required to contain this sequence of edges. Since the graph is a DAG, then the edges also appear in the order they are in the sequence.</p> <p>We create the graph as a networkx DiGraph.</p> <pre><code>import flowpaths as fp\nimport networkx as nx\n\ngraph = nx.DiGraph()\ngraph.add_edge(\"s\", \"a\", flow=6)\ngraph.add_edge(\"s\", \"b\", flow=7)\ngraph.add_edge(\"a\", \"b\", flow=2)\ngraph.add_edge(\"a\", \"c\", flow=4)\ngraph.add_edge(\"b\", \"c\", flow=9)\ngraph.add_edge(\"c\", \"d\", flow=6)\ngraph.add_edge(\"c\", \"t\", flow=7)\ngraph.add_edge(\"d\", \"t\", flow=6)\n</code></pre> <p>We now create a solver by specifying that the flow value of each edge is in the attribute <code>flow</code> of the edges, and setting <code>subpath_constraints</code> as a list, containing the single constraint <code>[(\"a\", \"c\"),(\"c\", \"t\")]</code>. Note that we pass the constraint as a list of edges, because of Note 2 above.</p> <pre><code>mfd_model = fp.MinFlowDecomp(\n        graph, \n        flow_attr=\"flow\", \n        subpath_constraints=[[(\"a\", \"c\"),(\"c\", \"t\")]])\n\nmfd_model.solve() # We solve it\nif mfd_model.is_solved():\n    print(mfd_model.get_solution())\n    # {'paths': [['s', 'a', 'b', 'c', 't'], ['s', 'a', 'c', 't'], ['s', 'b', 'c', 't'], ['s', 'b', 'c', 'd', 't']], 'weights': [2.0, 4.0, 1.0, 6.0]}\n</code></pre>"},{"location":"subpath-constraints.html#3-relaxing-the-constraint-coverage","title":"3. Relaxing the constraint coverage","text":""},{"location":"subpath-constraints.html#31-edge-coverage-fraction","title":"3.1 Edge coverage fraction","text":"<p>Suppose that you have have a subpath constraint, but you\u2019re not sure the subpath must appear entirely in a solution path. In this case, you can require that a give fraction of its edges appear in a solution path. For example, say you have the constraint <code>['s','a','c','t']</code>. Then, if you require that 50% of its edges appear in a solution path, the red path in the first flow decomposition on top (with 3 paths) contains <code>['s','a','c']</code>, thus 66% of its edges appea in the red path, and thus the decomposition satisfies this constraint. You can set this percentage via the parameter <code>subpath_constraints_coverage</code> \\(\\in [0,1]\\).</p> <pre><code>mfd_model = fp.MinFlowDecomp(\n        graph, \n        flow_attr=\"flow\", \n        subpath_constraints=[[(\"s\", \"a\"),(\"a\", \"c\"),(\"c\",\"t\")]], \n        subpath_constraints_coverage=0.75)\n</code></pre>"},{"location":"subpath-constraints.html#32-edge-length-coverage-fraction","title":"3.2 Edge length coverage fraction","text":"<p>If for every edge you also have an associated length, then you can specify the coverage constraint as a fraction of the total edge length of the contraint.</p> <p>For example, suppose we have a graph, where the attribute <code>length</code> stores the edge lengths.</p> <pre><code>graph2 = nx.DiGraph()\ngraph2.add_edge(\"s\", \"a\", flow=6, length=1) #\ngraph2.add_edge(\"s\", \"b\", flow=7, length=2)\ngraph2.add_edge(\"a\", \"b\", flow=2, length=9)\ngraph2.add_edge(\"a\", \"c\", flow=4, length=20) #\ngraph2.add_edge(\"b\", \"c\", flow=9, length=9)\ngraph2.add_edge(\"c\", \"d\", flow=6, length=29)\ngraph2.add_edge(\"c\", \"t\", flow=7, length=15) #\ngraph2.add_edge(\"d\", \"t\", flow=6, length=1)\n</code></pre> <p>When initializing the solver, we pass <code>length_attr=\"length\"</code> so that the solver knows from which edge attribute to get the lengths, and set the parameter <code>subpath_constraints_coverage_length</code> to say 0.6. The constraint has total length 1+20+15 = 36, and the length coverage fraction requires that 0.6 * 36 = 6 of the subpath length be covered by some solution path. This means that covering the edge <code>(\"s\", \"a\")</code> alone is not enough to satisfy the constraint, as it could cover only length 1.</p> <pre><code>mfd_model = fp.MinFlowDecomp(\n    graph2, \n    flow_attr=\"flow\", \n    length_attr=\"length\", \n    subpath_constraints=[[(\"s\", \"a\"),(\"a\", \"c\"),(\"c\",\"t\")]], \n    subpath_constraints_coverage_length=0.6\n    )\n</code></pre>"},{"location":"subset-constraints.html","title":"Subset constraints in general graphs","text":"<p>See also</p> <ul> <li>Subpath constraints in DAGs</li> </ul> <p>To any of the models on directed graphs (possibly with cycles) that are based on (or inherit from) the AbstractWalkModelDiGraph class you can add subset constraints. As opposed to the subpath constraints that you can add for directed acyclic graphs, here they mean the following.</p> <p>Say that you have prior knowledge of some set of edges that must appear together in at least one solution walk of you model. These constrain the space of possible solution walks.</p> <p>Let\u2019s consider the Minimum Flow Decomposition problem in graphs with cycles, and let\u2019s take the example graph from there. Let\u2019s assume that you want the set <code>[(a,b),(c,a)]</code> (which we draw in brown) to appear in at last one solution walk. </p> <pre><code>flowchart LR\n    s((s))\n    a((a))\n    t((t))\n    b((b))\n    c((c))\n\n    s --&gt;|7| a\n    a --&gt;|7| t\n    a --&gt;|5| b\n    b --&gt;|5| a\n    a --&gt;|2| c\n    c --&gt;|2| a\n    linkStyle 2,5 stroke:brown,stroke-width:3;</code></pre> <p>For example, the following flow decomposition doesn\u2019t contain the full set <code>[(a,b),(c,a)]</code>, in the sense that neither red nor blue walks contain it.</p> <pre><code>flowchart LR\n    s((s))\n    a((a))\n    t((t))\n    b((b))\n    c((c))\n\n    s --&gt;|5| a\n    a --&gt;|5| t\n    a --&gt;|5| b\n    b --&gt;|5| a\n\n\n    s --&gt;|2| a\n    a --&gt;|2| c\n    c --&gt;|2| a\n    a --&gt;|2| t\n    linkStyle 0,1,2,3 stroke:red,stroke-width:3;\n    linkStyle 4,5,6,7 stroke:blue,stroke-width:3;</code></pre> <p>A valid decomposition that contains it, and has the minimum number of walks among these, is the following. Note that <code>[(a,b),(c,a)]</code> now appears in the orange walk.</p> <p>Note also that if the orange walk is \\(s\\), \\(a\\), \\(c\\), \\(a\\), \\(b\\), \\(a\\), \\(t\\) then it does not contain the edges in the order <code>(a,b),(c,a)</code>. In fact, the subpath constraints cannot guarantee any order in which the edges in the set appear in a walk containing them.</p> <pre><code>flowchart LR\n    s((s))\n    a((a))\n    t((t))\n    b((b))\n    c((c))\n\n    s --&gt;|3| a\n    a --&gt;|3| t\n    s --&gt;|2| a\n    a --&gt;|2| t\n    a --&gt;|2| b\n    b --&gt;|2| a\n    a --&gt;|3| b\n    b --&gt;|3| a\n\n\n    s --&gt;|2| a\n    a --&gt;|2| c\n    c --&gt;|2| a\n    a --&gt;|2| t\n    linkStyle 2,4,5,9,10,3 stroke:orange,stroke-width:3;\n    linkStyle 0,6,7,1 stroke:red,stroke-width:3;\n    linkStyle 8,11 stroke:blue,stroke-width:3;</code></pre> <p>Note 1</p> <p>Any existing decomposition model based on AbstractWalkModelDiGraph supports subset constraints.</p> <p>Note 2</p> <ul> <li>The subset constraints can be any set of edges that don\u2019t necessarily share endpoints. </li> <li>The model does not guarantee that the edges in a subset constraint appear in a solution walk in any given order. It is only guaranteed that at least one solution walk contain this sequence of edges.</li> </ul>"},{"location":"utils.html","title":"Various utils","text":"<p>Flowpaths implements various helper functions on graphs. They can be access with the prefix <code>flowpaths.utils.</code></p>"},{"location":"utils.html#graph-visualization-and-drawing","title":"Graph visualization and drawing","text":"<p>You can create drawing as this one</p> <p></p> <p>using the following code:</p> <pre><code>import flowpaths as fp\nimport networkx as nx\n\n# Create a simple graph\ngraph = nx.DiGraph()\ngraph.graph[\"id\"] = \"simple_graph\"\ngraph.add_edge(\"s\", \"a\", flow=6)\ngraph.add_edge(\"s\", \"b\", flow=7)\ngraph.add_edge(\"a\", \"b\", flow=2)\ngraph.add_edge(\"a\", \"c\", flow=5)\ngraph.add_edge(\"b\", \"c\", flow=9)\ngraph.add_edge(\"c\", \"d\", flow=6)\ngraph.add_edge(\"c\", \"t\", flow=7)\ngraph.add_edge(\"d\", \"t\", flow=6)\n\n# Solve the minimum path error model\nmpe_model = fp.kMinPathError(graph, flow_attr=\"flow\", k=3, weight_type=float)\nmpe_model.solve()\n\n# Draw the solution\nif mpe_model.is_solved():\n    solution = mpe_model.get_solution()\n    fp.utils.draw(\n        G=graph,\n        filename=\"simple_graph.pdf\",\n        flow_attr=\"flow\",\n        paths=solution[\"paths\"],\n        weights=solution[\"weights\"],\n        draw_options={\n        \"show_graph_edges\": True,\n        \"show_edge_weights\": False,\n        \"show_path_weights\": False,\n        \"show_path_weight_on_first_edge\": True,\n        \"pathwidth\": 2,\n    })\n</code></pre> <p>This produces a file with extension <code>.pdf</code> storing the PDF image of the graph.</p>"},{"location":"utils.html#logging","title":"Logging","text":"<p>flowpaths exposes a simple logging helper via <code>fp.utils.configure_logging</code>. Use it to control verbosity, enable console/file logging, and set file mode.</p> <p>Basic usage (console logging at INFO level):</p> <pre><code>import flowpaths as fp\n\nfp.utils.configure_logging(\n    level=fp.utils.logging.INFO,\n    log_to_console=True,\n)\n</code></pre> <p>Also log to a file (append mode):</p> <pre><code>fp.utils.configure_logging(\n    level=fp.utils.logging.DEBUG,      # default is DEBUG\n    log_to_console=True,               # show logs in terminal\n    log_file=\"flowpaths.log\",         # write logs to this file\n    file_mode=\"a\",                    # \"a\" append (or \"w\" overwrite)\n)\n</code></pre> <p>Notes: - Levels available: <code>fp.utils.logging.DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>. - Default level is DEBUG. If you prefer quieter output, use INFO or WARNING. - Internally, the package logs through its own logger; <code>configure_logging</code> sets handlers/formatters accordingly.</p> <p>API reference:</p> <p>Configures logging for the flowpaths package.</p>"},{"location":"utils.html#flowpaths.utils.logging.configure_logging--parameters","title":"Parameters:","text":"<ul> <li> <p><code>level: int</code>, optional</p> <p>Logging level (e.g., fp.utils.logging.DEBUG, fp.utils.logging.INFO).  Default is fp.utils.logging.DEBUG.</p> </li> <li> <p><code>log_to_console: bool</code>, optional</p> <p>Whether to log to the console. Default is True.</p> </li> <li> <p><code>log_file: str</code>, optional</p> <p>File path to log to. If None, logging to a file is disabled. Default is None. If a file path is provided, the log will be written to that file. If the file already exists, it will be overwritten unless <code>file_mode</code> is set to \u201ca\u201d.</p> </li> <li> <p><code>file_mode: str</code>, optional</p> <p>Mode for the log file. \u201ca\u201d (append) or \u201cw\u201d (overwrite). Default is \u201cw\u201d.</p> </li> </ul> Source code in <code>flowpaths/utils/logging.py</code> <pre><code>def configure_logging(\n        level=logging.DEBUG, \n        log_to_console=True, \n        log_file=None, \n        file_mode=\"w\"  # \"a\" for append, \"w\" for overwrite\n    ):\n    \"\"\"\n    Configures logging for the flowpaths package.\n\n    Parameters:\n    -----------\n\n    - `level: int`, optional\n\n        Logging level (e.g., fp.utils.logging.DEBUG, fp.utils.logging.INFO). \n        Default is fp.utils.logging.DEBUG.\n\n    - `log_to_console: bool`, optional\n\n        Whether to log to the console. Default is True.\n\n    - `log_file: str`, optional\n\n        File path to log to. If None, logging to a file is disabled. Default is None.\n        If a file path is provided, the log will be written to that file.\n        If the file already exists, it will be overwritten unless `file_mode` is set to \"a\".\n\n    - `file_mode: str`, optional\n\n        Mode for the log file. \"a\" (append) or \"w\" (overwrite). Default is \"w\".\n\n    \"\"\"\n    # Remove existing handlers to avoid duplicate logs\n    for handler in logger.handlers[:]:\n        logger.removeHandler(handler)\n\n    # Set the logger level\n    logger.setLevel(level)\n\n    # Define a formatter\n    formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n\n    # Add console handler if enabled\n    if log_to_console:\n        console_handler = logging.StreamHandler()\n        console_handler.setLevel(level)\n        console_handler.setFormatter(formatter)\n        logger.addHandler(console_handler)\n\n    if file_mode not in [\"a\", \"w\"]:\n        raise ValueError(\"file_mode must be either 'a' (append) or 'w' (overwrite)\")\n\n    # Add file handler if a file path is provided\n    if log_file:\n        file_handler = logging.FileHandler(log_file, mode=file_mode)  # Use file_mode\n        file_handler.setLevel(level)\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n\n    logger.info(\"Logging initialized: level=%s, console=%s, file=%s, mode=%s\", \n                level, log_to_console, log_file, file_mode)\n</code></pre>"},{"location":"utils.html#flowpaths.utils.graphutils.check_flow_conservation","title":"check_flow_conservation","text":"<pre><code>check_flow_conservation(\n    G: DiGraph, flow_attr\n) -&gt; bool\n</code></pre> <p>Check if the flow conservation property holds for the given graph.</p>"},{"location":"utils.html#flowpaths.utils.graphutils.check_flow_conservation--parameters","title":"Parameters","text":"<ul> <li> <p><code>G</code>: nx.DiGraph</p> <p>The input directed acyclic graph, as networkx DiGraph.</p> </li> <li> <p><code>flow_attr</code>: str</p> <p>The attribute name from where to get the flow values on the edges.</p> </li> </ul>"},{"location":"utils.html#flowpaths.utils.graphutils.check_flow_conservation--returns","title":"Returns","text":"<ul> <li> <p>bool: </p> <p>True if the flow conservation property holds, False otherwise.</p> </li> </ul> Source code in <code>flowpaths/utils/graphutils.py</code> <pre><code>def check_flow_conservation(G: nx.DiGraph, flow_attr) -&gt; bool:\n    \"\"\"\n    Check if the flow conservation property holds for the given graph.\n\n    Parameters\n    ----------\n    - `G`: nx.DiGraph\n\n        The input directed acyclic graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html).\n\n    - `flow_attr`: str\n\n        The attribute name from where to get the flow values on the edges.\n\n    Returns\n    -------\n\n    - bool: \n\n        True if the flow conservation property holds, False otherwise.\n    \"\"\"\n\n    for v in G.nodes():\n        if G.out_degree(v) == 0 or G.in_degree(v) == 0:\n            continue\n\n        out_flow = 0\n        for x, y, data in G.out_edges(v, data=True):\n            if data.get(flow_attr) is None:\n                return False\n            out_flow += data[flow_attr]\n\n        in_flow = 0\n        for x, y, data in G.in_edges(v, data=True):\n            if data.get(flow_attr) is None:\n                return False\n            in_flow += data[flow_attr]\n\n        if out_flow != in_flow:\n            return False\n\n    return True\n</code></pre>"},{"location":"utils.html#flowpaths.utils.graphutils.draw","title":"draw","text":"<pre><code>draw(\n    G: DiGraph,\n    filename: str,\n    flow_attr: str = None,\n    paths: list = [],\n    weights: list = [],\n    additional_starts: list = [],\n    additional_ends: list = [],\n    subpath_constraints: list = [],\n    draw_options: dict = {\n        \"show_graph_edges\": True,\n        \"show_edge_weights\": False,\n        \"show_node_weights\": False,\n        \"show_path_weights\": False,\n        \"show_path_weight_on_first_edge\": True,\n        \"pathwidth\": 3.0,\n        \"style\": \"default\",\n    },\n)\n</code></pre> <p>Draw the graph with the paths and their weights highlighted.</p>"},{"location":"utils.html#flowpaths.utils.graphutils.draw--parameters","title":"Parameters","text":"<ul> <li> <p><code>G</code>: nx.DiGraph </p> <p>The input directed acyclic graph, as networkx DiGraph. </p> </li> <li> <p><code>filename</code>: str</p> <p>The name of the file to save the drawing. The file type is inferred from the extension. Supported extensions are \u2018.bmp\u2019, \u2018.canon\u2019, \u2018.cgimage\u2019, \u2018.cmap\u2019, \u2018.cmapx\u2019, \u2018.cmapx_np\u2019, \u2018.dot\u2019, \u2018.dot_json\u2019, \u2018.eps\u2019, \u2018.exr\u2019, \u2018.fig\u2019, \u2018.gd\u2019, \u2018.gd2\u2019, \u2018.gif\u2019, \u2018.gtk\u2019, \u2018.gv\u2019, \u2018.ico\u2019, \u2018.imap\u2019, \u2018.imap_np\u2019, \u2018.ismap\u2019, \u2018.jp2\u2019, \u2018.jpe\u2019, \u2018.jpeg\u2019, \u2018.jpg\u2019, \u2018.json\u2019, \u2018.json0\u2019, \u2018.pct\u2019, \u2018.pdf\u2019, \u2018.pic\u2019, \u2018.pict\u2019, \u2018.plain\u2019, \u2018.plain-ext\u2019, \u2018.png\u2019, \u2018.pov\u2019, \u2018.ps\u2019, \u2018.ps2\u2019, \u2018.psd\u2019, \u2018.sgi\u2019, \u2018.svg\u2019, \u2018.svgz\u2019, \u2018.tga\u2019, \u2018.tif\u2019, \u2018.tiff\u2019, \u2018.tk\u2019, \u2018.vml\u2019, \u2018.vmlz\u2019, \u2018.vrml\u2019, \u2018.wbmp\u2019, \u2018.webp\u2019, \u2018.x11\u2019, \u2018.xdot\u2019, \u2018.xdot1.2\u2019, \u2018.xdot1.4\u2019, \u2018.xdot_json\u2019, \u2018.xlib\u2019</p> </li> <li> <p><code>flow_attr</code>: str</p> <p>The attribute name from where to get the flow values on the edges. Default is an empty string, in which case no edge weights are shown.</p> </li> <li> <p><code>paths</code>: list</p> <p>The list of paths to highlight, as lists of nodes. Default is an empty list, in which case no path is drawn. Default is an empty list.</p> </li> <li> <p><code>weights</code>: list</p> <p>The list of weights corresponding to the paths, of various colors. Default is an empty list, in which case no path is drawn.</p> </li> <li> <p><code>additional_starts</code>: list</p> <pre><code>A list of additional nodes to highlight in green as starting nodes. Default is an empty list.\n</code></pre> </li> <li> <p><code>additional_ends</code>: list</p> <pre><code>A list of additional nodes to highlight in red as ending nodes. Default is an empty list.\n</code></pre> </li> <li> <p><code>subpath_constraints</code>: list</p> <p>A list of subpaths to highlight in the graph as dashed edges, of various colors. Each subpath is a list of edges. Default is an empty list. There is no association between the subpath colors and the path colors.</p> </li> <li> <p><code>draw_options</code>: dict</p> <p>A dictionary with the following keys:</p> <ul> <li> <p><code>show_graph_edges</code>: bool</p> <p>Whether to show the edges of the graph. Default is <code>True</code>.</p> </li> <li> <p><code>show_edge_weights</code>: bool</p> <p>Whether to show the edge weights in the graph from the <code>flow_attr</code>. Default is <code>False</code>.</p> </li> <li> <p><code>show_node_weights</code>: bool</p> <p>Whether to show the node weights in the graph from the <code>flow_attr</code>. Default is <code>False</code>.</p> </li> <li> <p><code>show_path_weights</code>: bool</p> <p>Whether to show the path weights in the graph on every edge. Default is <code>False</code>.</p> </li> <li> <p><code>show_path_weight_on_first_edge</code>: bool</p> <p>Whether to show the path weight on the first edge of the path. Default is <code>True</code>.</p> </li> <li> <p><code>pathwidth</code>: float</p> <p>The width of the path to be drawn. Default is <code>3.0</code>.</p> </li> <li> <p><code>style</code>: str</p> <p>The style of the drawing. Available options: <code>default</code>, <code>points</code>.</p> </li> </ul> </li> </ul> Source code in <code>flowpaths/utils/graphutils.py</code> <pre><code>def draw(\n        G: nx.DiGraph, \n        filename: str,\n        flow_attr: str = None,\n        paths: list = [], \n        weights: list = [], \n        additional_starts: list = [],\n        additional_ends: list = [],\n        subpath_constraints: list = [],\n        draw_options: dict = {\n            \"show_graph_edges\": True,\n            \"show_edge_weights\": False,\n            \"show_node_weights\": False,\n            \"show_path_weights\": False,\n            \"show_path_weight_on_first_edge\": True,\n            \"pathwidth\": 3.0,\n            \"style\": \"default\",\n        },\n        ):\n        \"\"\"\n        Draw the graph with the paths and their weights highlighted.\n\n        Parameters\n        ----------\n\n        - `G`: nx.DiGraph \n\n            The input directed acyclic graph, as [networkx DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html). \n\n        - `filename`: str\n\n            The name of the file to save the drawing. The file type is inferred from the extension. Supported extensions are '.bmp', '.canon', '.cgimage', '.cmap', '.cmapx', '.cmapx_np', '.dot', '.dot_json', '.eps', '.exr', '.fig', '.gd', '.gd2', '.gif', '.gtk', '.gv', '.ico', '.imap', '.imap_np', '.ismap', '.jp2', '.jpe', '.jpeg', '.jpg', '.json', '.json0', '.pct', '.pdf', '.pic', '.pict', '.plain', '.plain-ext', '.png', '.pov', '.ps', '.ps2', '.psd', '.sgi', '.svg', '.svgz', '.tga', '.tif', '.tiff', '.tk', '.vml', '.vmlz', '.vrml', '.wbmp', '.webp', '.x11', '.xdot', '.xdot1.2', '.xdot1.4', '.xdot_json', '.xlib'\n\n        - `flow_attr`: str\n\n            The attribute name from where to get the flow values on the edges. Default is an empty string, in which case no edge weights are shown.\n\n        - `paths`: list\n\n            The list of paths to highlight, as lists of nodes. Default is an empty list, in which case no path is drawn. Default is an empty list.\n\n        - `weights`: list\n\n            The list of weights corresponding to the paths, of various colors. Default is an empty list, in which case no path is drawn.\n\n        - `additional_starts`: list\n\n                A list of additional nodes to highlight in green as starting nodes. Default is an empty list.\n\n        - `additional_ends`: list\n\n                A list of additional nodes to highlight in red as ending nodes. Default is an empty list.\n\n        - `subpath_constraints`: list\n\n            A list of subpaths to highlight in the graph as dashed edges, of various colors. Each subpath is a list of edges. Default is an empty list. There is no association between the subpath colors and the path colors.\n\n        - `draw_options`: dict\n\n            A dictionary with the following keys:\n\n            - `show_graph_edges`: bool\n\n                Whether to show the edges of the graph. Default is `True`.\n\n            - `show_edge_weights`: bool\n\n                Whether to show the edge weights in the graph from the `flow_attr`. Default is `False`.\n\n            - `show_node_weights`: bool\n\n                Whether to show the node weights in the graph from the `flow_attr`. Default is `False`.\n\n            - `show_path_weights`: bool\n\n                Whether to show the path weights in the graph on every edge. Default is `False`.\n\n            - `show_path_weight_on_first_edge`: bool\n\n                Whether to show the path weight on the first edge of the path. Default is `True`.\n\n            - `pathwidth`: float\n\n                The width of the path to be drawn. Default is `3.0`.\n\n            - `style`: str\n\n                The style of the drawing. Available options: `default`, `points`.\n\n        \"\"\"\n\n        if len(paths) != len(weights) and len(weights) &gt; 0:\n            raise ValueError(f\"{__name__}: Paths and weights must have the same length, if provided.\")\n\n        try:\n            import graphviz as gv\n\n            dot = gv.Digraph(format=\"pdf\")\n            dot.graph_attr[\"rankdir\"] = \"LR\"  # Display the graph in landscape mode\n\n            style = draw_options.get(\"style\", \"default\")\n            if style == \"default\":\n                dot.node_attr[\"shape\"] = \"rectangle\"  # Rectangle nodes\n                dot.node_attr[\"style\"] = \"rounded\"  # Rounded rectangle nodes\n            elif style == \"points\":\n                dot.node_attr[\"shape\"] = \"point\"  # Point nodes\n                dot.node_attr[\"style\"] = \"filled\"  # Filled point nodes\n                # dot.node_attr['label'] = '' \n                dot.node_attr['width'] = '0.1' \n\n            colors = [\n                \"red\",\n                \"blue\",\n                \"green\",\n                \"purple\",\n                \"brown\",\n                \"cyan\",\n                \"yellow\",\n                \"pink\",\n                \"grey\",\n                \"chocolate\",\n                \"darkblue\",\n                \"darkolivegreen\",\n                \"darkslategray\",\n                \"deepskyblue2\",\n                \"cadetblue3\",\n                \"darkmagenta\",\n                \"goldenrod1\"\n            ]\n\n            dot.attr('node', fontname='Arial')\n\n            if draw_options.get(\"show_graph_edges\", True):\n                # drawing nodes\n                for node in G.nodes():\n                    color = \"black\"\n                    penwidth = \"1.0\"\n                    if node in additional_starts:\n                        color = \"green\"\n                        penwidth = \"2.0\"\n                    elif node in additional_ends:\n                        color = \"red\"\n                        penwidth = \"2.0\"\n\n                    if draw_options.get(\"show_node_weights\", False) and flow_attr is not None and flow_attr in G.nodes[node]:\n                        label = f\"{G.nodes[node][flow_attr]}\\\\n{node}\" if style != \"points\" else \"\"\n                        dot.node(\n                            name=str(node),\n                            label=label,\n                            shape=\"record\",\n                            color=color, \n                            penwidth=penwidth)\n                    else:\n                        label = str(node) if style != \"points\" else \"\"\n                        dot.node(\n                            name=str(node), \n                            label=str(node), \n                            color=color, \n                            penwidth=penwidth)\n\n                # drawing edges\n                for u, v, data in G.edges(data=True):\n                    if draw_options.get(\"show_edge_weights\", False):\n                        dot.edge(\n                            tail_name=str(u), \n                            head_name=str(v), \n                            label=str(data.get(flow_attr,\"\")),\n                            fontname=\"Arial\",)\n                    else:\n                        dot.edge(\n                            tail_name=str(u), \n                            head_name=str(v))\n\n            for index, path in enumerate(paths):\n                pathColor = colors[index % len(colors)]\n                for i in range(len(path) - 1):\n                    if i == 0 and draw_options.get(\"show_path_weight_on_first_edge\", True) or \\\n                        draw_options.get(\"show_path_weights\", True):\n                        dot.edge(\n                            str(path[i]),\n                            str(path[i + 1]),\n                            fontcolor=pathColor,\n                            color=pathColor,\n                            penwidth=str(draw_options.get(\"pathwidth\", 3.0)),\n                            label=str(weights[index]) if len(weights) &gt; 0 else \"\",\n                            fontname=\"Arial\",\n                        )\n                    else:\n                        dot.edge(\n                            str(path[i]),\n                            str(path[i + 1]),\n                            color=pathColor,\n                            penwidth=str(draw_options.get(\"pathwidth\", 3.0)),\n                            )\n                if len(path) == 1:\n                    dot.node(str(path[0]), color=pathColor, penwidth=str(draw_options.get(\"pathwidth\", 3.0)))        \n\n            for index, path in enumerate(subpath_constraints):\n                pathColor = colors[index % len(colors)]\n                for i in range(len(path)):\n                    if len(path[i]) != 2:\n                        utils.logger.error(f\"{__name__}: Subpaths must be lists of edges.\")\n                        raise ValueError(\"Subpaths must be lists of edges.\")\n                    dot.edge(\n                        str(path[i][0]),\n                        str(path[i][1]),\n                        color=pathColor,\n                        style=\"dashed\",\n                        penwidth=\"2.0\"\n                        )\n\n            dot.render(outfile=filename, view=False, cleanup=True)\n\n        except ImportError:\n            utils.logger.error(f\"{__name__}: graphviz module not found. Please install it via pip (pip install graphviz).\")\n            raise ImportError(\"graphviz module not found. Please install it via pip (pip install graphviz).\")\n</code></pre>"},{"location":"utils.html#flowpaths.utils.graphutils.fpid","title":"fpid","text":"<pre><code>fpid(G) -&gt; str\n</code></pre> <p>Returns a unique identifier for the given graph.</p> Source code in <code>flowpaths/utils/graphutils.py</code> <pre><code>def fpid(G) -&gt; str:\n    \"\"\"\n    Returns a unique identifier for the given graph.\n    \"\"\"\n    if isinstance(G, nx.DiGraph):\n        if \"id\" in G.graph:\n            return G.graph[\"id\"]\n\n    return str(id(G))\n</code></pre>"},{"location":"utils.html#flowpaths.utils.graphutils.get_subgraph_between_topological_nodes","title":"get_subgraph_between_topological_nodes","text":"<pre><code>get_subgraph_between_topological_nodes(\n    graph: DiGraph,\n    topo_order: list,\n    left: int,\n    right: int,\n) -&gt; nx.DiGraph\n</code></pre> <p>Create a subgraph with the nodes between left and right in the topological order,  including the edges between them, but also the edges from these nodes that are incident to nodes outside this range.</p> Source code in <code>flowpaths/utils/graphutils.py</code> <pre><code>def get_subgraph_between_topological_nodes(graph: nx.DiGraph, topo_order: list, left: int, right: int) -&gt; nx.DiGraph:\n    \"\"\"\n    Create a subgraph with the nodes between left and right in the topological order, \n    including the edges between them, but also the edges from these nodes that are incident to nodes outside this range.\n    \"\"\"\n\n    if left &lt; 0 or right &gt;= len(topo_order):\n        utils.logger.error(f\"{__name__}: Invalid range for topological order: {left}, {right}.\")\n        raise ValueError(\"Invalid range for topological order\")\n    if left &gt; right:\n        utils.logger.error(f\"{__name__}: Invalid range for topological order: {left}, {right}.\")\n        raise ValueError(\"Invalid range for topological order\")\n\n    # Create a subgraph with the nodes between left and right in the topological order\n    subgraph = nx.DiGraph()\n    if \"id\" in graph.graph:\n        subgraph.graph[\"id\"] = graph.graph[\"id\"]\n    for i in range(left, right):\n        subgraph.add_node(topo_order[i], **graph.nodes[topo_order[i]])\n\n    fixed_nodes = set(subgraph.nodes())\n\n    # Add the edges between the nodes in the subgraph\n    for u, v in graph.edges():\n        if u in fixed_nodes or v in fixed_nodes:\n            subgraph.add_edge(u, v, **graph[u][v])\n            if u not in fixed_nodes:\n                subgraph.add_node(u, **graph.nodes[u])\n            if v not in fixed_nodes:\n                subgraph.add_node(v, **graph.nodes[v])\n\n    return subgraph\n</code></pre>"},{"location":"utils.html#flowpaths.utils.graphutils.max_bottleneck_path","title":"max_bottleneck_path","text":"<pre><code>max_bottleneck_path(\n    G: DiGraph, flow_attr\n) -&gt; tuple\n</code></pre> <p>Computes the maximum bottleneck path in a directed graph.</p>"},{"location":"utils.html#flowpaths.utils.graphutils.max_bottleneck_path--parameters","title":"Parameters","text":"<ul> <li> <p><code>G</code>: nx.DiGraph</p> <p>A directed graph where each edge has a flow attribute.</p> </li> <li> <p><code>flow_attr</code>: str</p> <p>The flow attribute from where to get the flow values.</p> </li> </ul>"},{"location":"utils.html#flowpaths.utils.graphutils.max_bottleneck_path--returns","title":"Returns","text":"<ul> <li> <p>tuple: A tuple containing:</p> <ul> <li>The value of the maximum bottleneck.</li> <li>The path corresponding to the maximum bottleneck (list of nodes).     If no s-t flow exists in the network, returns (None, None).</li> </ul> </li> </ul> Source code in <code>flowpaths/utils/graphutils.py</code> <pre><code>def max_bottleneck_path(G: nx.DiGraph, flow_attr) -&gt; tuple:\n    \"\"\"\n    Computes the maximum bottleneck path in a directed graph.\n\n    Parameters\n    ----------\n    - `G`: nx.DiGraph\n\n        A directed graph where each edge has a flow attribute.\n\n    - `flow_attr`: str\n\n        The flow attribute from where to get the flow values.\n\n    Returns\n    --------\n\n    - tuple: A tuple containing:\n\n        - The value of the maximum bottleneck.\n        - The path corresponding to the maximum bottleneck (list of nodes).\n            If no s-t flow exists in the network, returns (None, None).\n    \"\"\"\n    B = dict()\n    maxInNeighbor = dict()\n    maxBottleneckSink = None\n\n    # Computing the B values with DP\n    for v in nx.topological_sort(G):\n        if G.in_degree(v) == 0:\n            B[v] = float(\"inf\")\n        else:\n            B[v] = float(\"-inf\")\n            for u in G.predecessors(v):\n                uBottleneck = min(B[u], G.edges[u, v][flow_attr])\n                if uBottleneck &gt; B[v]:\n                    B[v] = uBottleneck\n                    maxInNeighbor[v] = u\n            if G.out_degree(v) == 0:\n                if maxBottleneckSink is None or B[v] &gt; B[maxBottleneckSink]:\n                    maxBottleneckSink = v\n\n    # If no s-t flow exists in the network\n    if B[maxBottleneckSink] == 0:\n        return None, None\n\n    # Recovering the path of maximum bottleneck\n    reverse_path = [maxBottleneckSink]\n    while G.in_degree(reverse_path[-1]) &gt; 0:\n        reverse_path.append(maxInNeighbor[reverse_path[-1]])\n\n    return B[maxBottleneckSink], list(reversed(reverse_path))\n</code></pre>"},{"location":"utils.html#flowpaths.utils.graphutils.max_occurrence","title":"max_occurrence","text":"<pre><code>max_occurrence(\n    seq,\n    paths_in_DAG,\n    edge_lengths: dict = {},\n) -&gt; int\n</code></pre> <p>Check what is the maximum number of edges of seq that appear in some path in the list paths_in_DAG. </p> <p>This assumes paths_in_DAG are paths in a directed acyclic graph. </p>"},{"location":"utils.html#flowpaths.utils.graphutils.max_occurrence--parameters","title":"Parameters","text":"<ul> <li>seq (list): The sequence of edges to check.</li> <li>paths (list): The list of paths to check against, as lists of nodes.</li> </ul>"},{"location":"utils.html#flowpaths.utils.graphutils.max_occurrence--returns","title":"Returns","text":"<ul> <li>int: the largest number of seq edges that appear in some path in paths_in_DAG</li> </ul> Source code in <code>flowpaths/utils/graphutils.py</code> <pre><code>def max_occurrence(seq, paths_in_DAG, edge_lengths: dict = {}) -&gt; int:\n    \"\"\"\n    Check what is the maximum number of edges of seq that appear in some path in the list paths_in_DAG. \n\n    This assumes paths_in_DAG are paths in a directed acyclic graph. \n\n    Parameters\n    ----------\n    - seq (list): The sequence of edges to check.\n    - paths (list): The list of paths to check against, as lists of nodes.\n\n    Returns\n    -------\n    - int: the largest number of seq edges that appear in some path in paths_in_DAG\n    \"\"\"\n    max_occurence = 0\n    for path in paths_in_DAG:\n        path_edges = set([(path[i], path[i + 1]) for i in range(len(path) - 1)])\n        # Check how many seq edges are in path_edges\n        occurence = 0\n        for edge in seq:\n            if edge in path_edges:\n                occurence += edge_lengths.get(edge, 1)\n        if occurence &gt; max_occurence:\n            max_occurence = occurence\n\n    return max_occurence\n</code></pre>"},{"location":"utils.html#flowpaths.utils.graphutils.read_graph","title":"read_graph","text":"<pre><code>read_graph(\n    graph_raw,\n) -&gt; nx.DiGraph\n</code></pre> <p>Parse a single graph block from a list of lines.</p> <p>Accepts one or more header lines at the beginning (each prefixed by \u2018#\u2019), followed by a line containing the number of vertices (n), then any number of edge lines of the form: \u201cu v w\u201d (whitespace-separated).</p> Subpath constraint lines <p>Lines starting with \u201c#S\u201d define a (directed) subpath constraint as a sequence of nodes: \u201c#S n1 n2 n3 \u2026\u201d. For each such line we build the list of consecutive edge tuples [(n1,n2), (n2,n3), \u2026] and append this edge-list (the subpath) to G.graph[\u201cconstraints\u201d]. Duplicate filtering is applied on the whole node sequence: if an identical sequence of nodes has already appeared in a previous \u201c#S\u201d line, the entire subpath line is ignored (its edges are not added again). Different subpaths may</p> <p>share edges; they are kept as separate entries. After all graph edges are parsed, every constraint edge is validated to ensure it exists in the graph; a missing edge raises ValueError.</p> Example block Source code in <code>flowpaths/utils/graphutils.py</code> <pre><code>def read_graph(graph_raw) -&gt; nx.DiGraph:\n    \"\"\"\n    Parse a single graph block from a list of lines.\n\n    Accepts one or more header lines at the beginning (each prefixed by '#'),\n    followed by a line containing the number of vertices (n), then any number\n    of edge lines of the form: \"u v w\" (whitespace-separated).\n\n    Subpath constraint lines:\n        Lines starting with \"#S\" define a (directed) subpath constraint as a\n        sequence of nodes: \"#S n1 n2 n3 ...\". For each such line we build the\n        list of consecutive edge tuples [(n1,n2), (n2,n3), ...] and append this\n        edge-list (the subpath) to G.graph[\"constraints\"]. Duplicate filtering\n        is applied on the whole node sequence: if an identical sequence of\n        nodes has already appeared in a previous \"#S\" line, the entire subpath\n        line is ignored (its edges are not added again). Different subpaths may\n    share edges; they are kept as separate entries. After all graph edges\n    are parsed, every constraint edge is validated to ensure it exists in\n    the graph; a missing edge raises ValueError.\n\n    Example block:\n        # graph number = 1 name = foo\n        # any other header line\n        #S a b c d          (adds subpath [(a,b),(b,c),(c,d)])\n        #S b c e            (adds subpath [(b,c),(c,e)])\n        #S a b c d          (ignored: exact node sequence already seen)\n        5\n        a b 1.0\n        b c 2.5\n        c d 3.0\n        c e 4.0\n    \"\"\"\n\n    # Collect leading header lines (prefixed by '#') and parse constraint lines prefixed by '#S'\n    idx = 0\n    header_lines = []\n    constraint_subpaths = []       # list of subpaths, each a list of (u,v) edge tuples\n    subpaths_seen = set()          # set of full node sequences (tuples) to filter duplicate subpaths\n    while idx &lt; len(graph_raw) and graph_raw[idx].lstrip().startswith(\"#\"):\n        stripped = graph_raw[idx].lstrip()\n        # Subpath constraint line: starts with '#S'\n        if stripped.startswith(\"#S\"):\n            # Remove leading '#S' and split remaining node sequence\n            nodes_part = stripped[2:].strip()  # drop '#S'\n            if nodes_part:\n                nodes_seq = nodes_part.split()\n                seq_key = tuple(nodes_seq)\n                # Skip if this exact subpath sequence already processed\n                if seq_key not in subpaths_seen:\n                    subpaths_seen.add(seq_key)\n                    edges_list = [(u, v) for u, v in zip(nodes_seq, nodes_seq[1:])]\n                    # Only append if there is at least one edge (&gt;=2 nodes)\n                    if edges_list:\n                        constraint_subpaths.append(edges_list)\n        else:\n            # Regular header line (remove leading '#') for metadata / id extraction\n            header_lines.append(stripped.lstrip(\"#\").strip())\n        idx += 1\n\n    # Determine graph id from the first (non-#S) header line if present\n    graph_id = header_lines[0] if header_lines else str(id(graph_raw))\n\n    # Skip blank lines before the vertex-count line\n    while idx &lt; len(graph_raw) and graph_raw[idx].strip() == \"\":\n        idx += 1\n\n    if idx &gt;= len(graph_raw):\n        error_msg = \"Graph block missing vertex-count line.\"\n        utils.logger.error(f\"{__name__}: {error_msg}\")\n        raise ValueError(error_msg)\n    # Parse number of vertices (kept for information; not used to count edges here)\n    try:\n        n = int(graph_raw[idx].strip())\n    except ValueError:\n        utils.logger.error(f\"{__name__}: Invalid vertex-count line: {graph_raw[idx].rstrip()}.\")\n        raise\n\n    idx += 1\n\n    G = nx.DiGraph()\n    G.graph[\"id\"] = graph_id\n    # Store (possibly empty) list of subpaths (each a list of edge tuples)\n    G.graph[\"constraints\"] = constraint_subpaths\n\n    if n == 0:\n        utils.logger.info(f\"Graph {graph_id} has 0 vertices.\")\n        return G\n\n    # Parse edges: skip blanks and comment/header lines defensively\n    for line in graph_raw[idx:]:\n        if not line.strip() or line.lstrip().startswith('#'):\n            continue\n        elements = line.split()\n        if len(elements) != 3:\n            utils.logger.error(f\"{__name__}: Invalid edge format: {line.rstrip()}\")\n            raise ValueError(f\"Invalid edge format: {line.rstrip()}\")\n        u, v, w_str = elements\n        try:\n            w = float(w_str)\n        except ValueError:\n            utils.logger.error(f\"{__name__}: Invalid weight value in edge: {line.rstrip()}\")\n            raise\n        G.add_edge(u.strip(), v.strip(), flow=w)\n\n    # Validate that every constraint edge exists in the graph\n    for subpath in constraint_subpaths:\n        for (u, v) in subpath:\n            if not G.has_edge(u, v):\n                utils.logger.error(f\"{__name__}: Constraint edge ({u}, {v}) not found in graph {graph_id} edges.\")\n                raise ValueError(f\"Constraint edge ({u}, {v}) not found in graph edges.\")\n\n    G.graph[\"n\"] = G.number_of_nodes()\n    G.graph[\"m\"] = G.number_of_edges()\n    # Lazy import here to avoid circular import at module load time\n    from flowpaths import stdigraph as _stdigraph  # type: ignore\n    G.graph[\"w\"] = _stdigraph.stDiGraph(G).get_width()\n\n    return G\n</code></pre>"},{"location":"utils.html#flowpaths.utils.graphutils.read_graph--graph-number-1-name-foo","title":"graph number = 1 name = foo","text":""},{"location":"utils.html#flowpaths.utils.graphutils.read_graph--any-other-header-line","title":"any other header line","text":""},{"location":"utils.html#flowpaths.utils.graphutils.read_graph--s-a-b-c-d-adds-subpath-abbccd","title":"S a b c d          (adds subpath [(a,b),(b,c),(c,d)])","text":""},{"location":"utils.html#flowpaths.utils.graphutils.read_graph--s-b-c-e-adds-subpath-bcce","title":"S b c e            (adds subpath [(b,c),(c,e)])","text":""},{"location":"utils.html#flowpaths.utils.graphutils.read_graph--s-a-b-c-d-ignored-exact-node-sequence-already-seen","title":"S a b c d          (ignored: exact node sequence already seen)","text":"<p>5 a b 1.0 b c 2.5 c d 3.0 c e 4.0</p>"},{"location":"utils.html#flowpaths.utils.graphutils.read_graphs","title":"read_graphs","text":"<pre><code>read_graphs(filename)\n</code></pre> <p>Read one or more graphs from a file.</p> <p>Supports graphs whose header consists of one or multiple consecutive lines prefixed by \u2018#\u2019. Each graph block is:     - one or more header lines starting with \u2018#\u2019     - one line with the number of vertices (n)     - zero or more edge lines \u201cu v w\u201d</p> <p>Graphs are delimited by the start of the next header (a line starting with \u2018#\u2019) or the end of file.</p> Source code in <code>flowpaths/utils/graphutils.py</code> <pre><code>def read_graphs(filename):\n    \"\"\"\n    Read one or more graphs from a file.\n\n    Supports graphs whose header consists of one or multiple consecutive lines\n    prefixed by '#'. Each graph block is:\n        - one or more header lines starting with '#'\n        - one line with the number of vertices (n)\n        - zero or more edge lines \"u v w\"\n\n    Graphs are delimited by the start of the next header (a line starting with '#')\n    or the end of file.\n    \"\"\"\n    with open(filename, \"r\") as f:\n        lines = f.readlines()\n\n    graphs = []\n    n_lines = len(lines)\n    i = 0\n\n    # Iterate through the file, capturing blocks that start with one or more '#' lines\n    while i &lt; n_lines:\n        # Move to the start of the next graph header\n        while i &lt; n_lines and not lines[i].lstrip().startswith('#'):\n            i += 1\n        if i &gt;= n_lines:\n            break\n\n        start = i\n\n        # Consume all consecutive header lines for this graph\n        while i &lt; n_lines and lines[i].lstrip().startswith('#'):\n            i += 1\n\n        # Advance until the next header line (start of next graph) or EOF\n        j = i\n        while j &lt; n_lines and not lines[j].lstrip().startswith('#'):\n            j += 1\n\n        graphs.append(read_graph(lines[start:j]))\n        i = j\n\n    return graphs\n</code></pre>"}]}